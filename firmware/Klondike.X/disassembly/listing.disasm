Disassembly Listing for Klondike
Generated From:
/home/chris/Dev/klondike/firmware/Klondike.X/dist/K16/production/Klondike.X.production.cof
Aug 25, 2013 7:05:40 AM

---  /opt/microchip/xc8/v1.12/sources/wmul.c  -----------------------------------------------------------
1:             unsigned int
2:             __wmul(unsigned int multiplier, unsigned int multiplicand)
3:             {
4:             	unsigned int	product = 0;
0A1B  01DA     CLRF i_718
0A1C  01DB     CLRF i
17EB  01F4     CLRF product
17EC  01F5     CLRF 0x75
5:             
6:             	do {
7:             		if(multiplier & 1)
0A1D  1C56     BTFSS dest, 0x0
0A1E  2A23     GOTO 0x223
17ED  1C70     BTFSS multiplicand, 0x0
17EE  2FF3     GOTO 0x7F3
8:             			product += multiplicand;
0A1F  0858     MOVF off, W
0A20  07DA     ADDWF i_718, F
0A21  0859     MOVF x, W
0A22  3DDB     ADDWFC i, F
17EF  0872     MOVF product, W
17F0  07F4     ADDWF product, F
17F1  0873     MOVF 0x73, W
17F2  3DF5     ADDWFC 0x75, F
9:             		multiplicand <<= 1;
0A23  35D8     LSLF off, F
0A24  0DD9     RLF x, F
17F3  35F2     LSLF product, F
17F4  0DF3     RLF 0x73, F
10:            		multiplier >>= 1;
0A25  36D7     LSRF product, F
0A26  0CD6     RRF dest, F
17F5  36F1     LSRF 0x71, F
17F6  0CF0     RRF multiplicand, F
11:            	} while(multiplier != 0);
0A27  0857     MOVF product, W
0A28  0456     IORWF dest, W
0A29  1D03     BTFSS STATUS, 0x2
0A2A  2A1D     GOTO 0x21D
17F7  0871     MOVF 0x71, W
17F8  0470     IORWF multiplicand, W
17F9  1D03     BTFSS STATUS, 0x2
17FA  2FED     GOTO 0x7ED
12:            	return product;
0A2B  085B     MOVF i, W
0A2C  00D7     MOVWF product
0A2D  085A     MOVF i_718, W
0A2E  00D6     MOVWF dest
17FB  0875     MOVF 0x75, W
17FC  00F1     MOVWF 0x71
17FD  0874     MOVF product, W
17FE  00F0     MOVWF multiplicand
13:            }
0A2F  0008     RETURN
17FF  0008     RETURN
---  /opt/microchip/xc8/v1.12/sources/memset.c  ---------------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0559  0857     MOVF product, W
055A  00DE     MOVWF split
055B  0856     MOVF dest, W
055C  00DD     MOVWF y
19:            	while(n--)
055D  3001     MOVLW 0x1
055E  02DA     SUBWF i_718, F
055F  3000     MOVLW 0x0
0560  3BDB     SUBWFB i, F
0561  0A5A     INCF i_718, W
0562  1903     BTFSC STATUS, 0x2
0563  0A5B     INCF i, W
0564  1903     BTFSC STATUS, 0x2
0565  0008     RETURN
0571  2D5D     GOTO 0x55D
20:            		*p++ = c;
0566  0858     MOVF off, W
0567  00DC     MOVWF work
0568  085D     MOVF y, W
0569  0086     MOVWF FSR1L
056A  085E     MOVF split, W
056B  0087     MOVWF FSR1H
056C  085C     MOVF work, W
056D  0081     MOVWF INDF1
056E  0ADD     INCF y, F
056F  1903     BTFSC STATUS, 0x2
0570  0ADE     INCF split, F
21:            	return p1;
22:            }
0572  0020     MOVLB 0x0
---  /opt/microchip/xc8/v1.12/sources/lwdiv.c  ----------------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
0A30  01DB     CLRF i
0A31  01DC     CLRF work
10:            {
0A32  0857     MOVF product, W
0A33  0456     IORWF dest, W
0A34  1903     BTFSC STATUS, 0x2
0A35  2A50     GOTO 0x250
11:            	unsigned int	quotient;
0A36  01DA     CLRF i_718
12:            	unsigned char	counter;
0A38  1BD7     BTFSC product, 0x7
0A39  2A3D     GOTO 0x23D
0A3C  2A37     GOTO 0x237
13:            
0A3A  35D6     LSLF dest, F
0A3B  0DD7     RLF product, F
14:            	quotient = 0;
0A37  0ADA     INCF i_718, F
15:            	if(divisor != 0) {
16:            		counter = 1;
17:            		while((divisor & 0x8000) == 0) {
0A3D  35DB     LSLF i, F
0A3E  0DDC     RLF work, F
18:            			divisor <<= 1;
0A3F  0857     MOVF product, W
0A40  0259     SUBWF x, W
0A41  1D03     BTFSS STATUS, 0x2
0A42  2A45     GOTO 0x245
0A43  0856     MOVF dest, W
0A44  0258     SUBWF off, W
0A45  1C03     BTFSS STATUS, 0x0
0A46  2A4C     GOTO 0x24C
19:            			counter++;
0A47  0856     MOVF dest, W
0A48  02D8     SUBWF off, F
0A49  0857     MOVF product, W
0A4A  3BD9     SUBWFB x, F
20:            		}
0A4B  145B     BSF i, 0x0
21:            		do {
22:            			quotient <<= 1;
0A4C  36D7     LSRF product, F
0A4D  0CD6     RRF dest, F
23:            			if(divisor <= dividend) {
0A4E  0BDA     DECFSZ i_718, F
0A4F  2A3D     GOTO 0x23D
24:            				dividend -= divisor;
25:            				quotient |= 1;
0A50  085C     MOVF work, W
0A51  00D7     MOVWF product
0A52  085B     MOVF i, W
0A53  00D6     MOVWF dest
26:            			}
0A54  0008     RETURN
27:            			divisor >>= 1;
28:            		} while(--counter != 0);
29:            	}
30:            	return quotient;
31:            }
---  /opt/microchip/xc8/v1.12/sources/bmul.c  -----------------------------------------------------------
1:             unsigned char
2:             __bmul(unsigned char multiplier, unsigned char multiplicand)
3:             {
0D2E  0020     MOVLB 0x0
17DF  00F1     MOVWF 0x71
4:             	unsigned char	product = 0;
0D30  01D7     CLRF product
17E0  01F2     CLRF product
5:             
6:             	do {
7:             		if(multiplier & 1)
0D32  1858     BTFSC off, 0x0
17E2  1871     BTFSC 0x71, 0x0
8:             			product += multiplicand;
0D31  0856     MOVF dest, W
0D33  07D7     ADDWF product, F
17E1  0870     MOVF multiplicand, W
17E3  07F2     ADDWF product, F
9:             		multiplicand <<= 1;
0D34  35D6     LSLF dest, F
17E4  35F0     LSLF multiplicand, F
10:            		multiplier >>= 1;
0D35  36D8     LSRF off, F
17E5  36F1     LSRF 0x71, F
11:            	} while(multiplier != 0);
0D36  08D8     MOVF off, F
0D37  1D03     BTFSS STATUS, 0x2
0D38  2D31     GOTO 0x531
17E6  08F1     MOVF 0x71, F
17E7  1D03     BTFSS STATUS, 0x2
17E8  2FE1     GOTO 0x7E1
12:            	return product;
0D39  0857     MOVF product, W
17E9  0872     MOVF product, W
13:            }
0D3A  0008     RETURN
17EA  0008     RETURN
14:            
---  /opt/microchip/xc8/v1.12/sources/awdiv.c  ----------------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
0FC0  01DB     CLRF i
10:            {
0FC1  1FD7     BTFSS product, 0x7
0FC2  2FCA     GOTO 0x7CA
11:            	signed int	quotient;
0FC3  09D6     COMF dest, F
0FC4  09D7     COMF product, F
0FC5  0AD6     INCF dest, F
0FC6  1903     BTFSC STATUS, 0x2
0FC7  0AD7     INCF product, F
12:            	unsigned char	counter, sign;
0FC8  01DB     CLRF i
0FC9  0ADB     INCF i, F
13:            
14:            	sign = 0;
0FCA  1FD9     BTFSS x, 0x7
0FCB  2FD3     GOTO 0x7D3
15:            	if(divisor < 0) {
0FCC  09D8     COMF off, F
0FCD  09D9     COMF x, F
0FCE  0AD8     INCF off, F
0FCF  1903     BTFSC STATUS, 0x2
0FD0  0AD9     INCF x, F
16:            		divisor = -divisor;
0FD1  3001     MOVLW 0x1
0FD2  06DB     XORWF i, F
17:            		sign = 1;
18:            	}
0FD3  01DC     CLRF work
0FD4  01DD     CLRF y
19:            	if(dividend < 0) {
0FD5  0857     MOVF product, W
0FD6  0456     IORWF dest, W
0FD7  1903     BTFSC STATUS, 0x2
0FD8  2FF3     GOTO 0x7F3
20:            		dividend = -dividend;
0FD9  01DA     CLRF i_718
21:            		sign ^= 1;
0FDB  1BD7     BTFSC product, 0x7
0FDC  2FE0     GOTO 0x7E0
0FDF  2FDA     GOTO 0x7DA
22:            	}
0FDD  35D6     LSLF dest, F
0FDE  0DD7     RLF product, F
23:            	quotient = 0;
0FDA  0ADA     INCF i_718, F
24:            	if(divisor != 0) {
25:            		counter = 1;
26:            		while((divisor & 0x8000U) == 0) {
0FE0  35DC     LSLF work, F
0FE1  0DDD     RLF y, F
27:            			divisor <<= 1;
0FE2  0857     MOVF product, W
0FE3  0259     SUBWF x, W
0FE4  1D03     BTFSS STATUS, 0x2
0FE5  2FE8     GOTO 0x7E8
0FE6  0856     MOVF dest, W
0FE7  0258     SUBWF off, W
0FE8  1C03     BTFSS STATUS, 0x0
0FE9  2FEF     GOTO 0x7EF
28:            			counter++;
0FEA  0856     MOVF dest, W
0FEB  02D8     SUBWF off, F
0FEC  0857     MOVF product, W
0FED  3BD9     SUBWFB x, F
29:            		}
0FEE  145C     BSF work, 0x0
30:            		do {
31:            			quotient <<= 1;
0FEF  36D7     LSRF product, F
0FF0  0CD6     RRF dest, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0FF1  0BDA     DECFSZ i_718, F
0FF2  2FE0     GOTO 0x7E0
33:            				dividend -= divisor;
34:            				quotient |= 1;
0FF3  085B     MOVF i, W
0FF4  1903     BTFSC STATUS, 0x2
0FF5  2FFB     GOTO 0x7FB
35:            			}
0FF6  09DC     COMF work, F
0FF7  09DD     COMF y, F
0FF8  0ADC     INCF work, F
0FF9  1903     BTFSC STATUS, 0x2
0FFA  0ADD     INCF y, F
36:            			*(unsigned int *)&divisor >>= 1;
0FFB  085D     MOVF y, W
0FFC  00D7     MOVWF product
0FFD  085C     MOVF work, W
0FFE  00D6     MOVWF dest
37:            		} while(--counter != 0);
0FFF  0008     RETURN
38:            	}
39:            	if(sign)
40:            		quotient = -quotient;
41:            	return quotient;
42:            }
---  /home/chris/Dev/klondike/firmware/USB/usb_function_generic.c  --------------------------------------
1:             /******************************************************************************
2:               File Information:
3:                   FileName:       usb_function_generic.c
4:                   Dependencies:   See INCLUDES section below
5:                   Processor:      Microchip USB Microcontrollers
6:                   Hardware:       See "<install directory>\Microchip\Help" for details.
7:                                   
8:                   Compiler:       C18, C30, or C32
9:                   Company:        Microchip Technology, Inc.
10:                
11:                  Software License Agreement:
12:                
13:                  The software supplied herewith by Microchip Technology Incorporated
14:                  (the "Company") for its PIC(R) Microcontroller is intended and
15:                  supplied to you, the Company's customer, for use solely and
16:                  exclusively on Microchip PIC Microcontroller products. The
17:                  software is owned by the Company and/or its supplier, and is
18:                  protected under applicable copyright laws. All rights are reserved.
19:                  Any use in violation of the foregoing restrictions may subject the
20:                  user to criminal sanctions under applicable laws, as well as to
21:                  civil liability for the breach of the terms and conditions of this
22:                  license.
23:                
24:                  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
25:                  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
26:                  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
27:                  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
28:                  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
29:                  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
30:                
31:                   Change History:
32:                   Rev         Description
33:                
34:              Summary:
35:                This file contains all of functions, macros, definitions, variables,
36:                datatypes, etc. that are required for usage with vendor class function
37:                drivers. This file should be included in projects that use vendor class
38:                \function drivers. Vendor class function drivers include MCHPUSB
39:                (Microchip's custom class driver), WinUSB, and LibUSB.
40:                
41:                
42:                
43:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\Generic
44:                Device Driver" directory.
45:              Description:
46:                USB Vender Class Custom Driver Header File
47:                
48:                This file contains functions, macros, definitions, variables,
49:                datatypes, etc. that are required for use of vendor class function
50:                drivers. This file should be included in projects that use vendor class
51:                \function drivers.
52:                
53:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\Generic
54:                Device Driver" directory.
55:                
56:                When including this file in a new project, this file can either be
57:                referenced from the directory in which it was installed or copied
58:                directly into the user application folder. If the first method is
59:                chosen to keep the file located in the folder in which it is installed
60:                then include paths need to be added so that the library and the
61:                application both know where to reference each others files. If the
62:                application folder is located in the same folder as the Microchip
63:                folder (like the current demo folders), then the following include
64:                paths need to be added to the application's project:
65:                
66:                ..\\..\\Microchip\\Include
67:                .
68:                
69:                If a different directory structure is used, modify the paths as
70:                required. An example using absolute paths instead of relative paths
71:                would be the following:
72:                
73:                C:\\Microchip Solutions\\Microchip\\Include
74:                
75:                C:\\Microchip Solutions\\My Demo Application                               
76:              ******************************************************************************/
77:            
78:            //DOM-IGNORE-BEGIN
79:            /********************************************************************
80:             File Description:
81:            
82:             Change History:
83:              Rev    Description
84:              ----   -----------
85:              2.6    Minor changes in include file structure.
86:              2.9h   Implemented USBCheckVendorRequest() function, in order to
87:                     support MS OS Feature Descriptor handling.
88:            ********************************************************************
89:            //DOM-IGNORE-END
90:            
91:            ******************************************************************************/
92:            
93:            /** I N C L U D E S **********************************************************/
94:            #include "USB/usb.h"
95:            #include "./USB/usb_function_generic.h"
96:            
97:            #if defined(USB_USE_GEN)
98:            
99:            /** V A R I A B L E S ********************************************************/
100:           extern volatile CTRL_TRF_SETUP SetupPkt;    //Common buffer that receives the 
101:                                                       //8-byte SETUP packet data from the 
102:                                                       //host during control transfer 
103:                                                       //requests.
104:           
105:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
106:           
107:           /** D E C L A R A T I O N S **************************************************/
108:           
109:           /** U S E R  A P I ***********************************************************/
110:           
111:           /********************************************************************
112:               Function:
113:                   USB_HANDLE USBGenWrite(BYTE ep, BYTE* data, WORD len)
114:                   
115:               Summary:
116:                   Sends the specified data out the specified endpoint
117:           
118:               Description:
119:                   This function sends the specified data out the specified 
120:                   endpoint and returns a handle to the transfer information.
121:           
122:                   Typical Usage:
123:                   <code>
124:                   //make sure that the last transfer isn't busy by checking the handle
125:                   if(!USBHandleBusy(USBGenericInHandle))
126:                   {
127:                       //Send the data contained in the INPacket[] array out on
128:                       //  endpoint USBGEN_EP_NUM
129:                       USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM,(BYTE*)&INPacket[0],sizeof(INPacket));
130:                   }
131:                   </code>
132:                   
133:               PreCondition:
134:                   None
135:                   
136:               Parameters:
137:                   BYTE ep    - the endpoint you want to send the data out of
138:                   BYTE* data - pointer to the data that you wish to send
139:                   WORD len   - the length of the data that you wish to send
140:                   
141:               Return Values:
142:                   USB_HANDLE - a handle for the transfer.  This information
143:                   should be kept to track the status of the transfer
144:                   
145:               Remarks:
146:                   None
147:             
148:            *******************************************************************/
149:            // Implemented as a macro. See usb_function_generic.h
150:           
151:           /********************************************************************
152:               Function:
153:                   USB_HANDLE USBGenRead(BYTE ep, BYTE* data, WORD len)
154:                   
155:               Summary:
156:                   Receives the specified data out the specified endpoint
157:                   
158:               Description:
159:                   Receives the specified data out the specified endpoint.
160:           
161:                   Typical Usage:
162:                   <code>
163:                   //Read 64-bytes from endpoint USBGEN_EP_NUM, into the OUTPacket array.
164:                   //  Make sure to save the return handle so that we can check it later
165:                   //  to determine when the transfer is complete.
166:                   if(!USBHandleBusy(USBOutHandle))
167:                   {
168:                       USBOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,64);
169:                   }
170:                   </code>
171:           
172:               PreCondition:
173:                   None
174:                   
175:               Parameters:
176:                   BYTE ep - the endpoint you want to receive the data into
177:                   BYTE* data - pointer to where the data will go when it arrives
178:                   WORD len - the length of the data that you wish to receive
179:                   
180:               Return Values:
181:                   USB_HANDLE - a handle for the transfer.  This information
182:                   should be kept to track the status of the transfer
183:                   
184:               Remarks:
185:                   None
186:             
187:            *******************************************************************/
188:            // Implemented as a macro. See usb_function_generic.h
189:           
190:           
191:           /********************************************************************
192:           	Function:
193:           		void USBCheckVendorRequest(void)
194:           
195:            	Summary:
196:            		This routine handles vendor class specific requests that happen on EP0.
197:                   This function should be called from the USBCBCheckOtherReq() call back
198:                   function whenever implementing a custom/vendor class device.
199:           
200:            	Description:
201:            		This routine handles vendor specific requests that may arrive on EP0 as
202:            		a control transfer.  These can include, but are not necessarily 
203:            		limited to, requests for Microsft specific OS feature descriptor(s).  
204:            		This function should be called from the USBCBCheckOtherReq() call back 
205:            		function whenever using a vendor class device.
206:           
207:                   Typical Usage:
208:                   <code>
209:                   void USBCBCheckOtherReq(void)
210:                   {
211:                       //Since the stack didn't handle the request I need to check
212:                       //  my class drivers to see if it is for them
213:                       USBCheckVendorRequest();
214:                   }
215:                   </code>
216:           
217:           	PreCondition:
218:           		None
219:           
220:           	Parameters:
221:           		Although this function has a void input, this handler function will
222:           		typically need to look at the 8-byte SETUP packet contents that the
223:           		host just sent, which may contain the vendor class specific request.
224:           		
225:           		Therefore, the statically allocated SetupPkt structure may be looked
226:           		at while in the context of this function, and it will contain the most
227:           		recently received 8-byte SETUP packet data.
228:           
229:           	Return Values:
230:           		None
231:           
232:           	Remarks:
233:           		This function normally gets called within the same context as the
234:           		USBDeviceTasks() function, just after a new control transfer request
235:           		from the host has arrived.  If the USB stack is operated in 
236:           		USB_INTERRUPT mode (a usb_config.h option), then this function
237:           		will be executed in the interrupt context.  If however the USB stack
238:           		is operated in the USB_POLLING mode, then this function executes in the
239:           		main loop context.
240:           		
241:           		In order to respond to class specific control transfer request(s) in
242:           		this handler function, it is suggested to use one or more of the
243:           		USBEP0SendRAMPtr(), USBEP0SendROMPtr(), or USBEP0Receive() API 
244:           		functions.
245:            
246:            *******************************************************************/
247:           void USBCheckVendorRequest(void)
248:           {
249:               #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
250:                   WORD Length;
251:               
252:                   //Check if the most recent SETUP request is class specific
253:                   if(SetupPkt.bmRequestType == 0b11000000)    //Class specific, device to host, device level target
254:                   {
255:                       //Check if the host is requesting an MS feature descriptor
256:                       if(SetupPkt.bRequest == GET_MS_DESCRIPTOR)
257:                       {
258:                           //Figure out which descriptor is being requested
259:                           if(SetupPkt.wIndex == EXTENDED_COMPAT_ID)
260:                           {
261:                               //Determine number of bytes to send to host 
262:                               //Lesser of: requested amount, or total size of the descriptor
263:                               Length = CompatIDFeatureDescriptor.dwLength;
264:                               if(SetupPkt.wLength < Length)
265:                               {
266:                                   Length = SetupPkt.wLength;
267:                               }    
268:                                    
269:                               //Prepare to send the requested descriptor to the host
270:                               USBEP0SendROMPtr((ROM BYTE*)&CompatIDFeatureDescriptor, Length, USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
271:                           }
272:                       }            
273:                   }//if(SetupPkt.bmRequestType == 0b11000000)    
274:                   else if(SetupPkt.bmRequestType == 0b11000001)    //Class specific, device to host, interface target
275:                   {
276:                       //Check if the host is requesting an MS feature descriptor
277:                       if(SetupPkt.bRequest == GET_MS_DESCRIPTOR)
278:                       {
279:                           //Figure out which descriptor is being requested
280:                           if(SetupPkt.wIndex == EXTENDED_PROPERTIES)    
281:                           {
282:                               //Determine number of bytes to send to host 
283:                               //Lesser of: requested amount, or total size of the descriptor
284:                               Length = ExtPropertyFeatureDescriptor.dwLength;
285:                               if(SetupPkt.wLength < Length)
286:                               {
287:                                   Length = SetupPkt.wLength;
288:                               }    
289:                                    
290:                               //Prepare to send the requested descriptor to the host
291:                               USBEP0SendROMPtr((ROM BYTE*)&ExtPropertyFeatureDescriptor, Length, USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
292:                           }    
293:                       }                   
294:                   }//else if(SetupPkt.bmRequestType == 0b11000001)    
295:               #endif  //#if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)   
296:           }//void USBCheckVendorRequest(void)
07FD  0008     RETURN
297:           
298:           
299:           #endif //def USB_USE_GEN
300:           /** EOF usbgen.c *************************************************************/
---  /home/chris/Dev/klondike/firmware/USB/usb_device.c  ------------------------------------------------
1:             /********************************************************************
2:               File Information:
3:                 FileName:     	usb_device.c
4:                 Dependencies:	See INCLUDES section
5:                 Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                 Hardware:		This code is natively intended to be used on Mirochip USB
7:                                 demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                 section) for list of available platforms.  The firmware may 
9:                                 be modified for use on other USB platforms by editing the
10:                				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                and C32 (for PIC32)
13:                Company:		Microchip Technology, Inc.
14:                
15:                Software License Agreement:
16:                
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the "Company") for its PIC(r) Microcontroller is intended and
19:                supplied to you, the Company's customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:                
28:                THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:            
35:              Summary:
36:                This file contains functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                stack. This file should be included in projects that use the device stack. 
39:                
40:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                directory.
42:            
43:              Description:
44:                USB Device Stack File
45:                
46:                This file contains functions, macros, definitions, variables,
47:                datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                stack. This file should be included in projects that use the device stack.
49:                
50:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                directory.
52:                
53:                When including this file in a new project, this file can either be
54:                referenced from the directory in which it was installed or copied
55:                directly into the user application folder. If the first method is
56:                chosen to keep the file located in the folder in which it is installed
57:                then include paths need to be added so that the library and the
58:                application both know where to reference each others files. If the
59:                application folder is located in the same folder as the Microchip
60:                folder (like the current demo folders), then the following include
61:                paths need to be added to the application's project:
62:                
63:                .
64:                ..\\..\\MicrochipInclude
65:                
66:                If a different directory structure is used, modify the paths as
67:                required. An example using absolute paths instead of relative paths
68:                would be the following:
69:                
70:                C:\\Microchip Solutions\\Microchip\\Include
71:                
72:                C:\\Microchip Solutions\\My Demo Application 
73:            
74:            ********************************************************************
75:             File Description:
76:            
77:             Change History:
78:              Rev    Description
79:              ----   -----------
80:              2.6    Added USBCancelIO() function.  Moved and some stack
81:                     defintions to be more consistant with the host stack.
82:            
83:              2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                     inability to transmit on an endpoint if using ping-pong
85:                     and an odd number of packets had been sent on that endpoint 
86:            
87:              2.7    Fixed error where the USB error interrupt flag was not getting
88:                     cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                     http://www.microchip.com/forums/tm.aspx?m=479085
90:            
91:                     Fixed issue with dual role mode when device run in polling
92:                     mode.  Interrupts were remaining enabled after the host mode
93:                     operation was complete.  This was incompatible with polling
94:                     mode operation.
95:            
96:                     Changed how the bus sensing works.  In previous revisions it
97:                     was impossible to use the USBDeviceDetach to detach from the
98:                     bus if the bus voltage was still present.  This is now
99:                     possible.  It was also possible to move the device to the 
100:                    ATTACHED state in interrupt mode even if the bus voltage 
101:                    wasn't available.  This is now prohibited unless VBUS is
102:                    present.
103:                    
104:                    Improved error case handling when the host sends more OUT
105:                    bytes in a control transfer than the firmware was expecting
106:                    to receive (based on the size parameter when calling USBEP0Receive()).
107:                    
108:                    In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                    variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                    function.  
111:           
112:             2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                    devices.
114:           
115:                    Fixed an error on 16-bit and 32-bit processors where a word access
116:                    could be performed on a byte pointer resulting in possible address
117:                    errors with odd aligned pointers.
118:                    
119:             2.8    Several changes to the way control transfers get processed,
120:                    so as to support the ability to allow application/class specific
121:                    handler code to defer the status stage.  
122:                    Implemented USBCtrlEPAllowStatusStage() API function.
123:                    Implemented USBDeferStatusStage() API function (macro).
124:                    These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                    requirement, while allowing USB class handlers more flexibility.
126:                    
127:                    Also implemented the following API functions and macros, for delaying 
128:                    the data stage of a control transfer (with data stage):
129:                    USBDeferINDataStage()
130:                    USBDeferOUTDataStage()
131:                    USBOUTDataStageDeferred()
132:                    USBINDataStageDeferred()
133:                    USBCtrlEPAllowDataStage()      
134:                    
135:                    Fixed USB reset event handler issue, where the USB stack would 
136:                    re-initialize global interrupt settings in the interrupt context, on 
137:                    PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                    
139:                    Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                    Previous implementation would not always initialize endpoints correctly 
141:                    to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                    all ping pong mode and usage scenarios.
143:                    
144:              2.9   Fixed an issue with STALL handling behavior on non-EP0 endpoints, for 
145:                    PIC24 and PIC32 devices.  
146:              		  
147:              		 Fixed an issue where the ep_data_in[]/ep_data_out[] flags weren't 
148:              		 getting re-initialized coincident with the hardware ping pong pointer 
149:              		 reset during set configuration events.
150:              		 
151:              		 Implemented USBGetNextHandle() API function (actually a macro, defined
152:              		 in usb_device.h).
153:           
154:              2.9d  Added build option for disabling DTS checking
155:              
156:              2.9f  Adding pragma for PIC18F97J94 Family BDT location.
157:           
158:              2.9h  Updated to be able to support optional Microsoft OS Descriptors
159:           
160:              2.9i  Updated to set UCON<SUSPND> bit on PIC16F USB devices during 
161:                    suspend, so as to save power.
162:              
163:           ********************************************************************/
164:           
165:           /*----------------------------------------------------------------------------------
166:           The USBDeviceTasks() function is responsible for detecting and processing various
167:           USB bus events and host requests, such as those required for USB enumeration, when
168:           the USB cable is first attached to the host.  This function is the main dispatcher
169:           routine for the USB stack.
170:           
171:           Additional API functions and macros are also provided by the USB stack, which can be 
172:           used to send/receive USB data to/from the host, among other things.  A full list 
173:           of the available implemented functions/macros are provided in the 
174:           "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
175:           the USB API documentation can be found from:
176:           
177:           Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
178:           
179:           Once the help file is opened, the API functions/macros are described in the following section:
180:           Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
181:           Additional API functions may also be provided depending upon the specific USB device class
182:           implemented, and these functions are also documented in the MCHPFSUSB Library Help.
183:           
184:           
185:           If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
186:           usb_config.h), then the application firmware is reponsible for calling the 
187:           USBDeviceTasks() function periodically.  If the USB stack is operated in the 
188:           "USB_INTERRUPT" mode, then the application firmware does not have to directly 
189:           call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
190:           
191:           In order to properly operate a USB connection, and to correctly process and respond
192:           to control transfers in the maximum time allowed by the USB specifications, the
193:           USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
194:           fashion.
195:           
196:           When the USB module is enabled, the USB cable is attached to the host, the USB bus
197:           is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
198:           with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
199:           time between calls to the USBDeviceTasks() function needs to be:
200:           
201:           The faster of:
202:           1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
203:           2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
204:           3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
205:           
206:           Additional details of the above timing limits are provided:
207:           
208:           Timing item #1: This parameter originates from the 2ms set address "recovery interval"
209:           specification dictated by section "9.2.6.3 Set Address Processing" of the official 
210:           USB 2.0 specifications.
211:           
212:           Timing item #2: This parameter originates from several "10 ms" criteria in the 
213:           USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
214:           intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
215:           
216:           Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
217:           transaction rate implemented by the application.  The USBDeviceTasks() function is
218:           responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
219:           then no further USB transactions are allowed to occur, until the firmware pops entries
220:           off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
221:           a rate at least as fast as once every three times the USBTransferOnePacket() function
222:           is called.  This ensures that the rate that USTAT FIFO entries are getting added to
223:           the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
224:           USBDeviceTasks() function will pop up to 4 entries per call), which is a
225:           necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
226:           USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
227:           USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
228:           and is therefore recommended.
229:           
230:           When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
231:           parameters should be interpreted to be the longest allowed time that the USB 
232:           interrupts may be masked/disabled for, before re-enabling the USB interrupts.
233:           
234:           Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
235:           will still have potential USB data rate speed and processing latency benefits.
236:           It is also beneficial to call USBDeviceTasks() more often than theoretically 
237:           required, since it has been observed that not all host/drivers/bios/hubs are 
238:           100% consistently compliant with all timing parameters of the USB 2.0 specifications.
239:           Therefore, in a USB_POLLING based application, it is still suggested to call 
240:           USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
241:           performance, along with best possible compatibility with all existing USB 
242:           hosts/hubs (both those that are compliant and [partially] non-compliant).
243:           
244:           If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
245:           to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
246:           per 100us, or preferrably faster).  Therefore, in all applications, it is 
247:           normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
248:           USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
249:           allow for much more relaxed timing requirements, and therefore greater application
250:           firmware design flexibility.
251:           //----------------------------------------------------------------------------------*/
252:           
253:           /** INCLUDES *******************************************************/
254:           #include "./USB/usb.h"
255:           #include "HardwareProfile.h"
256:           
257:           #include "./USB/usb_device_local.h"
258:           
259:           
260:           #if defined(USB_USE_MSD)
261:               #include "./USB/usb_function_msd.h"
262:           #endif
263:           
264:           #if !defined(USE_USB_BUS_SENSE_IO)
265:               #undef USB_BUS_SENSE
266:               #define USB_BUS_SENSE 1
267:           #endif
268:           
269:           #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
270:               #define _DTS_CHECKING_ENABLED 0
271:           #else
272:               #define _DTS_CHECKING_ENABLED _DTSEN
273:           #endif
274:           
275:           /** DEFINITIONS ****************************************************/
276:           
277:           /** VARIABLES ******************************************************/
278:           #if defined(__18CXX)
279:               #pragma udata
280:           #endif
281:           
282:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
283:           USB_VOLATILE BYTE USBActiveConfiguration;
284:           USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
285:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
286:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
287:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
288:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
289:           USB_VOLATILE BYTE shortPacketStatus;
290:           USB_VOLATILE BYTE controlTransferState;
291:           USB_VOLATILE IN_PIPE inPipes[1];
292:           USB_VOLATILE OUT_PIPE outPipes[1];
293:           USB_VOLATILE BYTE *pDst;
294:           USB_VOLATILE BOOL RemoteWakeup;
295:           USB_VOLATILE BOOL USBBusIsSuspended;
296:           USB_VOLATILE USTAT_FIELDS USTATcopy;
297:           USB_VOLATILE BYTE endpoint_number;
298:           USB_VOLATILE BOOL BothEP0OutUOWNsSet;
299:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
300:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
301:           USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
302:           volatile BOOL USBDeferStatusStagePacket;
303:           volatile BOOL USBStatusStageEnabledFlag1;
304:           volatile BOOL USBStatusStageEnabledFlag2;
305:           volatile BOOL USBDeferINDataStagePackets;
306:           volatile BOOL USBDeferOUTDataStagePackets;
307:           
308:           
309:           #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
310:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 2)
311:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
312:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 2)+1)
313:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
314:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 4)
315:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
316:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 4)-2)
317:           #else
318:               #error "No ping pong mode defined."
319:           #endif
320:           
321:           /** USB FIXED LOCATION VARIABLES ***********************************/
322:           #if defined(__18CXX)
323:               #pragma udata USB_BDT=USB_BDT_ADDRESS
324:           #endif
325:           
326:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
327:           
328:           /********************************************************************
329:            * Section B: EP0 Buffer Space
330:            *******************************************************************/
331:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
332:           volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
333:           
334:           /********************************************************************
335:            * Section C: non-EP0 Buffer Space
336:            *******************************************************************/
337:           #if defined(USB_USE_MSD)
338:           	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
339:           	volatile USB_MSD_CBW msd_cbw;
340:           	volatile USB_MSD_CSW msd_csw;
341:           	//#pragma udata
342:           
343:           	#if defined(__18CXX)
344:           		#pragma udata myMSD=MSD_BUFFER_ADDRESS
345:           	#endif
346:           	volatile char msd_buffer[512];
347:           #endif
348:           
349:           
350:           
351:           ////Depricated in v2.2 - will be removed in a future revision
352:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
353:               //Device descriptor
354:               extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
355:           #else
356:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
357:           #endif
358:           
359:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
360:               //Array of configuration descriptors
361:               extern ROM BYTE *ROM USB_CD_Ptr[];
362:           #else
363:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
364:           #endif
365:           
366:           extern ROM BYTE *ROM USB_SD_Ptr[];
367:           
368:           /** DECLARATIONS ***************************************************/
369:           #if defined(__18CXX)
370:               #pragma code
371:           #endif
372:           
373:           /** Macros *********************************************************/
374:           
375:           /** Function Prototypes ********************************************/
376:           //External
377:           //This is the prototype for the required user event handler
378:           __section("usb") BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size);
379:           
380:           //Internal Functions
381:           static void USBCtrlEPService(void);
382:           static void USBCtrlTrfSetupHandler(void);
383:           static void USBCtrlTrfInHandler(void);
384:           static void USBCheckStdRequest(void);
385:           static void USBStdGetDscHandler(void);
386:           static void USBCtrlEPServiceComplete(void);
387:           static void USBCtrlTrfTxService(void);
388:           static void USBCtrlTrfRxService(void);
389:           static void USBStdSetCfgHandler(void);
390:           static void USBStdGetStatusHandler(void);
391:           static void USBStdFeatureReqHandler(void);
392:           static void USBCtrlTrfOutHandler(void);
393:           static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
394:           static void USBWakeFromSuspend(void);
395:           static void USBSuspend(void);
396:           static void USBStallHandler(void);
397:           
398:           //static BOOL USBIsTxBusy(BYTE EPNumber);
399:           //static void USBPut(BYTE EPNum, BYTE Data);
400:           //static void USBEPService(void);
401:           //static void USBProtocolResetHandler(void);
402:           
403:           /******************************************************************************/
404:           /** Function Implementations *************************************************/
405:           /******************************************************************************/
406:           
407:           /******************************************************************************/
408:           /** Internal Macros *********************************************************/
409:           /******************************************************************************/
410:           
411:           /****************************************************************************
412:             Function:
413:               void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
414:           
415:             Description:
416:               This function will advance the passed pointer to the next buffer based on
417:               the ping pong option setting.  This function should be used for EP1-EP15
418:               only.  This function is not valid for EP0.
419:           
420:             Precondition:
421:               None
422:           
423:             Parameters:
424:               BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
425:               to the next buffer state
426:           
427:             Return Values:
428:               None
429:           
430:             Remarks:
431:               None
432:           
433:             ***************************************************************************/
434:           #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
435:           #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
436:           #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
437:           
438:           
439:           /******************************************************************************/
440:           /** External API Functions ****************************************************/
441:           /******************************************************************************/
442:           
443:           /**************************************************************************
444:               Function:
445:                   void USBDeviceInit(void)
446:               
447:               Description:
448:                   This function initializes the device stack it in the default state. The
449:                   USB module will be completely reset including all of the internal
450:                   variables, registers, and interrupt flags.
451:                           
452:               Precondition:
453:                   This function must be called before any of the other USB Device
454:                   functions can be called, including USBDeviceTasks().
455:                   
456:               Parameters:
457:                   None
458:                
459:               Return Values:
460:                   None
461:                   
462:               Remarks:
463:                   None
464:                                                                     
465:             ***************************************************************************/
466:           void USBDeviceInit(void)
467:           {
468:               BYTE i;
469:           
470:               USBDisableInterrupts();
16BF  0021     MOVLB 0x1
16C0  1112     BCF PIR2, 0x2
471:           
472:               // Clear all USB error flags
473:               USBClearInterruptRegister(U1EIR);  
16C1  003D     MOVLB 0x1D
16C2  0193     CLRF 0x13
474:                  
475:               // Clears all USB interrupts          
476:               USBClearInterruptRegister(U1IR); 
16C3  0190     CLRF 0x10
477:           
478:               //Clear all of the endpoint control registers
479:               U1EP0 = 0;
16C4  0198     CLRF T1CON
480:               
481:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
16C5  300E     MOVLW 0xE
16C6  0020     MOVLB 0x0
16C7  00D9     MOVWF x
16C8  3099     MOVLW 0x99
16C9  00D8     MOVWF off
16CA  01DA     CLRF i_718
16CB  0858     MOVF off, W
16CC  0086     MOVWF FSR1L
16CD  0859     MOVF x, W
16CE  0087     MOVWF FSR1H
16CF  0181     CLRF INDF1
16D0  0AD8     INCF off, F
16D1  1903     BTFSC STATUS, 0x2
16D2  0AD9     INCF x, F
16D3  0ADA     INCF i_718, F
16D4  1903     BTFSC STATUS, 0x2
16D5  2ECB     GOTO 0x6CB
482:           
483:               SetConfigurationOptions();
16D6  3016     MOVLW 0x16
16D7  003D     MOVLB 0x1D
16D8  0091     MOVWF PIR1
16D9  309F     MOVLW 0x9F
16DA  0097     MOVWF TMR1H
16DB  307B     MOVLW 0x7B
16DC  0092     MOVWF PIR2
484:           
485:               //power up the module (if not already powered)
486:               USBPowerModule();
487:           
488:               //set the address of the BDT (if applicable)
489:               USBSetBDTAddress(BDT);
490:           
491:               //Clear all of the BDT entries
492:               for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
16DD  0020     MOVLB 0x0
16DE  01DB     CLRF i
16EA  3008     MOVLW 0x8
16EB  0ADB     INCF i, F
16EC  025B     SUBWF i, W
16ED  1C03     BTFSS STATUS, 0x0
16EE  2EDF     GOTO 0x6DF
493:               {
494:                   BDT[i].Val = 0x00;
16DF  085B     MOVF i, W
16E0  0709     ADDWF WREG, W
16E1  0709     ADDWF WREG, W
16E2  3E20     ADDLW 0x20
16E3  0086     MOVWF FSR1L
16E4  3000     MOVLW 0x0
16E5  0187     CLRF FSR1H
16E6  3FC0     MOVWI [0]FSR1
16E7  3FC1     MOVWI [1]FSR1
16E8  3FC2     MOVWI [2]FSR1
16E9  3FC3     MOVWI [3]FSR1
495:               }
496:           
497:               // Assert reset request to all of the Ping Pong buffer pointers
498:               USBPingPongBufferReset = 1;                    
16EF  003D     MOVLB 0x1D
16F0  170E     BSF PORTC, 0x6
499:           
500:               // Reset to default address
501:               U1ADDR = 0x00;                   
16F1  0196     CLRF TMR1L
502:           
503:               // Make sure packet processing is enabled
504:               USBPacketDisable = 0;           
16F2  120E     BCF PORTC, 0x4
505:           
506:               //Stop trying to reset ping pong buffer pointers
507:               USBPingPongBufferReset = 0;
16F3  130E     BCF PORTC, 0x6
508:           
509:               // Flush any pending transactions
510:               while(USBTransactionCompleteIF == 1)      
16F4  003D     MOVLB 0x1D
16F5  1D90     BTFSS 0x10, 0x3
16F6  2EFE     GOTO 0x6FE
16FD  2EF4     GOTO 0x6F4
511:               {
512:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
16F7  1190     BCF 0x10, 0x3
513:                   //Initialize USB stack software state variables
514:                   inPipes[0].info.Val = 0;
16F8  0022     MOVLB 0x2
16F9  01CC     CLRF 0x4C
515:                   outPipes[0].info.Val = 0;
16FA  01A2     CLRF 0x22
516:                   outPipes[0].wCount.Val = 0;
16FB  01A3     CLRF 0x23
16FC  01A4     CLRF 0x24
517:               }
518:           
519:               //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
520:               //try and arm a status stage, even before the first control transfer starts.
521:               USBStatusStageEnabledFlag1 = TRUE;  
16FE  3001     MOVLW 0x1
16FF  0022     MOVLB 0x2
1700  00B8     MOVWF 0x38
522:               USBStatusStageEnabledFlag2 = TRUE;
1701  00B9     MOVWF 0x39
523:               //Initialize other flags
524:               USBDeferINDataStagePackets = FALSE;
1702  01B5     CLRF 0x35
525:               USBDeferOUTDataStagePackets = FALSE;
1703  01B6     CLRF 0x36
526:               USBBusIsSuspended = FALSE;
527:           
528:           	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
529:           	//pointers to NULL, so they don't get used inadvertently.  
530:           	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
1704  0020     MOVLB 0x0
1705  01DB     CLRF i
1718  3002     MOVLW 0x2
171A  0ADB     INCF i, F
171B  025B     SUBWF i, W
171C  1C03     BTFSS STATUS, 0x0
171D  2F06     GOTO 0x706
531:           	{
532:           		pBDTEntryIn[i] = 0u;
1706  085B     MOVF i, W
1707  3E6A     ADDLW 0x6A
1708  0086     MOVWF FSR1L
1709  0187     CLRF FSR1H
170A  0181     CLRF INDF1
533:           		pBDTEntryOut[i] = 0u;		
170B  085B     MOVF i, W
170C  3E2C     ADDLW 0x2C
170D  0086     MOVWF FSR1L
170E  3001     MOVLW 0x1
170F  0087     MOVWF FSR1H
1710  0181     CLRF INDF1
534:           		ep_data_in[i].Val = 0u;
1711  085B     MOVF i, W
1712  3E26     ADDLW 0x26
1713  0086     MOVWF FSR1L
1714  0181     CLRF INDF1
535:                   ep_data_out[i].Val = 0u;
1715  085B     MOVF i, W
1716  3E28     ADDLW 0x28
1717  0086     MOVWF FSR1L
1719  0181     CLRF INDF1
536:           	}
537:           
538:               //Get ready for the first packet
539:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
171E  3028     MOVLW 0x28
171F  00EA     MOVWF pBDTEntryIn
540:               // Initialize EP0 as a Ctrl EP
541:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
1720  3016     MOVLW 0x16
1721  003D     MOVLB 0x1D
1722  0098     MOVWF T1CON
542:           	//Prepare for the first SETUP on EP0 OUT
543:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
1723  3040     MOVLW 0x40
1724  0020     MOVLB 0x0
1725  00D6     MOVWF dest
1726  01D7     CLRF product
1727  00A2     MOVWF 0x22
1728  0857     MOVF product, W
1729  00A3     MOVWF 0x23
544:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
172A  3008     MOVLW 0x8
172B  00A1     MOVWF 0x21
545:               BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
172C  3084     MOVLW 0x84
172D  00A0     MOVWF BDT
546:           
547:               // Clear active configuration
548:               USBActiveConfiguration = 0;     
172E  0022     MOVLB 0x2
172F  01CF     CLRF 0x4F
549:           
550:               //Indicate that we are now in the detached state        
551:               USBDeviceState = DETACHED_STATE;
1730  0021     MOVLB 0x1
1731  01EB     CLRF 0x6B
552:           }
1732  0008     RETURN
553:           
554:           /**************************************************************************
555:             Function:
556:                   void USBDeviceTasks(void)
557:               
558:             Summary:
559:               This function is the main state machine/transaction handler of the USB 
560:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
561:               (usb_config.h user option) the USBDeviceTasks() function should be called 
562:               periodically to receive and transmit packets through the stack. This 
563:               function also takes care of control transfers associated with the USB 
564:               enumeration process, and detecting various USB events (such as suspend).  
565:               This function should be called at least once every 1.8ms during the USB 
566:               enumeration process. After the enumeration process is complete (which can 
567:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
568:               USBDeviceTasks() handler may be called the faster of: either once 
569:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
570:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
571:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
572:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
573:               near the top of usb_device.c for more details about minimum timing 
574:               requirements when calling USBDeviceTasks().
575:               
576:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
577:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
578:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
579:               interrupt occurs, and therefore only needs to be called from the interrupt 
580:               context.
581:           
582:             Description:
583:               This function is the main state machine/transaction handler of the USB 
584:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
585:               (usb_config.h user option) the USBDeviceTasks() function should be called 
586:               periodically to receive and transmit packets through the stack. This 
587:               function also takes care of control transfers associated with the USB 
588:               enumeration process, and detecting various USB events (such as suspend).  
589:               This function should be called at least once every 1.8ms during the USB 
590:               enumeration process. After the enumeration process is complete (which can 
591:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
592:               USBDeviceTasks() handler may be called the faster of: either once 
593:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
594:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
595:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
596:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
597:               near the top of usb_device.c for more details about minimum timing 
598:               requirements when calling USBDeviceTasks().
599:               
600:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
601:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
602:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
603:               interrupt occurs, and therefore only needs to be called from the interrupt 
604:               context.
605:           
606:               Typical usage:
607:               <code>
608:               void main(void)
609:               {
610:                   USBDeviceInit();
611:                   while(1)
612:                   {
613:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
614:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
615:                          (USBIsDeviceSuspended() == TRUE))
616:                       {
617:                           //Either the device is not configured or we are suspended,
618:                           // so we don't want to execute any USB related application code
619:                           continue;   //go back to the top of the while loop
620:                       }
621:                       else
622:                       {
623:                           //Otherwise we are free to run USB and non-USB related user 
624:                           //application code.
625:                           UserApplication();
626:                       }
627:                   }
628:               }
629:               </code>
630:           
631:             Precondition:
632:               Make sure the USBDeviceInit() function has been called prior to calling
633:               USBDeviceTasks() for the first time.
634:             Remarks:
635:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
636:               if the user application firmware in the USBCBSuspend() callback function
637:               enables the ACTVIF USB interrupt source and put the microcontroller into 
638:               sleep mode.  If the application firmware decides not to sleep the 
639:               microcontroller core during USB suspend (ex: continues running at full 
640:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
641:               function must still be called periodically, at a rate frequent enough to 
642:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
643:               a worst case primary oscillator and PLL start up time of <5ms, then 
644:               USBDeviceTasks() should be called once every 5ms in this scenario.
645:              
646:               When the USB cable is detached, or the USB host is not actively powering 
647:               the VBUS line to +5V nominal, the application firmware does not always have 
648:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
649:               place.  However, if USBDeviceTasks() is not called regularly, some 
650:               alternative means of promptly detecting when VBUS is powered (indicating 
651:               host attachment), or not powered (host powered down or USB cable unplugged)
652:               is still needed.  For self or dual self/bus powered USB applications, see 
653:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
654:               considerations.
655:                                
656:             **************************************************************************/
657:           
658:           #if defined(USB_INTERRUPT) 
659:           #if defined(__18CXX) || defined (_PIC14E)
660:               void USBDeviceTasks(void)
661:             #elif defined(__C30__) || defined __XC16__
662:               void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
663:             #elif defined(__PIC32MX__)
664:               void __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
665:             #endif
666:           #else
667:           void __section("usb") USBDeviceTasks(void)
668:           #endif
669:           {
670:               BYTE i;
671:           
672:           #ifdef USB_SUPPORT_OTG
673:               //SRP Time Out Check
674:               if (USBOTGSRPIsReady())
675:               {
676:                   if (USBT1MSECIF && USBT1MSECIE)
677:                   {
678:                       if (USBOTGGetSRPTimeOutFlag())
679:                       {
680:                           if (USBOTGIsSRPTimeOutExpired())
681:                           {
682:                               USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
683:                           }       
684:                       }
685:           
686:                       //Clear Interrupt Flag
687:                       USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
688:                   }
689:               }
690:           #endif
691:           
692:               #if defined(USB_POLLING)
693:               //If the interrupt option is selected then the customer is required
694:               //  to notify the stack when the device is attached or removed from the
695:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
696:               if (USB_BUS_SENSE != 1)
697:               {
698:                    // Disable module & detach from bus
699:                    U1CON = 0;             
700:           
701:                    // Mask all USB interrupts              
702:                    U1IE = 0;          
703:           
704:                    //Move to the detached state                  
705:                    USBDeviceState = DETACHED_STATE;
706:           
707:                    #ifdef  USB_SUPPORT_OTG    
708:                        //Disable D+ Pullup
709:                        U1OTGCONbits.DPPULUP = 0;
710:           
711:                        //Disable HNP
712:                        USBOTGDisableHnp();
713:           
714:                        //Deactivate HNP
715:                        USBOTGDeactivateHnp();
716:                        
717:                        //If ID Pin Changed State
718:                        if (USBIDIF && USBIDIE)
719:                        {  
720:                            //Re-detect & Initialize
721:                             USBOTGInitialize();
722:           
723:                             //Clear ID Interrupt Flag
724:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
725:                        }
726:                    #endif
727:           
728:                    #if defined __C30__ || defined __XC16__
729:                        //USBClearInterruptFlag(U1OTGIR, 3); 
730:                    #endif
731:                       //return so that we don't go through the rest of 
732:                       //the state machine
733:                    USBClearUSBInterrupt();
734:                    return;
735:               }
736:           
737:           	#ifdef USB_SUPPORT_OTG
738:               //If Session Is Started Then
739:               else
740:           	{
741:                   //If SRP Is Ready
742:                   if (USBOTGSRPIsReady())
743:                   {   
744:                       //Clear SRPReady
745:                       USBOTGClearSRPReady();
746:           
747:                       //Clear SRP Timeout Flag
748:                       USBOTGClearSRPTimeOutFlag();
749:           
750:                       //Indicate Session Started
751:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
752:                   }
753:               }
754:           	#endif	//#ifdef USB_SUPPORT_OTG
755:           
756:               //if we are in the detached state
757:               if(USBDeviceState == DETACHED_STATE)
0191  0021     MOVLB 0x1
0192  08EB     MOVF 0x6B, F
0193  1D03     BTFSS STATUS, 0x2
0194  2996     GOTO 0x196
0195  2997     GOTO 0x197
0196  29A9     GOTO 0x1A9
758:               {
759:           	    //Initialize register to known value
760:                   U1CON = 0;                          
0197  003D     MOVLB 0x1D
0198  018E     CLRF PORTC
761:           
762:                   // Mask all USB interrupts
763:                   U1IE = 0;                                
0199  0192     CLRF PIR2
764:           
765:                   //Enable/set things like: pull ups, full/low-speed mode, 
766:                   //set the ping pong mode, and set internal transceiver
767:                   SetConfigurationOptions();
019A  3016     MOVLW 0x16
019B  0091     MOVWF PIR1
019C  309F     MOVLW 0x9F
019D  0097     MOVWF TMR1H
019E  307B     MOVLW 0x7B
019F  0092     MOVWF PIR2
768:           
769:                   // Enable module & attach to bus
770:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
01A0  29A2     GOTO 0x1A2
01A1  158E     BSF PORTC, 0x3
01A2  1D8E     BTFSS PORTC, 0x3
01A3  29A5     GOTO 0x1A5
01A4  29A6     GOTO 0x1A6
01A5  29A1     GOTO 0x1A1
771:           
772:                   //moved to the attached state
773:                   USBDeviceState = ATTACHED_STATE;
01A6  0021     MOVLB 0x1
01A7  01EB     CLRF 0x6B
01A8  0AEB     INCF 0x6B, F
774:           
775:                   #ifdef  USB_SUPPORT_OTG
776:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
777:                   #endif
778:               }
779:           	#endif  //#if defined(USB_POLLING)
780:           
781:               if(USBDeviceState == ATTACHED_STATE)
01A9  036B     DECF 0x6B, W
01AA  1D03     BTFSS STATUS, 0x2
01AB  29AD     GOTO 0x1AD
01AC  29AE     GOTO 0x1AE
01AD  29BA     GOTO 0x1BA
782:               {
783:                   /*
784:                    * After enabling the USB module, it takes some time for the
785:                    * voltage on the D+ or D- line to rise high enough to get out
786:                    * of the SE0 condition. The USB Reset interrupt should not be
787:                    * unmasked until the SE0 condition is cleared. This helps
788:                    * prevent the firmware from misinterpreting this unique event
789:                    * as a USB bus reset from the USB host.
790:                    */
791:           
792:                   if(!USBSE0Event)
01AE  003D     MOVLB 0x1D
01AF  1A8E     BTFSC PORTC, 0x5
01B0  29B2     GOTO 0x1B2
01B1  29B3     GOTO 0x1B3
01B2  29BA     GOTO 0x1BA
793:                   {
794:                       USBClearInterruptRegister(U1IR);// Clear all USB interrupts
01B3  0190     CLRF 0x10
795:                       #if defined(USB_POLLING)
796:                           U1IE=0;                        // Mask all USB interrupts
01B4  0192     CLRF PIR2
797:                       #endif
798:                       USBResetIE = 1;             // Unmask RESET interrupt
01B5  1412     BSF PIR2, 0x0
799:                       USBIdleIE = 1;             // Unmask IDLE interrupt
01B6  1612     BSF PIR2, 0x4
800:                       USBDeviceState = POWERED_STATE;
01B7  3002     MOVLW 0x2
01B8  0021     MOVLB 0x1
01B9  00EB     MOVWF 0x6B
801:                   }
802:               }
803:           
804:               #ifdef  USB_SUPPORT_OTG
805:                   //If ID Pin Changed State
806:                   if (USBIDIF && USBIDIE)
807:                   {  
808:                       //Re-detect & Initialize
809:                       USBOTGInitialize();
810:           
811:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
812:                   }
813:               #endif
814:           
815:               /*
816:                * Task A: Service USB Activity Interrupt
817:                */
818:               if(USBActivityIF && USBActivityIE)
01BA  003D     MOVLB 0x1D
01BB  1D10     BTFSS 0x10, 0x2
01BC  29BE     GOTO 0x1BE
01BD  29BF     GOTO 0x1BF
01BE  29C7     GOTO 0x1C7
01BF  1D12     BTFSS PIR2, 0x2
01C0  29C2     GOTO 0x1C2
01C1  29C3     GOTO 0x1C3
01C2  29C7     GOTO 0x1C7
819:               {
820:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
01C3  1110     BCF 0x10, 0x2
821:                   #if defined(USB_SUPPORT_OTG)
822:                       U1OTGIR = 0x10;        
823:                   #else
824:                       USBWakeFromSuspend();
01C4  3187     MOVLP 0x7
01C5  27EC     CALL 0x7EC
01C6  3181     MOVLP 0x1
825:                   #endif
826:               }
827:           
828:               /*
829:                * Pointless to continue servicing if the device is in suspend mode.
830:                */
831:               if(USBSuspendControl==1)
01C7  1C8E     BTFSS PORTC, 0x1
01C8  29CA     GOTO 0x1CA
01C9  29CB     GOTO 0x1CB
01CA  29CE     GOTO 0x1CE
832:               {
833:                   USBClearUSBInterrupt();
01CB  0020     MOVLB 0x0
01CC  1112     BCF PIR2, 0x2
834:                   return;
01CD  2A87     GOTO 0x287
835:               }
836:           
837:               /*
838:                * Task B: Service USB Bus Reset Interrupt.
839:                * When bus reset is received during suspend, ACTVIF will be set first,
840:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
841:                * This is why URSTIF is checked after ACTVIF.
842:                *
843:                * The USB reset flag is masked when the USB state is in
844:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
845:                * cause a USB reset event during these two states.
846:                */
847:               if(USBResetIF && USBResetIE)
01CE  1C10     BTFSS 0x10, 0x0
01CF  29D1     GOTO 0x1D1
01D0  29D2     GOTO 0x1D2
01D1  29DD     GOTO 0x1DD
01D2  1C12     BTFSS PIR2, 0x0
01D3  29D5     GOTO 0x1D5
01D4  29D6     GOTO 0x1D6
01D5  29DD     GOTO 0x1DD
848:               {
849:                   USBDeviceInit();
01D6  3196     MOVLP 0x16
01D7  26BF     CALL 0x6BF
01D8  3181     MOVLP 0x1
850:           
851:                   //Re-enable the interrupts since the USBDeviceInit() function will
852:                   //  disable them.  This will do nothing in a polling setup
853:                   USBUnmaskInterrupts();
854:           
855:                   USBDeviceState = DEFAULT_STATE;
01D9  3004     MOVLW 0x4
01DA  00EB     MOVWF 0x6B
856:           
857:                   #ifdef USB_SUPPORT_OTG
858:                        //Disable HNP
859:                        USBOTGDisableHnp();
860:           
861:                        //Deactivate HNP
862:                        USBOTGDeactivateHnp();
863:                   #endif
864:           
865:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
01DB  003D     MOVLB 0x1D
01DC  1010     BCF 0x10, 0x0
866:               }
867:           
868:               /*
869:                * Task C: Service other USB interrupts
870:                */
871:               if(USBIdleIF && USBIdleIE)
01DD  1E10     BTFSS 0x10, 0x4
01DE  29E0     GOTO 0x1E0
01DF  29E1     GOTO 0x1E1
01E0  29EA     GOTO 0x1EA
01E1  1E12     BTFSS PIR2, 0x4
01E2  29E4     GOTO 0x1E4
01E3  29E5     GOTO 0x1E5
01E4  29EA     GOTO 0x1EA
872:               { 
873:                   #ifdef  USB_SUPPORT_OTG 
874:                       //If Suspended, Try to switch to Host
875:                       USBOTGSelectRole(ROLE_HOST);
876:                   #else
877:                       USBSuspend();
01E5  3196     MOVLP 0x16
01E6  2605     CALL 0x605
01E7  3181     MOVLP 0x1
878:                   #endif
879:                   
880:                   USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
01E8  003D     MOVLB 0x1D
01E9  1210     BCF 0x10, 0x4
881:               }
882:           
883:               if(USBSOFIF)
01EA  1F10     BTFSS 0x10, 0x6
01EB  29ED     GOTO 0x1ED
01EC  29EE     GOTO 0x1EE
01ED  2A0F     GOTO 0x20F
884:               {
885:                   if(USBSOFIE)
01EE  1F12     BTFSS PIR2, 0x6
01EF  29F1     GOTO 0x1F1
01F0  29F2     GOTO 0x1F2
01F1  29FF     GOTO 0x1FF
886:                   {
887:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
01F2  3073     MOVLW 0x73
01F3  0020     MOVLB 0x0
01F4  00E0     MOVWF count
01F5  01E1     CLRF 0x61
01F6  3000     MOVLW 0x0
01F7  00E2     MOVWF 0x62
01F8  3000     MOVLW 0x0
01F9  00E3     MOVWF 0x63
01FA  01E4     CLRF 0x64
01FB  0AE4     INCF 0x64, F
01FC  01E5     CLRF 0x65
01FD  2288     CALL 0x288
01FE  3181     MOVLP 0x1
888:                   }    
889:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
01FF  003D     MOVLB 0x1D
0200  1310     BCF 0x10, 0x6
890:                   
891:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
892:                       //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
893:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
894:                           #warning "Double click this message.  See inline code comments."
895:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
896:                           //not strictly needed in all applications (ex: those that never call 
897:                           //USBDeferStatusStage() and don't use host to device (OUT) control
898:                           //transfers with data stage).  
899:                           //However, if this feature is enabled and used, it requires a timer 
900:                           //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
901:                           //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
902:                           //packets at a 1ms rate, which generates SOFIF interrupts.
903:                           //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
904:                           //below.  However, the host does not send SOF packets to Low Speed devices.  
905:                           //Therefore, some other method  (ex: using a general purpose microcontroller 
906:                           //timer, such as Timer0) needs to be implemented to call and execute the below code
907:                           //at a once/1ms rate, in a low speed USB application.
908:                           //Note: Pre-condition to executing the below code: USBDeviceInit() should have
909:                           //been called at least once (since the last microcontroller reset/power up), 
910:                           //prior to executing the below code.
911:                       #endif
912:                       
913:                       //Decrement our status stage counter.
914:                       if(USBStatusStageTimeoutCounter != 0u)
0201  0022     MOVLB 0x2
0202  083A     MOVF 0x3A, W
0203  1D03     BTFSS STATUS, 0x2
0204  2A06     GOTO 0x206
0205  2A07     GOTO 0x207
915:                       {
916:                           USBStatusStageTimeoutCounter--;
0206  03BA     DECF 0x3A, F
917:                       }
918:                       //Check if too much time has elapsed since progress was made in 
919:                       //processing the control transfer, without arming the status stage.  
920:                       //If so, auto-arm the status stage to ensure that the control 
921:                       //transfer can [eventually] complete, within the timing limits
922:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
923:                       if(USBStatusStageTimeoutCounter == 0)
0207  08BA     MOVF 0x3A, F
0208  1D03     BTFSS STATUS, 0x2
0209  2A0B     GOTO 0x20B
020A  2A0C     GOTO 0x20C
020B  2A0F     GOTO 0x20F
924:                       {
925:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
020C  3187     MOVLP 0x7
020D  2796     CALL 0x796
020E  3181     MOVLP 0x1
926:                       } 
927:                   #endif
928:               }
929:           
930:               if(USBStallIF && USBStallIE)
020F  003D     MOVLB 0x1D
0210  1E90     BTFSS 0x10, 0x5
0211  2A13     GOTO 0x213
0212  2A14     GOTO 0x214
0213  2A1B     GOTO 0x21B
0214  1E92     BTFSS PIR2, 0x5
0215  2A17     GOTO 0x217
0216  2A18     GOTO 0x218
0217  2A1B     GOTO 0x21B
931:               {
932:                   USBStallHandler();
0218  3196     MOVLP 0x16
0219  2614     CALL 0x614
021A  3181     MOVLP 0x1
933:               }
934:           
935:               if(USBErrorIF && USBErrorIE)
021B  1C90     BTFSS 0x10, 0x1
021C  2A1E     GOTO 0x21E
021D  2A1F     GOTO 0x21F
021E  2A33     GOTO 0x233
021F  1C92     BTFSS PIR2, 0x1
0220  2A22     GOTO 0x222
0221  2A23     GOTO 0x223
0222  2A33     GOTO 0x233
936:               {
937:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0223  30FF     MOVLW 0xFF
0224  0020     MOVLB 0x0
0225  00E0     MOVWF count
0226  307F     MOVLW 0x7F
0227  00E1     MOVWF 0x61
0228  3000     MOVLW 0x0
0229  00E2     MOVWF 0x62
022A  3000     MOVLW 0x0
022B  00E3     MOVWF 0x63
022C  01E4     CLRF 0x64
022D  0AE4     INCF 0x64, F
022E  01E5     CLRF 0x65
022F  2288     CALL 0x288
0230  3181     MOVLP 0x1
938:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0231  003D     MOVLB 0x1D
0232  0193     CLRF 0x13
939:           
940:                   //On PIC18, clearing the source of the error will automatically clear
941:                   //  the interrupt flag.  On other devices the interrupt flag must be 
942:                   //  manually cleared. 
943:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
944:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
945:                   #endif
946:               }
947:           
948:               /*
949:                * Pointless to continue servicing if the host has not sent a bus reset.
950:                * Once bus reset is received, the device transitions into the DEFAULT
951:                * state and is ready for communication.
952:                */
953:               if(USBDeviceState < DEFAULT_STATE)
0233  3004     MOVLW 0x4
0234  0021     MOVLB 0x1
0235  026B     SUBWF 0x6B, W
0236  1803     BTFSC STATUS, 0x0
0237  2A39     GOTO 0x239
0238  2A3A     GOTO 0x23A
0239  2A3B     GOTO 0x23B
023A  29CB     GOTO 0x1CB
954:               {
955:           	    USBClearUSBInterrupt();
956:           	    return; 
957:           	}  
958:           
959:               /*
960:                * Task D: Servicing USB Transaction Complete Interrupt
961:                */
962:               if(USBTransactionCompleteIE)
023B  003D     MOVLB 0x1D
023C  1D92     BTFSS PIR2, 0x3
023D  2A3F     GOTO 0x23F
023E  2A40     GOTO 0x240
023F  29CB     GOTO 0x1CB
963:               {
964:           	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
0240  0021     MOVLB 0x1
0241  01A8     CLRF 0x28
027E  0021     MOVLB 0x1
027F  0AA8     INCF 0x28, F
0280  3004     MOVLW 0x4
0281  0228     SUBWF 0x28, W
0282  1C03     BTFSS STATUS, 0x0
0283  2A85     GOTO 0x285
0284  2A86     GOTO 0x286
0285  2A42     GOTO 0x242
0286  29CB     GOTO 0x1CB
965:           		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
966:           		    if(USBTransactionCompleteIF)
0242  003D     MOVLB 0x1D
0243  1D90     BTFSS 0x10, 0x3
0244  2A46     GOTO 0x246
0245  2A47     GOTO 0x247
0246  29CB     GOTO 0x1CB
967:           		    {
968:               		    //Save and extract USTAT register info.  Will use this info later.
969:                           USTATcopy.Val = U1STAT;
0247  080F     MOVF 0xF, W
0248  0021     MOVLB 0x1
0249  00EF     MOVWF pBDTEntryEP0OutNext
970:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
024A  0C6F     RRF pBDTEntryEP0OutNext, W
024B  00A7     MOVWF 0x27
024C  0CA7     RRF 0x27, F
024D  0C27     RRF 0x27, W
024E  390F     ANDLW 0xF
024F  0022     MOVLB 0x2
0250  00BC     MOVWF 0x3C
971:                           
972:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0251  003D     MOVLB 0x1D
0252  1190     BCF 0x10, 0x3
973:                           
974:                           //Keep track of the hardware ping pong state for endpoints other
975:                           //than EP0, if ping pong buffering is enabled.
976:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
977:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
0253  0021     MOVLB 0x1
0254  196F     BTFSC pBDTEntryEP0OutNext, 0x2
0255  2A57     GOTO 0x257
0256  2A58     GOTO 0x258
0257  2A61     GOTO 0x261
978:                               {
979:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
0258  0022     MOVLB 0x2
0259  083C     MOVF 0x3C, W
025A  3E28     ADDLW 0x28
025B  0086     MOVWF FSR1L
025C  3001     MOVLW 0x1
025D  0087     MOVWF FSR1H
025E  3001     MOVLW 0x1
025F  0681     XORWF INDF1, F
980:                               }   
0260  2A69     GOTO 0x269
981:                               else
982:                               {
983:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
0261  0022     MOVLB 0x2
0262  083C     MOVF 0x3C, W
0263  3E26     ADDLW 0x26
0264  0086     MOVWF FSR1L
0265  3001     MOVLW 0x1
0266  0087     MOVWF FSR1H
0267  3001     MOVLW 0x1
0268  0681     XORWF INDF1, F
984:                               }         
985:                           #endif    
986:                           
987:                           //USBCtrlEPService only services transactions over EP0.
988:                           //It ignores all other EP transactions.
989:                           if(endpoint_number == 0)
0269  08BC     MOVF 0x3C, F
026A  1D03     BTFSS STATUS, 0x2
026B  2A6D     GOTO 0x26D
026C  2A6E     GOTO 0x26E
026D  2A72     GOTO 0x272
990:                           {
991:                               USBCtrlEPService();
026E  3186     MOVLP 0x6
026F  26B7     CALL 0x6B7
0270  3181     MOVLP 0x1
992:                           }
0271  2A7E     GOTO 0x27E
993:                           else
994:                           {
995:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
0272  3072     MOVLW 0x72
0273  0020     MOVLB 0x0
0274  00E0     MOVWF count
0275  01E1     CLRF 0x61
0276  30EF     MOVLW 0xEF
0277  00E2     MOVWF 0x62
0278  3000     MOVLW 0x0
0279  00E3     MOVWF 0x63
027A  01E4     CLRF 0x64
027B  01E5     CLRF 0x65
027C  2288     CALL 0x288
027D  3181     MOVLP 0x1
996:                           }
997:           		    }//end if(USBTransactionCompleteIF)
998:           		    else
999:           		    	break;	//USTAT FIFO must be empty.
1000:          		}//end for()
1001:          	}//end if(USBTransactionCompleteIE)   
1002:          
1003:              USBClearUSBInterrupt();
1004:          }//end of USBDeviceTasks()
0287  0008     RETURN
1005:          
1006:          /*******************************************************************************
1007:            Function:
1008:                  void USBEnableEndpoint(BYTE ep, BYTE options)
1009:              
1010:            Summary:
1011:              This function will enable the specified endpoint with the specified
1012:              options
1013:            Description:
1014:              This function will enable the specified endpoint with the specified
1015:              options.
1016:              
1017:              Typical Usage:
1018:              <code>
1019:              void USBCBInitEP(void)
1020:              {
1021:                  USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1022:                  USBMSDInit();
1023:              }
1024:              </code>
1025:              
1026:              In the above example endpoint number MSD_DATA_IN_EP is being configured
1027:              for both IN and OUT traffic with handshaking enabled. Also since
1028:              MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1029:              explicitly disable SETUP packets on this endpoint.
1030:            Conditions:
1031:              None
1032:            Input:
1033:              BYTE ep -       the endpoint to be configured
1034:              BYTE options -  optional settings for the endpoint. The options should
1035:                              be ORed together to form a single options string. The
1036:                              available optional settings for the endpoint. The
1037:                              options should be ORed together to form a single options
1038:                              string. The available options are the following\:
1039:                              * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1040:                                NAK)
1041:                              * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1042:                                NAK)
1043:                              * USB_OUT_ENABLED enables the out direction
1044:                              * USB_OUT_DISABLED disables the out direction
1045:                              * USB_IN_ENABLED enables the in direction
1046:                              * USB_IN_DISABLED disables the in direction
1047:                              * USB_ALLOW_SETUP enables control transfers
1048:                              * USB_DISALLOW_SETUP disables control transfers
1049:                              * USB_STALL_ENDPOINT STALLs this endpoint
1050:            Return:
1051:              None
1052:            Remarks:
1053:              None                                                                                                          
1054:            *****************************************************************************/
1055:          void USBEnableEndpoint(BYTE ep, BYTE options)
1056:          {
1057:              unsigned char* p;
1058:                  
1059:              //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
1060:              //starting DTS state in the BDT entry.
1061:              if(options & USB_OUT_ENABLED)
1677  00DF     MOVWF handle
1678  1D5A     BTFSS i_718, 0x2
1679  2E7D     GOTO 0x67D
1062:              {
1063:                  USBConfigureEndpoint(ep, OUT_FROM_HOST);
167A  01D6     CLRF dest
167B  2696     CALL 0x696
167C  3196     MOVLP 0x16
1064:              }
1065:              if(options & USB_IN_ENABLED)
167D  1CDA     BTFSS i_718, 0x1
167E  2E83     GOTO 0x683
1066:              {
1067:                  USBConfigureEndpoint(ep, IN_TO_HOST);
167F  01D6     CLRF dest
1680  0AD6     INCF dest, F
1681  085F     MOVF handle, W
1682  2696     CALL 0x696
1068:              }
1069:          
1070:              //Update the relevant UEPx register to actually enable the endpoint with
1071:              //the specified options (ex: handshaking enabled, control transfers allowed,
1072:              //etc.)
1073:              #if defined(__C32__)
1074:                  p = (unsigned char*)(&U1EP0+(4*ep));
1075:              #else
1076:                  p = (unsigned char*)(&U1EP0+ep);
1683  085F     MOVF handle, W
1684  3E98     ADDLW 0x98
1685  00DB     MOVWF i
1686  300E     MOVLW 0xE
1687  01DC     CLRF work
1688  3DDC     ADDWFC work, F
1689  085B     MOVF i, W
168A  00DD     MOVWF y
168B  085C     MOVF work, W
168C  00DE     MOVWF split
1077:              #endif
1078:              *p = options;
168D  085A     MOVF i_718, W
168E  00DB     MOVWF i
168F  085D     MOVF y, W
1690  0086     MOVWF FSR1L
1691  085E     MOVF split, W
1692  0087     MOVWF FSR1H
1693  085B     MOVF i, W
1694  0081     MOVWF INDF1
1079:          }
1695  0008     RETURN
1080:          
1081:          
1082:          /*************************************************************************
1083:            Function:
1084:              USB_HANDLE USBTransferOnePacket(BYTE ep, BYTE dir, BYTE* data, BYTE len)
1085:              
1086:            Summary:
1087:              Transfers a single packet (one transaction) of data on the USB bus.
1088:          
1089:            Description:
1090:              The USBTransferOnePacket() function prepares a USB endpoint
1091:              so that it may send data to the host (an IN transaction), or 
1092:              receive data from the host (an OUT transaction).  The 
1093:              USBTransferOnePacket() function can be used both to receive	and 
1094:              send data to the host.  This function is the primary API function 
1095:              provided by the USB stack firmware for sending or receiving application 
1096:              data over the USB port.  
1097:          
1098:              The USBTransferOnePacket() is intended for use with all application 
1099:              endpoints.  It is not used for sending or receiving applicaiton data 
1100:              through endpoint 0 by using control transfers.  Separate API 
1101:              functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
1102:              USBEP0SendROMPtr() are provided for this purpose.
1103:          
1104:              The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
1105:              entry associated with an endpoint buffer, and sets the UOWN bit, which 
1106:              prepares the USB hardware to allow the transaction to complete.  The 
1107:              application firmware can use the USBHandleBusy() macro to check the 
1108:              status of the transaction, to see if the data has been successfully 
1109:              transmitted yet.
1110:          
1111:          
1112:              Typical Usage
1113:              <code>
1114:              //make sure that the we are in the configured state
1115:              if(USBGetDeviceState() == CONFIGURED_STATE)
1116:              {
1117:                  //make sure that the last transaction isn't busy by checking the handle
1118:                  if(!USBHandleBusy(USBInHandle))
1119:                  {
1120:          	        //Write the new data that we wish to send to the host to the INPacket[] array
1121:          	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
1122:          	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
1123:          	        //INPacket[2] = ... (fill in the rest of the packet data)
1124:          	      
1125:                      //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
1126:                      USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(BYTE*)&INPacket[0],sizeof(INPacket));
1127:                  }
1128:              }
1129:              </code>
1130:          
1131:            Conditions:
1132:              Before calling USBTransferOnePacket(), the following should be true.
1133:              1.  The USB stack has already been initialized (USBDeviceInit() was called).
1134:              2.  A transaction is not already pending on the specified endpoint.  This
1135:                  is done by checking the previous request using the USBHandleBusy() 
1136:                  macro (see the typical usage example).
1137:              3.  The host has already sent a set configuration request and the 
1138:                  enumeration process is complete.
1139:                  This can be checked by verifying that the USBGetDeviceState() 
1140:                  macro returns "CONFIGURED_STATE", prior to calling 
1141:                  USBTransferOnePacket().
1142:           					
1143:            Input:
1144:              BYTE ep - The endpoint number that the data will be transmitted or 
1145:          	          received on
1146:              BYTE dir - The direction of the transfer
1147:                         This value is either OUT_FROM_HOST or IN_TO_HOST
1148:              BYTE* data - For IN transactions: pointer to the RAM buffer containing 
1149:                           the data to be sent to the host.  For OUT transactions: pointer
1150:                           to the RAM buffer that the received data should get written to.
1151:             BYTE len - Length of the data needing to be sent (for IN transactions).
1152:                        For OUT transactions, the len parameter should normally be set
1153:                        to the endpoint size specified in the endpoint descriptor.    
1154:          
1155:            Return Values:
1156:              USB_HANDLE - handle to the transfer.  The handle is a pointer to 
1157:                           the BDT entry associated with this transaction.  The
1158:                           status of the transaction (ex: if it is complete or still
1159:                           pending) can be checked using the USBHandleBusy() macro
1160:                           and supplying the USB_HANDLE provided by
1161:                           USBTransferOnePacket().
1162:          
1163:            Remarks:
1164:              If calling the USBTransferOnePacket() function from within the USBCBInitEP()
1165:              callback function, the set configuration is still being processed and the
1166:              USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
1167:              the USBTransferOnePacket() may still be called, but make sure that the 
1168:              endpoint has been enabled and initialized by the USBEnableEndpoint() 
1169:              function first.  
1170:              
1171:            *************************************************************************/
1172:          __section("usb") USB_HANDLE  USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
1173:          {
1174:              volatile BDT_ENTRY* handle;
1175:          
1176:              //If the direction is IN
1177:              if(dir != 0)
02CD  00DE     MOVWF split
02CE  0859     MOVF x, W
02CF  1D03     BTFSS STATUS, 0x2
02D0  2AD2     GOTO 0x2D2
02D1  2AD9     GOTO 0x2D9
1178:              {
1179:                  //point to the IN BDT of the specified endpoint
1180:                  handle = pBDTEntryIn[ep];
02D2  085E     MOVF split, W
02D3  3E6A     ADDLW 0x6A
02D4  0086     MOVWF FSR1L
02D5  0187     CLRF FSR1H
02D6  0801     MOVF INDF1, W
02D7  00DF     MOVWF handle
1181:              }
02D8  2AE0     GOTO 0x2E0
1182:              else
1183:              {
1184:                  //else point to the OUT BDT of the specified endpoint
1185:                  handle = pBDTEntryOut[ep];
02D9  085E     MOVF split, W
02DA  3E2C     ADDLW 0x2C
02DB  0086     MOVWF FSR1L
02DC  3001     MOVLW 0x1
02DD  0087     MOVWF FSR1H
02DE  0801     MOVF INDF1, W
02DF  00DF     MOVWF handle
1186:              }
1187:              
1188:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1189:              //pBDTEntryOut[ep]) is initialized before using it.
1190:              if(handle == 0)
02E0  08DF     MOVF handle, F
02E1  1D03     BTFSS STATUS, 0x2
02E2  2AE4     GOTO 0x2E4
02E3  2AE5     GOTO 0x2E5
02E4  2AE7     GOTO 0x2E7
1191:              {
1192:          	    return 0;
02E5  3000     MOVLW 0x0
02E6  2B15     GOTO 0x315
1193:          	}
1194:          
1195:              //Toggle the DTS bit if required
1196:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1197:                  handle->STAT.Val ^= _DTSMASK;
1198:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1199:                  if(ep != 0)
1200:                  {
1201:                      handle->STAT.Val ^= _DTSMASK;
1202:                  }
1203:              #endif
1204:          
1205:              //Set the data pointer, data length, and enable the endpoint
1206:              handle->ADR = ConvertToPhysicalAddress(data);
02E7  085A     MOVF i_718, W
02E8  00DC     MOVWF work
02E9  3002     MOVLW 0x2
02EA  00DD     MOVWF y
02EB  085F     MOVF handle, W
02EC  3E02     ADDLW 0x2
02ED  0086     MOVWF FSR1L
02EE  0187     CLRF FSR1H
02EF  085C     MOVF work, W
02F0  3FC0     MOVWI [0]FSR1
02F1  085D     MOVF y, W
02F2  3FC1     MOVWI [1]FSR1
1207:              handle->CNT = len;
02F3  0A5F     INCF handle, W
02F4  0086     MOVWF FSR1L
02F5  0187     CLRF FSR1H
02F6  085B     MOVF i, W
02F7  0081     MOVWF INDF1
1208:              handle->STAT.Val &= _DTSMASK;
02F8  085F     MOVF handle, W
02F9  0086     MOVWF FSR1L
02FA  0187     CLRF FSR1H
02FB  3040     MOVLW 0x40
02FC  0581     ANDWF INDF1, F
1209:              handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
02FD  085F     MOVF handle, W
02FE  0086     MOVWF FSR1L
02FF  0187     CLRF FSR1H
0300  3088     MOVLW 0x88
0301  0481     IORWF INDF1, F
1210:          
1211:              //Point to the next buffer for ping pong purposes.
1212:              if(dir != OUT_FROM_HOST)
0302  0859     MOVF x, W
0303  1D03     BTFSS STATUS, 0x2
0304  2B06     GOTO 0x306
0305  2B0D     GOTO 0x30D
1213:              {
1214:                  //toggle over the to the next buffer for an IN endpoint
1215:                  USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
0306  085E     MOVF split, W
0307  3E6A     ADDLW 0x6A
0308  0086     MOVWF FSR1L
0309  0187     CLRF FSR1H
030A  3004     MOVLW 0x4
030B  0681     XORWF INDF1, F
1216:              }
030C  2B14     GOTO 0x314
1217:              else
1218:              {
1219:                  //toggle over the to the next buffer for an OUT endpoint
1220:                  USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
030D  085E     MOVF split, W
030E  3E2C     ADDLW 0x2C
030F  0086     MOVWF FSR1L
0310  3001     MOVLW 0x1
0311  0087     MOVWF FSR1H
0312  3004     MOVLW 0x4
0313  0681     XORWF INDF1, F
1221:              }
1222:              return (USB_HANDLE)handle;
0314  085F     MOVF handle, W
1223:          }
0315  0008     RETURN
1224:          
1225:          
1226:          /********************************************************************
1227:              Function:
1228:                  void USBStallEndpoint(BYTE ep, BYTE dir)
1229:                  
1230:              Summary:
1231:                   Configures the specified endpoint to send STALL to the host, the next
1232:                   time the host tries to access the endpoint.
1233:              
1234:              PreCondition:
1235:                  None
1236:                  
1237:              Parameters:
1238:                  BYTE ep - The endpoint number that should be configured to send STALL.
1239:                  BYTE dir - The direction of the endpoint to STALL, either 
1240:                             IN_TO_HOST or OUT_FROM_HOST.
1241:                  
1242:              Return Values:
1243:                  None
1244:                  
1245:              Remarks:
1246:                  None
1247:          
1248:           *******************************************************************/
1249:          void USBStallEndpoint(BYTE ep, BYTE dir)
1250:          {
1251:              BDT_ENTRY *p;
1252:          
1253:              if(ep == 0)
1254:              {
1255:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1256:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1257:                  //packet that will arrrive.
1258:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1259:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1260:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1261:                  pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
1262:                         
1263:              }
1264:              else
1265:              {
1266:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1267:                  p->STAT.Val |= _BSTALL | _USIE;
1268:              
1269:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1270:                  //then stall that entry as well
1271:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1272:              
1273:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1274:                  p->STAT.Val |= _BSTALL | _USIE;
1275:                  #endif
1276:              }
1277:          }
1278:          
1279:          /**************************************************************************
1280:              Function:
1281:                  void USBCancelIO(BYTE endpoint)
1282:              
1283:              Description:
1284:                  This function cancels the transfers pending on the specified endpoint.
1285:                  This function can only be used after a SETUP packet is received and 
1286:                  before that setup packet is handled.  This is the time period in which
1287:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1288:                  returns to the stack.
1289:          
1290:              Precondition:
1291:            
1292:              Parameters:
1293:                  BYTE endpoint - the endpoint number you wish to cancel the transfers for
1294:               
1295:              Return Values:
1296:                  None
1297:                  
1298:              Remarks:
1299:                  None
1300:                                                                    
1301:            **************************************************************************/
1302:          void USBCancelIO(BYTE endpoint)
1303:          {
1304:              if(USBPacketDisable == 1)
1305:              {
1306:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1307:              	//to mess with the BDT right now.
1308:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1309:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1310:              	
1311:              	//Need to do additional handling if ping-pong buffering is being used
1312:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1313:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1314:                  //(either due to SIE clearing it after a transaction, or the firmware
1315:                  //clearing it) makes hardware ping pong pointer advance.
1316:                  USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
1317:              
1318:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1319:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1320:                  #endif
1321:              }
1322:          }
1323:          
1324:          /**************************************************************************
1325:              Function:
1326:                  void USBDeviceDetach(void)
1327:             
1328:              Summary:
1329:                  This function configures the USB module to "soft detach" itself from
1330:                  the USB host.
1331:                  
1332:              Description:
1333:                  This function configures the USB module to perform a "soft detach"
1334:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1335:                  lets the host know the device is present and attached.  This will make
1336:                  the host think that the device has been unplugged.  This is potentially
1337:                  useful, as it allows the USB device to force the host to re-enumerate
1338:                  the device (on the firmware has re-enabled the USB module/pull up, by
1339:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1340:                  
1341:              Precondition:
1342:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1343:                  section if USB_POLLING mode option is being used (usb_config.h option).
1344:          
1345:                  Additionally, this function should only be called from the main() loop 
1346:                  context.  Do not call this function from within an interrupt handler, as 
1347:                  this function may modify global interrupt enable bits and settings.
1348:                  
1349:              Parameters:
1350:                  None
1351:               
1352:              Return Values:
1353:                  None
1354:                  
1355:              Remarks:
1356:                  If the application firmware calls USBDeviceDetach(), it is strongly
1357:                  recommended that the firmware wait at least >= 80ms before calling
1358:                  USBDeviceAttach().  If the firmeware performs a soft detach, and then
1359:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1360:                  hosts may interpret this as an unexpected "glitch" rather than as a
1361:                  physical removal/re-attachment of the USB device.  In this case the host
1362:                  may simply ignore the event without re-enumerating the device.  To 
1363:                  ensure that the host properly detects and processes the device soft
1364:                  detach/re-attach, it is recommended to make sure the device remains 
1365:                  detached long enough to mimic a real human controlled USB 
1366:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1367:                  call USBDeviceAttach() for at least 80+ms, preferrably longer.
1368:                  
1369:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1370:                  or take long to execute.  It is the application firmware's 
1371:                  responsibility for adding the 80+ms delay, when using these API 
1372:                  functions.
1373:                  
1374:                  Note: The Windows plug and play event handler processing is fairly 
1375:                  slow, especially in certain versions of Windows, and for certain USB
1376:                  device classes.  It has been observed that some device classes need to
1377:                  provide even more USB detach dwell interval (before calling 
1378:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1379:                  If the USB device is a CDC class device, it is recommended to wait
1380:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1381:                  to provide the plug and play event handler enough time to finish 
1382:                  processing the removal event, before the re-attach occurs.
1383:                  
1384:                  If the application is using the USB_POLLING mode option, then the 
1385:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1386:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1387:                  and "#define USB_BUS_SENSE" options in the 
1388:                  HardwareProfile – [platform name].h file. 
1389:          
1390:                  When using the USB_POLLING mode option, and the 
1391:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1392:                  the USB stack assumes that it should always enable the USB module at 
1393:                  pretty much all times.  Basically, anytime the application firmware 
1394:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1395:                  module.  This mode would typically be selected if the application was 
1396:                  designed to be a purely bus powered device.  In this case, the 
1397:                  application is powered from the +5V VBUS supply from the USB port, so 
1398:                  it is correct and sensible in this type of application to power up and 
1399:                  turn on the USB module, at anytime that the microcontroller is 
1400:                  powered (which implies the USB cable is attached and the host is also 
1401:                  powered).
1402:          
1403:                  In a self powered application, the USB stack is designed with the 
1404:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1405:                  option in the HardwareProfile – [platform name].h file.  When this 
1406:                  option is defined, then the USBDeviceTasks() function will automatically 
1407:                  check the I/O pin port value of the designated pin (based on the 
1408:                  #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h 
1409:                  file), every time the application calls USBDeviceTasks().  If the 
1410:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1411:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1412:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1413:                  If however the USBDeviceTasks() function is executed and finds the pin 
1414:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1415:                  will automatically enable the USB module, if it has not already been 
1416:                  enabled.        
1417:                                                                    
1418:            **************************************************************************/
1419:          #if defined(USB_INTERRUPT)
1420:          void USBDeviceDetach(void)
1421:          {
1422:              //If the interrupt option is selected then the customer is required
1423:              //  to notify the stack when the device is attached or removed from the
1424:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1425:          #ifdef USB_SUPPORT_OTG
1426:              if (USB_BUS_SENSE != 1)
1427:          #endif
1428:              {
1429:                   // Disable module & detach from bus
1430:                   U1CON = 0;             
1431:          
1432:                   // Mask all USB interrupts              
1433:                   U1IE = 0;          
1434:          
1435:                   //Move to the detached state                  
1436:                   USBDeviceState = DETACHED_STATE;
1437:          
1438:                   #ifdef  USB_SUPPORT_OTG    
1439:                       //Disable D+ Pullup
1440:                       U1OTGCONbits.DPPULUP = 0;
1441:          
1442:                       //Disable HNP
1443:                       USBOTGDisableHnp();
1444:          
1445:                       //Deactivate HNP
1446:                       USBOTGDeactivateHnp();
1447:                       
1448:                       //If ID Pin Changed State
1449:                       if (USBIDIF && USBIDIE)
1450:                       {  
1451:                           //Re-detect & Initialize
1452:                            USBOTGInitialize();
1453:          
1454:                            //Clear ID Interrupt Flag
1455:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1456:                       }
1457:                   #endif
1458:          
1459:                   #if defined __C30__ || defined __XC16__
1460:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1461:                   #endif
1462:                      //return so that we don't go through the rest of 
1463:                      //the state machine
1464:                    return;
1465:              }
1466:          
1467:          #ifdef USB_SUPPORT_OTG
1468:              //If Session Is Started Then
1469:             else
1470:             {
1471:                  //If SRP Is Ready
1472:                  if (USBOTGSRPIsReady())
1473:                  {   
1474:                      //Clear SRPReady
1475:                      USBOTGClearSRPReady();
1476:          
1477:                      //Clear SRP Timeout Flag
1478:                      USBOTGClearSRPTimeOutFlag();
1479:          
1480:                      //Indicate Session Started
1481:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1482:                  }
1483:              }
1484:          #endif
1485:          }
1486:          #endif  //#if defined(USB_INTERRUPT)
1487:          /**************************************************************************
1488:              Function:
1489:                  void USBDeviceAttach(void)
1490:              
1491:              Summary:
1492:                  Checks if VBUS is present, and that the USB module is not already 
1493:                  initalized, and if so, enables the USB module so as to signal device 
1494:                  attachment to the USB host.   
1495:          
1496:              Description:
1497:                  This function indicates to the USB host that the USB device has been
1498:                  attached to the bus.  This function needs to be called in order for the
1499:                  device to start to enumerate on the bus.
1500:                          
1501:              Precondition:
1502:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1503:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1504:                  from within an interrupt handler, as the USBDeviceAttach() function
1505:                  may modify global interrupt enable bits and settings.
1506:          
1507:                  For normal USB devices:
1508:                  Make sure that if the module was previously on, that it has been turned off 
1509:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1510:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1511:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1512:                  reject this event, since no human could ever unplug and reattach a USB device in a 
1513:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1514:                  of glitch and ignore the event altogether.  
1515:              Parameters:
1516:                  None
1517:               
1518:              Return Values:
1519:                  None       
1520:              
1521:              Remarks: 
1522:          		See also the USBDeviceDetach() API function documentation.                                                 
1523:          ****************************************************************************/
1524:          #if defined(USB_INTERRUPT)
1525:          void USBDeviceAttach(void)
1526:          {
1527:              //if we are in the detached state
1528:              if(USBDeviceState == DETACHED_STATE)
1529:              {
1530:                  if(USB_BUS_SENSE == 1)
1531:                  {
1532:              	    //Initialize registers to known states.
1533:                      U1CON = 0;          
1534:              
1535:                      // Mask all USB interrupts
1536:                      U1IE = 0;                                
1537:              
1538:                      //Configure things like: pull ups, full/low-speed mode, 
1539:                      //set the ping pong mode, and set internal transceiver
1540:                      SetConfigurationOptions();
1541:              
1542:                      USBEnableInterrupts();  //Modifies global interrupt settings
1543:              
1544:                      // Enable module & attach to bus
1545:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1546:              
1547:                      //moved to the attached state
1548:                      USBDeviceState = ATTACHED_STATE;
1549:              
1550:                      #ifdef  USB_SUPPORT_OTG
1551:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1552:                      #endif
1553:                  }
1554:              }
1555:          }
1556:          #endif  //#if defined(USB_INTERRUPT)
1557:          
1558:          
1559:          /*******************************************************************************
1560:            Function: void USBCtrlEPAllowStatusStage(void);
1561:              
1562:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT 
1563:                      (based on the controlTransferState) to allow the status stage packet
1564:                      of a control transfer to complete.  This function gets used 
1565:                      internally by the USB stack itself, but it may also be called from
1566:                      the application firmware, IF the application firmware called
1567:                      the USBDeferStatusStage() function during the initial processing
1568:                      of the control transfer request.  In this case, the application
1569:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1570:                      completed processing and handling the data stage portion of the
1571:                      request.  
1572:                      
1573:                      If the application firmware has no need for delaying control 
1574:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1575:                      application firmware should not call USBCtrlEPAllowStatusStage().
1576:                      
1577:            Description:
1578:              
1579:            Conditions:
1580:              None
1581:          
1582:            Input:
1583:          
1584:            Return:
1585:          
1586:            Remarks:
1587:              None                                                                                                          
1588:            *****************************************************************************/
1589:          void __section("usb") USBCtrlEPAllowStatusStage(void)
1590:          {
1591:              //Check and set two flags, prior to actually modifying any BDT entries.
1592:              //This double checking is necessary to make certain that 
1593:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1594:              //in main loop context, while simultaneously getting an interrupt which 
1595:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1596:              if(USBStatusStageEnabledFlag1 == FALSE)
0796  0022     MOVLB 0x2
1597:              {
1598:                  USBStatusStageEnabledFlag1 = TRUE;  
079A  3001     MOVLW 0x1
079B  00B8     MOVWF 0x38
1599:                  if(USBStatusStageEnabledFlag2 == FALSE)
079C  08B9     MOVF 0x39, F
079D  1D03     BTFSS STATUS, 0x2
079E  0008     RETURN
1600:                  {
1601:                      USBStatusStageEnabledFlag2 = TRUE;
079F  00B9     MOVWF 0x39
1602:                  
1603:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1604:                      //stage), based on the type of control transfer currently pending.
1605:                      if(controlTransferState == CTRL_TRF_RX)
07A0  0020     MOVLB 0x0
07A1  086D     MOVF controlTransferState, W
07A2  3A02     XORLW 0x2
07A3  1D03     BTFSS STATUS, 0x2
07A4  2FAB     GOTO 0x7AB
1606:                      {
1607:                          pBDTEntryIn[0]->CNT = 0;
07A5  0A6A     INCF pBDTEntryIn, W
07A6  0086     MOVWF FSR1L
07A7  0187     CLRF FSR1H
07A8  0181     CLRF INDF1
1608:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
07A9  086A     MOVF pBDTEntryIn, W
07AA  2FE8     GOTO 0x7E8
1609:                      }
1610:                      else if(controlTransferState == CTRL_TRF_TX)
07AB  0B6D     DECFSZ controlTransferState, W
07AC  0008     RETURN
1611:                      {
1612:                  		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
07AD  0022     MOVLB 0x2
07AE  01B0     CLRF 0x30
1613:                  
1614:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1615:                          //next SETUP packet.
1616:                  		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1617:                  		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
07AF  0020     MOVLB 0x0
07B0  0A6E     INCF pBDTEntryEP0OutCurrent, W
07B1  0086     MOVWF FSR1L
07B2  3008     MOVLW 0x8
07B3  0187     CLRF FSR1H
07B4  0081     MOVWF INDF1
1618:                  		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
07B5  3040     MOVLW 0x40
07B6  00D6     MOVWF dest
07B7  01D7     CLRF product
07B8  086E     MOVF pBDTEntryEP0OutCurrent, W
07B9  27E1     CALL 0x7E1
07BA  3186     MOVLP 0x6
1619:                  		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
07BB  086E     MOVF pBDTEntryEP0OutCurrent, W
07BC  0086     MOVWF FSR1L
07BD  3084     MOVLW 0x84
07BE  0081     MOVWF INDF1
1620:                  		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
07BF  0022     MOVLB 0x2
07C0  01B0     CLRF 0x30
07C1  0AB0     INCF 0x30, F
1621:                  		#endif
1622:                  
1623:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1624:                  		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
07C2  0020     MOVLB 0x0
07C3  0A6F     INCF pBDTEntryEP0OutNext, W
07C4  0086     MOVWF FSR1L
07C5  3008     MOVLW 0x8
07C6  0081     MOVWF INDF1
1625:                  		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
07C7  3040     MOVLW 0x40
07C8  00D6     MOVWF dest
07C9  01D7     CLRF product
07CA  086F     MOVF pBDTEntryEP0OutNext, W
07CB  27E1     CALL 0x7E1
1626:                  		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
07CC  086F     MOVF pBDTEntryEP0OutNext, W
07CD  0086     MOVWF FSR1L
07CE  3080     MOVLW 0x80
07CF  0081     MOVWF INDF1
07D0  0008     RETURN
1627:                      }
1628:                  }    
1629:              }
1630:          }   
07D1  0A6F     INCF pBDTEntryEP0OutNext, W
1631:          
1632:          
1633:          /*******************************************************************************
1634:            Function: void USBCtrlEPAllowDataStage(void);
1635:              
1636:            Summary: This function allows the data stage of either a host-to-device or
1637:                      device-to-host control transfer (with data stage) to complete.
1638:                      This function is meant to be used in conjunction with either the
1639:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1640:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1641:                      then the firmware does not need to manually call 
1642:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1643:                      instead.
1644:               
1645:            Description:
1646:              
1647:            Conditions: A control transfer (with data stage) should already be pending, 
1648:                          if the firmware calls this function.  Additionally, the firmware
1649:                          should have called either USBDeferOUTDataStage() or 
1650:                          USBDeferINDataStage() at the start of the control transfer, if
1651:                          the firmware will be calling this function manually.
1652:          
1653:            Input:
1654:          
1655:            Return:
1656:          
1657:            Remarks: 
1658:            *****************************************************************************/
1659:          void USBCtrlEPAllowDataStage(void)
1660:          {
1661:              USBDeferINDataStagePackets = FALSE;
0601  01B5     CLRF 0x35
1662:              USBDeferOUTDataStagePackets = FALSE;
0602  01B6     CLRF 0x36
1663:          
1664:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0603  0020     MOVLB 0x0
0604  086D     MOVF controlTransferState, W
0605  3A02     XORLW 0x2
0606  1D03     BTFSS STATUS, 0x2
0607  2E1A     GOTO 0x61A
1665:              {
1666:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1667:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0608  0A6F     INCF pBDTEntryEP0OutNext, W
0609  0086     MOVWF FSR1L
060A  3008     MOVLW 0x8
060B  0187     CLRF FSR1H
060C  0081     MOVWF INDF1
1668:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
060D  3048     MOVLW 0x48
060E  00D9     MOVWF x
060F  01DA     CLRF i_718
0610  086F     MOVF pBDTEntryEP0OutNext, W
0611  3E02     ADDLW 0x2
0612  0086     MOVWF FSR1L
0613  0859     MOVF x, W
0614  3FC0     MOVWI [0]FSR1
0615  085A     MOVF i_718, W
0616  3FC1     MOVWI [1]FSR1
1669:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0617  086F     MOVF pBDTEntryEP0OutNext, W
0618  3187     MOVLP 0x7
0619  2FE8     GOTO 0x7E8
1670:              }   
1671:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1672:              {
1673:                  //Error check the data stage byte count.  Make sure the user specified
1674:                  //value was no greater than the number of bytes the host requested.
1675:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
061A  0022     MOVLB 0x2
061B  084E     MOVF 0x4E, W
061C  0020     MOVLB 0x0
061D  0247     SUBWF 0x47, W
061E  1D03     BTFSS STATUS, 0x2
061F  2E24     GOTO 0x624
0620  0022     MOVLB 0x2
0621  084D     MOVF 0x4D, W
0622  0020     MOVLB 0x0
0623  0246     SUBWF 0x46, W
0624  1803     BTFSC STATUS, 0x0
0625  2E2D     GOTO 0x62D
1676:          		{
1677:          			inPipes[0].wCount.Val = SetupPkt.wLength;
0626  0847     MOVF 0x47, W
0627  0022     MOVLB 0x2
0628  00CE     MOVWF 0x4E
0629  0020     MOVLB 0x0
062A  0846     MOVF 0x46, W
062B  0022     MOVLB 0x2
062C  00CD     MOVWF 0x4D
1678:          		}
1679:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
062D  263D     CALL 0x63D
062E  3183     MOVLP 0x3
1680:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1681:          
1682:          	    //Cnt should have been initialized by responsible request owner (ex: by
1683:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1684:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
062F  3048     MOVLW 0x48
0630  00D9     MOVWF x
0631  01DA     CLRF i_718
0632  086A     MOVF pBDTEntryIn, W
0633  3E02     ADDLW 0x2
0634  0086     MOVWF FSR1L
0635  0187     CLRF FSR1H
0636  0859     MOVF x, W
0637  3FC0     MOVWI [0]FSR1
0638  085A     MOVF i_718, W
0639  3FC1     MOVWI [1]FSR1
1685:          		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
063A  086A     MOVF pBDTEntryIn, W
063B  3187     MOVLP 0x7
063C  2FE8     GOTO 0x7E8
1686:              }     
1687:          }    
063D  3008     MOVLW 0x8
1688:          
1689:          
1690:          /******************************************************************************/
1691:          /** Internal Functions *********************************************************/
1692:          /******************************************************************************/
1693:          
1694:          /********************************************************************
1695:           * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1696:           *
1697:           * PreCondition:    None
1698:           *
1699:           * Input:           BYTE EPNum - the endpoint to be configured
1700:           *                  BYTE direction - the direction to be configured
1701:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1702:           *
1703:           * Output:          None
1704:           *
1705:           * Side Effects:    None
1706:           *
1707:           * Overview:        This function will configure the specified 
1708:           *                  endpoint
1709:           *
1710:           * Note:            None
1711:           *******************************************************************/
1712:          static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1713:          {
1714:              volatile BDT_ENTRY* handle;
1715:          
1716:              //Compute a pointer to the even BDT entry corresponding to the
1717:              //EPNum and direction values passed to this function.
1718:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1696  00D8     MOVWF off
1697  3020     MOVLW 0x20
1698  00D9     MOVWF x
1719:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
1699  0856     MOVF dest, W
169A  00D7     MOVWF product
169B  35D7     LSLF product, F
169C  0858     MOVF off, W
169D  0709     ADDWF WREG, W
169E  0709     ADDWF WREG, W
169F  0757     ADDWF product, W
16A0  0709     ADDWF WREG, W
16A1  0709     ADDWF WREG, W
16A2  07D9     ADDWF x, F
1720:              
1721:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
16A3  0859     MOVF x, W
16A4  0086     MOVWF FSR1L
16A5  0187     CLRF FSR1H
16A6  1381     BCF INDF1, 0x7
1722:              //already cleared the entire BDT table
1723:          
1724:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1725:              //for USBTransferOnePacket() API calls.
1726:              if(direction == OUT_FROM_HOST)
16A7  08D6     MOVF dest, F
16A8  1D03     BTFSS STATUS, 0x2
16A9  2EB0     GOTO 0x6B0
1727:              {
1728:                  pBDTEntryOut[EPNum] = handle;
16AA  0858     MOVF off, W
16AB  3E2C     ADDLW 0x2C
16AC  0086     MOVWF FSR1L
16AD  3001     MOVLW 0x1
16AE  0087     MOVWF FSR1H
16AF  2EB4     GOTO 0x6B4
1729:              }
1730:              else
1731:              {
1732:                  pBDTEntryIn[EPNum] = handle;
16B0  0858     MOVF off, W
16B1  3E6A     ADDLW 0x6A
16B2  0086     MOVWF FSR1L
16B3  0187     CLRF FSR1H
16B4  0859     MOVF x, W
16B5  0081     MOVWF INDF1
1733:              }
1734:          
1735:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1736:                  handle->STAT.DTS = 0;
16B6  0859     MOVF x, W
16B7  0086     MOVWF FSR1L
16B8  0187     CLRF FSR1H
16B9  1301     BCF INDF1, 0x6
1737:                  (handle+1)->STAT.DTS = 1;
16BA  0859     MOVF x, W
16BB  3E04     ADDLW 0x4
16BC  0086     MOVWF FSR1L
16BD  1701     BSF INDF1, 0x6
1738:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1739:                  //Set DTS to one because the first thing we will do
1740:                  //when transmitting is toggle the bit
1741:                  handle->STAT.DTS = 1;
1742:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1743:                  if(EPNum != 0)
1744:                  {
1745:                      handle->STAT.DTS = 1;
1746:                  }
1747:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1748:                  if(EPNum != 0)
1749:                  {
1750:                      handle->STAT.DTS = 0;
1751:                      (handle+1)->STAT.DTS = 1;
1752:                  }
1753:              #endif
1754:          }
16BE  0008     RETURN
1755:          
1756:          
1757:          /******************************************************************************
1758:           * Function:        void USBCtrlEPServiceComplete(void)
1759:           *
1760:           * PreCondition:    None
1761:           *
1762:           * Input:           None
1763:           *
1764:           * Output:          None
1765:           *
1766:           * Side Effects:    None
1767:           *
1768:           * Overview:        This routine wrap up the remaining tasks in servicing
1769:           *                  a Setup Request. Its main task is to set the endpoint
1770:           *                  controls appropriately for a given situation. See code
1771:           *                  below.
1772:           *                  There are three main scenarios:
1773:           *                  a) There was no handler for the Request, in this case
1774:           *                     a STALL should be sent out.
1775:           *                  b) The host has requested a read control transfer,
1776:           *                     endpoints are required to be setup in a specific way.
1777:           *                  c) The host has requested a write control transfer, or
1778:           *                     a control data stage is not required, endpoints are
1779:           *                     required to be setup in a specific way.
1780:           *
1781:           *                  Packet processing is resumed by clearing PKTDIS bit.
1782:           *
1783:           * Note:            None
1784:           *****************************************************************************/
1785:          static void USBCtrlEPServiceComplete(void)
1786:          {
1787:              /*
1788:               * PKTDIS bit is set when a Setup Transaction is received.
1789:               * Clear to resume packet processing.
1790:               */
1791:              USBPacketDisable = 0;
05C6  003D     MOVLB 0x1D
05C7  120E     BCF PORTC, 0x4
1792:          
1793:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1794:          	//control transfer is currently in progress.  We need to know the type of control
1795:          	//transfer that is currently pending, in order to know how to properly arm the 
1796:          	//EP0 IN and EP0 OUT endpoints.
1797:              if(inPipes[0].info.bits.busy == 0)
05C8  0022     MOVLB 0x2
05C9  1BCC     BTFSC 0x4C, 0x7
05CA  2DE4     GOTO 0x5E4
1798:              {
1799:                  if(outPipes[0].info.bits.busy == 1)
05CB  1FA2     BTFSS 0x22, 0x7
05CC  2DD9     GOTO 0x5D9
1800:                  {
1801:                      controlTransferState = CTRL_TRF_RX;
05CD  3002     MOVLW 0x2
05CE  0020     MOVLB 0x0
05CF  00ED     MOVWF controlTransferState
1802:                      /*
1803:                       * Control Write:
1804:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1805:                       */
1806:          
1807:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1808:                      //   function decided to defer the data stage (ex: because the intended
1809:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1810:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1811:                      //   once it is ready to begin receiving the data.
1812:                      if(USBDeferOUTDataStagePackets == FALSE)
05D0  0022     MOVLB 0x2
05D1  08B6     MOVF 0x36, F
05D2  1D03     BTFSS STATUS, 0x2
05D3  2DD5     GOTO 0x5D5
1813:                      {
1814:                          USBCtrlEPAllowDataStage();
05D4  2601     CALL 0x601
1815:                      }
1816:                      
1817:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1818:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1819:                      USBStatusStageEnabledFlag2 = FALSE;
05D5  0022     MOVLB 0x2
05D6  01B9     CLRF 0x39
1820:                      USBStatusStageEnabledFlag1 = FALSE;
05D7  01B8     CLRF 0x38
1821:                  }
05D8  0008     RETURN
1822:                  else
1823:                  {
1824:                      /*
1825:                       * If no one knows how to service this request then stall.
1826:                       * Must also prepare EP0 to receive the next SETUP transaction.
1827:                       */
1828:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
05D9  0020     MOVLB 0x0
05DA  0A6F     INCF pBDTEntryEP0OutNext, W
05DB  0086     MOVWF FSR1L
05DC  268D     CALL 0x68D
1829:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1830:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
05DD  308C     MOVLW 0x8C
05DE  0081     MOVWF INDF1
1831:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
05DF  086A     MOVF pBDTEntryIn, W
05E0  0086     MOVWF FSR1L
05E1  3084     MOVLW 0x84
05E2  0081     MOVWF INDF1
05E3  0008     RETURN
1832:                  }
1833:              }
1834:              else    // A module has claimed ownership of the control transfer session.
1835:              {
1836:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
05E4  0020     MOVLB 0x0
05E5  1FC0     BTFSS SetupPkt, 0x7
05E6  2DF8     GOTO 0x5F8
1837:          		{
1838:          			controlTransferState = CTRL_TRF_TX;
05E7  01ED     CLRF controlTransferState
05E8  0AED     INCF controlTransferState, F
1839:          			/*
1840:          			 * Control Read:
1841:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1842:          			 *
1843:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1844:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1845:          			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
1846:          			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1847:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1848:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1849:          			 *    is ready to begin sending the data, it should then call the 
1850:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1851:          			 */
1852:          			if(USBDeferINDataStagePackets == FALSE)
05E9  0022     MOVLB 0x2
05EA  08B5     MOVF 0x35, F
05EB  1D03     BTFSS STATUS, 0x2
05EC  2DEF     GOTO 0x5EF
1853:                      {
1854:                          USBCtrlEPAllowDataStage();
05ED  2601     CALL 0x601
05EE  3183     MOVLP 0x3
1855:          			}
1856:          
1857:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1858:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
1859:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1860:                      //    is ready.  If the class request handler does this, it needs to be careful to
1861:                      //    be written so that it can handle the early termination scenario.
1862:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1863:                      //    1.  The desired total number of bytes were sent to the host.
1864:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1865:                      //        started the control transfer) has been reached.
1866:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1867:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1868:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1869:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1870:                      //        option can take care of this for you.
1871:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1872:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1873:                      //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1874:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1875:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1876:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1877:                      USBStatusStageEnabledFlag2 = FALSE;
05EF  0022     MOVLB 0x2
05F0  01B9     CLRF 0x39
1878:                      USBStatusStageEnabledFlag1 = FALSE;
05F1  01B8     CLRF 0x38
1879:                      if(USBDeferStatusStagePacket == FALSE)
05F2  0020     MOVLB 0x0
05F3  08EC     MOVF USBDeferStatusStagePacket, F
05F4  1D03     BTFSS STATUS, 0x2
05F5  0008     RETURN
1880:                      {
1881:                          USBCtrlEPAllowStatusStage();
05F6  3187     MOVLP 0x7
05F7  2F96     GOTO 0x796
1882:                      } 
1883:          		}
1884:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1885:          		{
1886:          			//This situation occurs for special types of control transfers,
1887:          			//such as that which occurs when the host sends a SET_ADDRESS
1888:          			//control transfer.  Ex:
1889:          			//
1890:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1891:          				
1892:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1893:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1894:          			//an IN status stage.
1895:          
1896:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
05F8  3002     MOVLW 0x2
05F9  00ED     MOVWF controlTransferState
1897:          			
1898:          			//1. Prepare OUT EP to receive the next SETUP packet.
1899:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
05FA  0A6F     INCF pBDTEntryEP0OutNext, W
05FB  0086     MOVWF FSR1L
05FC  268D     CALL 0x68D
05FD  3183     MOVLP 0x3
1900:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1901:          			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
05FE  3084     MOVLW 0x84
05FF  0081     MOVWF INDF1
0600  2DEF     GOTO 0x5EF
1902:          				
1903:          			//2. Prepare for IN status stage of the control transfer
1904:                      USBStatusStageEnabledFlag2 = FALSE;
1905:                      USBStatusStageEnabledFlag1 = FALSE;
1906:          			if(USBDeferStatusStagePacket == FALSE)
1907:                      {
1908:                          USBCtrlEPAllowStatusStage();
1909:                      } 
1910:          		}
1911:          
1912:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1913:          
1914:          }//end USBCtrlEPServiceComplete
0601  01B5     CLRF 0x35
1915:          
1916:          
1917:          /******************************************************************************
1918:           * Function:        void USBCtrlTrfTxService(void)
1919:           *
1920:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1921:           *
1922:           * Input:           None
1923:           *
1924:           * Output:          None
1925:           *
1926:           * Side Effects:    None
1927:           *
1928:           * Overview:        This routine is used for device to host control transfers 
1929:           *					(IN transactions).  This function takes care of managing a
1930:           *                  transfer over multiple USB transactions.
1931:           *					This routine should be called from only two places.
1932:           *                  One from USBCtrlEPServiceComplete() and one from
1933:           *                  USBCtrlTrfInHandler().
1934:           *
1935:           * Note:            
1936:           *****************************************************************************/
1937:          static void USBCtrlTrfTxService(void)
1938:          {
1939:              BYTE byteToSend;
1940:          
1941:              //Figure out how many bytes of data to send in the next IN transaction.
1942:              //Assume a full size packet, unless otherwise determined below.
1943:              byteToSend = USB_EP0_BUFF_SIZE;         
063D  3008     MOVLW 0x8
063E  0020     MOVLB 0x0
063F  00D8     MOVWF off
1944:              if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
0640  3000     MOVLW 0x0
0641  0022     MOVLB 0x2
0642  024E     SUBWF 0x4E, W
0643  3008     MOVLW 0x8
0644  1903     BTFSC STATUS, 0x2
0645  024D     SUBWF 0x4D, W
0646  1803     BTFSC STATUS, 0x0
0647  2E56     GOTO 0x656
1945:              {
1946:                  byteToSend = inPipes[0].wCount.Val;
0648  084D     MOVF 0x4D, W
0649  0020     MOVLB 0x0
064A  00D8     MOVWF off
1947:          
1948:                  //Keep track of whether or not we have sent a "short packet" yet.
1949:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1950:                  //after we have sent all of the intended data.  This makes sure the
1951:                  //hardware STALLs if the host erroneously tries to send more IN token 
1952:                  //packets, requesting more data than intended in the control transfer.
1953:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
064B  0022     MOVLB 0x2
064C  08C1     MOVF 0x41, F
064D  1D03     BTFSS STATUS, 0x2
064E  2E52     GOTO 0x652
1954:                  {
1955:                      shortPacketStatus = SHORT_PKT_PENDING;
064F  01C1     CLRF 0x41
0650  0AC1     INCF 0x41, F
1956:                  }
0651  2E56     GOTO 0x656
1957:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0652  0B41     DECFSZ 0x41, W
0653  2E56     GOTO 0x656
1958:                  {
1959:                      shortPacketStatus = SHORT_PKT_SENT;
0654  3002     MOVLW 0x2
0655  00C1     MOVWF 0x41
1960:                  }
1961:              }
1962:          
1963:              //Keep track of how many bytes remain to be sent in the transfer, by
1964:              //subtracting the number of bytes about to be sent from the total.
1965:              inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
0656  0020     MOVLB 0x0
0657  0858     MOVF off, W
0658  00D6     MOVWF dest
0659  01D7     CLRF product
065A  0022     MOVLB 0x2
065B  024D     SUBWF 0x4D, W
065C  00CD     MOVWF 0x4D
065D  0020     MOVLB 0x0
065E  0857     MOVF product, W
065F  0022     MOVLB 0x2
0660  3B4E     SUBWFB 0x4E, W
0661  00CE     MOVWF 0x4E
1966:              
1967:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1968:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1969:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1970:              pBDTEntryIn[0]->CNT = byteToSend;
0662  0020     MOVLB 0x0
0663  0A6A     INCF pBDTEntryIn, W
0664  0086     MOVWF FSR1L
0665  0187     CLRF FSR1H
0666  0858     MOVF off, W
0667  0081     MOVWF INDF1
1971:          
1972:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1973:              //which we will send to the host.
1974:              pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
0668  3048     MOVLW 0x48
0669  0022     MOVLB 0x2
066A  00BF     MOVWF 0x3F
1975:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
066B  1C4C     BTFSS 0x4C, 0x0
066C  2E70     GOTO 0x670
066D  2E77     GOTO 0x677
1976:              {
1977:                  while(byteToSend)
0670  0020     MOVLB 0x0
0671  08D8     MOVF off, F
0672  1903     BTFSC STATUS, 0x2
0673  0008     RETURN
0674  2E6E     GOTO 0x66E
0675  267C     CALL 0x67C
0676  3183     MOVLP 0x3
1978:                  {
1979:                      *pDst++ = *inPipes[0].pSrc.bRom++;
066E  267C     CALL 0x67C
066F  3183     MOVLP 0x3
1980:                      byteToSend--;
1981:                  }//end while(byte_to_send.Val)
1982:              }
1983:              else  // RAM
1984:              {
1985:                  while(byteToSend)
0677  0020     MOVLB 0x0
0678  08D8     MOVF off, F
0679  1903     BTFSC STATUS, 0x2
067A  0008     RETURN
067B  2E75     GOTO 0x675
1986:                  {
1987:                      *pDst++ = *inPipes[0].pSrc.bRam++;
1988:                      byteToSend--;
1989:                  }//end while(byte_to_send.Val)
1990:              }//end if(usb_stat.ctrl_trf_mem == _ROM)
1991:          }//end USBCtrlTrfTxService
067C  0022     MOVLB 0x2
1992:          
1993:          /******************************************************************************
1994:           * Function:        void USBCtrlTrfRxService(void)
1995:           *
1996:           * PreCondition:    pDst and wCount are setup properly.
1997:           *                  pSrc is always &CtrlTrfData
1998:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1999:           *                  wCount should be set to 0 at the start of each control
2000:           *                  transfer.
2001:           *
2002:           * Input:           None
2003:           *
2004:           * Output:          None
2005:           *
2006:           * Side Effects:    None
2007:           *
2008:           * Overview:        This routine is used for host to device control transfers
2009:           *					(uses OUT transactions).  This function receives the data that arrives
2010:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2011:           *					buffer.  Once the host has sent all the data it was intending
2012:           *					to send, this function will call the appropriate outPipes[0].pFunc()
2013:           *					handler (unless it is NULL), so that it can be used by the
2014:           *					intended target firmware.
2015:           *
2016:           * Note:            None
2017:           *****************************************************************************/
2018:          static void USBCtrlTrfRxService(void)
2019:          {
2020:              BYTE byteToRead;
2021:              BYTE i;
2022:          
2023:              //Load byteToRead with the number of bytes the host just sent us in the 
2024:              //last OUT transaction.
2025:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
072B  086E     MOVF pBDTEntryEP0OutCurrent, W
072C  0086     MOVWF FSR1L
072D  0187     CLRF FSR1H
072E  3F41     MOVIW [1]FSR1
072F  00DB     MOVWF i
2026:          
2027:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2028:              //of remaining bytes expected to be received from the host, in the control
2029:              //transfer.  First check to see if the host sent us more bytes than the
2030:              //application firmware was expecting to receive.
2031:              if(byteToRead > outPipes[0].wCount.Val)
0730  00D8     MOVWF off
0731  01D9     CLRF x
0732  0859     MOVF x, W
0733  0022     MOVLB 0x2
0734  0224     SUBWF 0x24, W
0735  1D03     BTFSS STATUS, 0x2
0736  2F3B     GOTO 0x73B
0737  0020     MOVLB 0x0
0738  0858     MOVF off, W
0739  0022     MOVLB 0x2
073A  0223     SUBWF 0x23, W
073B  1803     BTFSC STATUS, 0x0
073C  2F40     GOTO 0x740
2032:              {
2033:                  byteToRead = outPipes[0].wCount.Val;
073D  0823     MOVF 0x23, W
073E  0020     MOVLB 0x0
073F  00DB     MOVWF i
2034:              }	
2035:              //Reduce the number of remaining bytes by the number we just received.
2036:          	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
0740  0020     MOVLB 0x0
0741  085B     MOVF i, W
0742  00D8     MOVWF off
0743  01D9     CLRF x
0744  0022     MOVLB 0x2
0745  0223     SUBWF 0x23, W
0746  00A3     MOVWF 0x23
0747  0020     MOVLB 0x0
0748  0859     MOVF x, W
0749  0022     MOVLB 0x2
074A  3B24     SUBWFB 0x24, W
074B  00A4     MOVWF 0x24
2037:          
2038:              //Copy the OUT DATAx packet bytes that we just received from the host,
2039:              //into the user application buffer space.
2040:              for(i=0;i<byteToRead;i++)
074C  0020     MOVLB 0x0
074D  01DA     CLRF i_718
074E  085B     MOVF i, W
074F  025A     SUBWF i_718, W
0750  1803     BTFSC STATUS, 0x0
0751  2F62     GOTO 0x762
075F  0020     MOVLB 0x0
0760  0ADA     INCF i_718, F
0761  2F4E     GOTO 0x74E
2041:              {
2042:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0752  0022     MOVLB 0x2
0753  0820     MOVF BDT, W
0754  0086     MOVWF FSR1L
0755  0187     CLRF FSR1H
0756  0020     MOVLB 0x0
0757  085A     MOVF i_718, W
0758  3E48     ADDLW 0x48
0759  0084     MOVWF FSR0L
075A  0185     CLRF FSR0H
075B  0800     MOVF INDF0, W
075C  0081     MOVWF INDF1
075D  0022     MOVLB 0x2
075E  0AA0     INCF BDT, F
2043:              }//end while(byteToRead.Val)
2044:          
2045:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
2046:          	//the next packet in the sequence.
2047:              if(outPipes[0].wCount.Val > 0)
0762  3003     MOVLW 0x3
0763  3E20     ADDLW 0x20
0764  0086     MOVWF FSR1L
0765  3001     MOVLW 0x1
0766  0087     MOVWF FSR1H
0767  0016     MOVIW FSR1++
0768  0401     IORWF INDF1, W
0769  1903     BTFSC STATUS, 0x2
076A  2F81     GOTO 0x781
2048:              {
2049:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
076B  0A6F     INCF pBDTEntryEP0OutNext, W
076C  0086     MOVWF FSR1L
076D  3008     MOVLW 0x8
076E  0187     CLRF FSR1H
076F  0081     MOVWF INDF1
2050:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0770  3048     MOVLW 0x48
0771  27D7     CALL 0x7D7
0772  3186     MOVLP 0x6
2051:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0773  086E     MOVF pBDTEntryEP0OutCurrent, W
0774  0086     MOVWF FSR1L
0776  1B01     BTFSC INDF1, 0x6
0777  2F7C     GOTO 0x77C
2052:                  {
2053:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0775  086F     MOVF pBDTEntryEP0OutNext, W
0778  0086     MOVWF FSR1L
0779  30C8     MOVLW 0xC8
077A  0081     MOVWF INDF1
2054:                  }
077B  0008     RETURN
2055:                  else
2056:                  {
2057:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
077C  0086     MOVWF FSR1L
077D  3088     MOVLW 0x88
077E  0187     CLRF FSR1H
077F  0081     MOVWF INDF1
0780  0008     RETURN
0781  27D1     CALL 0x7D1
0782  3186     MOVLP 0x6
0783  27D7     CALL 0x7D7
0784  3186     MOVLP 0x6
2058:                  }
2059:              }
2060:              else
2061:              {
2062:          	    //We have received all OUT packets that we were expecting to
2063:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
2064:          		//the next SETUP transaction that may arrive.
2065:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
2066:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
2067:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
2068:                  //control transfers.  However, set BSTALL in case the host tries to send
2069:                  //more data than it claims it was going to send.
2070:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
0785  086F     MOVF pBDTEntryEP0OutNext, W
0786  0086     MOVWF FSR1L
0787  3084     MOVLW 0x84
0788  0081     MOVWF INDF1
2071:          
2072:          		//All data bytes for the host to device control write (OUT) have now been
2073:          		//received successfully.
2074:          		//Go ahead and call the user specified callback function, to use/consume
2075:          		//the control transfer data (ex: if the "void (*function)" parameter 
2076:          		//was non-NULL when USBEP0Receive() was called).
2077:                  if(outPipes[0].pFunc != NULL)
0789  0022     MOVLB 0x2
078A  0825     MOVF 0x25, W
078B  1903     BTFSC STATUS, 0x2
078C  2F90     GOTO 0x790
2078:                  {
2079:                      #if defined(__XC8)
2080:                          //Special pragmas to suppress an expected/harmless warning
2081:                          //message when building with the XC8 compiler
2082:                          #pragma warning push
2083:                          #pragma warning disable 1088
2084:                          outPipes[0].pFunc();    //Call the user's callback function
078D  0825     MOVF 0x25, W
078E  3187     MOVLP 0x7
078F  2F8F     GOTO 0x78F
2085:                          #pragma warning pop
2086:                      #else
2087:                          outPipes[0].pFunc();    //Call the user's callback function
2088:                      #endif
2089:                  }
2090:                  outPipes[0].info.bits.busy = 0;    
0790  13A2     BCF 0x22, 0x7
2091:          
2092:                  //Ready to arm status stage IN transaction now, if the application
2093:                  //firmware has completed processing the request.  If it is still busy
2094:                  //and needs more time to finish handling the request, then the user
2095:                  //callback (the one called by the outPipes[0].pFunc();) should set the
2096:                  //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2097:                  //this case, it is the application's firmware responsibility to call 
2098:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2099:                  //Note: The application firmware must process the request and call
2100:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2101:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
2102:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
2103:                  //more details.
2104:                  if(USBDeferStatusStagePacket == FALSE)
0791  0020     MOVLB 0x0
0792  08EC     MOVF USBDeferStatusStagePacket, F
0793  1D03     BTFSS STATUS, 0x2
0794  0008     RETURN
2105:                  {
2106:                      USBCtrlEPAllowStatusStage();
0795  2F96     GOTO 0x796
2107:                  }            
2108:              }    
2109:          
2110:          }//end USBCtrlTrfRxService
0796  0022     MOVLB 0x2
2111:          
2112:          
2113:          /********************************************************************
2114:           * Function:        void USBStdSetCfgHandler(void)
2115:           *
2116:           * PreCondition:    None
2117:           *
2118:           * Input:           None
2119:           *
2120:           * Output:          None
2121:           *
2122:           * Side Effects:    None
2123:           *
2124:           * Overview:        This routine first disables all endpoints by
2125:           *                  clearing UEP registers. It then configures
2126:           *                  (initializes) endpoints by calling the callback
2127:           *                  function USBCBInitEP().
2128:           *
2129:           * Note:            None
2130:           *******************************************************************/
2131:          static void USBStdSetCfgHandler(void)
2132:          {
2133:              BYTE i;
2134:          
2135:              // This will generate a zero length packet
2136:              inPipes[0].info.bits.busy = 1;            
04FC  0022     MOVLB 0x2
04FE  17CC     BSF 0x4C, 0x7
2137:          
2138:              //Clear all of the endpoint control registers
2139:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
04FD  300E     MOVLW 0xE
04FF  0020     MOVLB 0x0
0500  00E7     MOVWF n
0501  3099     MOVLW 0x99
0502  00E6     MOVWF work
0503  01E8     CLRF i_1089
0504  0866     MOVF work, W
0505  0086     MOVWF FSR1L
0506  0867     MOVF n, W
0507  0087     MOVWF FSR1H
0508  0181     CLRF INDF1
0509  0AE6     INCF work, F
050A  1903     BTFSC STATUS, 0x2
050B  0AE7     INCF n, F
050C  0AE8     INCF i_1089, F
050D  1903     BTFSC STATUS, 0x2
050E  2D04     GOTO 0x504
2140:          
2141:              //Clear all of the BDT entries
2142:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
050F  3020     MOVLW 0x20
0510  00D6     MOVWF dest
0511  01D7     CLRF product
0512  01D8     CLRF off
0513  01D9     CLRF x
0514  00DA     MOVWF i_718
0515  01DB     CLRF i
0516  2559     CALL 0x559
0517  3183     MOVLP 0x3
2143:          
2144:              // Assert reset request to all of the Ping Pong buffer pointers
2145:              USBPingPongBufferReset = 1;                                   
0518  003D     MOVLB 0x1D
0519  170E     BSF PORTC, 0x6
2146:          
2147:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
2148:          	//the EVEN buffer being the next one that will be used), since we are also 
2149:          	//doing a hardware ping pong pointer reset above.
2150:          	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
051A  0020     MOVLB 0x0
051B  01E9     CLRF i
0525  3002     MOVLW 0x2
0527  0AE9     INCF i, F
0528  0269     SUBWF i, W
0529  1C03     BTFSS STATUS, 0x0
052A  2D1C     GOTO 0x51C
2151:          	{
2152:          		ep_data_in[i].Val = 0u;
051C  0869     MOVF i, W
051D  3E26     ADDLW 0x26
051E  0086     MOVWF FSR1L
051F  3001     MOVLW 0x1
0520  0087     MOVWF FSR1H
0521  0181     CLRF INDF1
2153:                  ep_data_out[i].Val = 0u;
0522  0869     MOVF i, W
0523  3E28     ADDLW 0x28
0524  0086     MOVWF FSR1L
0526  0181     CLRF INDF1
2154:          	}
2155:          
2156:              //clear the alternate interface settings
2157:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
052B  3050     MOVLW 0x50
052C  00D6     MOVWF dest
052D  3001     MOVLW 0x1
052E  00D7     MOVWF product
052F  01D8     CLRF off
0530  01D9     CLRF x
0531  01DA     CLRF i_718
0532  0ADA     INCF i_718, F
0533  01DB     CLRF i
0534  2559     CALL 0x559
0535  3183     MOVLP 0x3
2158:          
2159:              //Stop trying to reset ping pong buffer pointers
2160:              USBPingPongBufferReset = 0;
0536  003D     MOVLB 0x1D
0537  130E     BCF PORTC, 0x6
2161:          
2162:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0538  3028     MOVLW 0x28
0539  0020     MOVLB 0x0
053A  00EA     MOVWF pBDTEntryIn
2163:          
2164:          	//Set the next out to the current out packet
2165:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
053B  3020     MOVLW 0x20
053C  00EE     MOVWF pBDTEntryEP0OutCurrent
2166:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
053D  00EF     MOVWF pBDTEntryEP0OutNext
2167:          
2168:              //set the current configuration
2169:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
053E  0842     MOVF 0x42, W
053F  0022     MOVLB 0x2
0540  00CF     MOVWF 0x4F
2170:          
2171:              //if the configuration value == 0
2172:              if(USBActiveConfiguration == 0)
0541  08CF     MOVF 0x4F, F
0542  1D03     BTFSS STATUS, 0x2
0543  2D48     GOTO 0x548
2173:              {
2174:                  //Go back to the addressed state
2175:                  USBDeviceState = ADDRESS_STATE;
0544  3010     MOVLW 0x10
0545  0021     MOVLB 0x1
0546  00EB     MOVWF 0x6B
2176:              }
0547  0008     RETURN
2177:              else
2178:              {
2179:                  //initialize the required endpoints
2180:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0548  0020     MOVLB 0x0
0549  304F     MOVLW 0x4F
054A  01E0     CLRF count
054B  0AE0     INCF count, F
054C  01E1     CLRF 0x61
054D  00E2     MOVWF 0x62
054E  3001     MOVLW 0x1
054F  00E3     MOVWF 0x63
0550  01E4     CLRF 0x64
0551  0AE4     INCF 0x64, F
0552  01E5     CLRF 0x65
0553  3182     MOVLP 0x2
0554  2288     CALL 0x288
2181:          
2182:                  //Otherwise go to the configured state.  Update the state variable last,
2183:                  //after performing all of the set configuration related initialization
2184:                  //tasks.
2185:                  USBDeviceState = CONFIGURED_STATE;		
0555  3020     MOVLW 0x20
0556  0021     MOVLB 0x1
0557  00EB     MOVWF 0x6B
2186:              }//end if(SetupPkt.bConfigurationValue == 0)
2187:          }//end USBStdSetCfgHandler
0558  0008     RETURN
2188:          
2189:          
2190:          /********************************************************************
2191:           * Function:        void USBStdGetDscHandler(void)
2192:           *
2193:           * PreCondition:    None
2194:           *
2195:           * Input:           None
2196:           *
2197:           * Output:          None
2198:           *
2199:           * Side Effects:    None
2200:           *
2201:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2202:           *                  request.
2203:           *
2204:           * Note:            None
2205:           *******************************************************************/
2206:          static void USBStdGetDscHandler(void)
2207:          {
2208:              if(SetupPkt.bmRequestType == 0x80)
04B8  0020     MOVLB 0x0
04B9  0840     MOVF SetupPkt, W
04BA  3A80     XORLW 0x80
04BB  1D03     BTFSS STATUS, 0x2
04BC  0008     RETURN
2209:              {
2210:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
04BD  30C0     MOVLW 0xC0
04BE  0022     MOVLB 0x2
04BF  00CC     MOVWF 0x4C
2211:          
2212:                  switch(SetupPkt.bDescriptorType)
04C0  2CEF     GOTO 0x4EF
04EF  0020     MOVLB 0x0
04F0  0843     MOVF 0x43, W
04F1  3A01     XORLW 0x1
04F2  1903     BTFSC STATUS, 0x2
04F3  2CC1     GOTO 0x4C1
04F4  3A03     XORLW 0x3
04F5  1903     BTFSC STATUS, 0x2
04F6  2CCA     GOTO 0x4CA
04F7  3A01     XORLW 0x1
04F8  1903     BTFSC STATUS, 0x2
04F9  2CDC     GOTO 0x4DC
04FA  2CEC     GOTO 0x4EC
2213:                  {
2214:                      case USB_DESCRIPTOR_DEVICE:
2215:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2216:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
2217:                          #else
2218:                              inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
04C1  309B     MOVLW 0x9B
04C2  0022     MOVLB 0x2
04C3  00CA     MOVWF 0x4A
04C4  3090     MOVLW 0x90
04C5  00CB     MOVWF 0x4B
2219:                          #endif
2220:                          inPipes[0].wCount.Val = sizeof(device_dsc);
04C6  3012     MOVLW 0x12
04C7  00CD     MOVWF 0x4D
04C8  01CE     CLRF 0x4E
2221:                          break;
04C9  0008     RETURN
2222:                      case USB_DESCRIPTOR_CONFIGURATION:
2223:                          #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2224:                              inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2225:                          #else
2226:                              inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
04CA  3012     MOVLW 0x12
04CB  0084     MOVWF FSR0L
04CC  3090     MOVLW 0x90
04CD  269D     CALL 0x69D
04CE  3183     MOVLP 0x3
2227:                          #endif
2228:          
2229:                          //This must be loaded using byte addressing.  The source pointer
2230:                          //  may not be word aligned for the 16 or 32 bit machines resulting
2231:                          //  in an address error on the dereference.
2232:                          inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
04CF  26B0     CALL 0x6B0
04D0  3183     MOVLP 0x3
04D1  3E02     ADDLW 0x2
04D2  26A8     CALL 0x6A8
04D3  3183     MOVLP 0x3
04D4  00CD     MOVWF 0x4D
2233:                          inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
04D5  084B     MOVF 0x4B, W
04D6  26B0     CALL 0x6B0
04D7  3183     MOVLP 0x3
04D8  3E03     ADDLW 0x3
04D9  26A8     CALL 0x6A8
04DA  00CE     MOVWF 0x4E
2234:                          break;
04DB  0008     RETURN
2235:                      case USB_DESCRIPTOR_STRING:
2236:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2237:                          //  later it is now manditory.  This should be defined in usb_config.h and should
2238:                          //  indicate the number of string descriptors.
2239:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
04DC  3003     MOVLW 0x3
04DD  0242     SUBWF 0x42, W
04DE  1803     BTFSC STATUS, 0x0
04DF  2CEC     GOTO 0x4EC
2240:                          {
2241:                              //Get a pointer to the String descriptor requested
2242:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
04E0  300F     MOVLW 0xF
04E1  0084     MOVWF FSR0L
04E2  3090     MOVLW 0x90
04E3  269D     CALL 0x69D
2243:                              // Set data count
2244:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
04E4  084A     MOVF 0x4A, W
04E5  0084     MOVWF FSR0L
04E6  084B     MOVF 0x4B, W
04E7  0085     MOVWF FSR0H
04E8  0800     MOVF INDF0, W
04E9  00CD     MOVWF 0x4D
04EA  01CE     CLRF 0x4E
2245:                          }
04EB  0008     RETURN
2246:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2247:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2248:                          {
2249:                              //Get a pointer to the special MS OS string descriptor requested
2250:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&MSOSDescriptor;
2251:                              // Set data count
2252:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2253:                          }    
2254:                          #endif
2255:                          else
2256:                          {
2257:                              inPipes[0].info.Val = 0;
04EC  0022     MOVLB 0x2
04ED  01CC     CLRF 0x4C
04EE  0008     RETURN
2258:                          }
2259:                          break;
2260:                      default:
2261:                          inPipes[0].info.Val = 0;
2262:                          break;
2263:                  }//end switch
2264:              }//end if
2265:          }//end USBStdGetDscHandler
04FB  0008     RETURN
2266:          
2267:          /********************************************************************
2268:           * Function:        void USBStdGetStatusHandler(void)
2269:           *
2270:           * PreCondition:    None
2271:           *
2272:           * Input:           None
2273:           *
2274:           * Output:          None
2275:           *
2276:           * Side Effects:    None
2277:           *
2278:           * Overview:        This routine handles the standard GET_STATUS request
2279:           *
2280:           * Note:            None
2281:           *******************************************************************/
2282:          static void USBStdGetStatusHandler(void)
2283:          {
2284:              CtrlTrfData[0] = 0;                 // Initialize content
0474  0020     MOVLB 0x0
0475  01C8     CLRF CtrlTrfData
2285:              CtrlTrfData[1] = 0;
0476  01C9     CLRF 0x49
2286:          
2287:              switch(SetupPkt.Recipient)
0477  2CA3     GOTO 0x4A3
04A3  0840     MOVF SetupPkt, W
04A4  391F     ANDLW 0x1F
04A5  1903     BTFSC STATUS, 0x2
04A6  2C78     GOTO 0x478
04A7  3A01     XORLW 0x1
04A8  1903     BTFSC STATUS, 0x2
04A9  2C82     GOTO 0x482
04AA  3A03     XORLW 0x3
04AB  1903     BTFSC STATUS, 0x2
04AC  2C85     GOTO 0x485
04AD  2CAE     GOTO 0x4AE
2288:              {
2289:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2290:                      inPipes[0].info.bits.busy = 1;
0478  0022     MOVLB 0x2
0479  17CC     BSF 0x4C, 0x7
2291:                      /*
2292:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2293:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2294:                       */
2295:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2296:                      {
2297:                          CtrlTrfData[0]|=0x01;
047A  0020     MOVLB 0x0
047B  1448     BSF CtrlTrfData, 0x0
2298:                      }
2299:          
2300:                      if(RemoteWakeup == TRUE)
047C  0022     MOVLB 0x2
047D  0B31     DECFSZ 0x31, W
047E  2CAE     GOTO 0x4AE
2301:                      {
2302:                          CtrlTrfData[0]|=0x02;
047F  0020     MOVLB 0x0
0480  14C8     BSF CtrlTrfData, 0x1
0481  2CAE     GOTO 0x4AE
2303:                      }
2304:                      break;
2305:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2306:                      inPipes[0].info.bits.busy = 1;     // No data to update
0482  0022     MOVLB 0x2
0483  17CC     BSF 0x4C, 0x7
2307:                      break;
0484  2CAE     GOTO 0x4AE
2308:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2309:                      inPipes[0].info.bits.busy = 1;
0485  0022     MOVLB 0x2
0486  17CC     BSF 0x4C, 0x7
2310:                      /*
2311:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2312:                       */
2313:                      {
2314:                          BDT_ENTRY *p;
2315:          
2316:                          if(SetupPkt.EPDir == 0)
0487  0020     MOVLB 0x0
0488  1BC4     BTFSC 0x44, 0x7
0489  2C91     GOTO 0x491
2317:                          {
2318:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
048A  0844     MOVF 0x44, W
048B  390F     ANDLW 0xF
048C  3E2C     ADDLW 0x2C
048D  0086     MOVWF FSR1L
048E  3001     MOVLW 0x1
048F  0087     MOVWF FSR1H
0490  2C96     GOTO 0x496
2319:                          }
2320:                          else
2321:                          {
2322:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0491  0844     MOVF 0x44, W
0492  390F     ANDLW 0xF
0493  3E6A     ADDLW 0x6A
0494  0086     MOVWF FSR1L
0495  0187     CLRF FSR1H
0496  0801     MOVF INDF1, W
0497  00D6     MOVWF dest
2323:                          }
2324:          
2325:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0498  0086     MOVWF FSR1L
0499  0187     CLRF FSR1H
049A  1F81     BTFSS INDF1, 0x7
049B  2CAE     GOTO 0x4AE
049C  0856     MOVF dest, W
049D  0086     MOVWF FSR1L
049E  1D01     BTFSS INDF1, 0x2
049F  2CAE     GOTO 0x4AE
2326:                              CtrlTrfData[0]=0x01;    // Set bit0
04A0  3001     MOVLW 0x1
04A1  00C8     MOVWF CtrlTrfData
04A2  2CAE     GOTO 0x4AE
2327:                          break;
2328:                      }
2329:              }//end switch
2330:          
2331:              if(inPipes[0].info.bits.busy == 1)
04AE  0022     MOVLB 0x2
04AF  1FCC     BTFSS 0x4C, 0x7
04B0  0008     RETURN
2332:              {
2333:                  inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
04B1  3048     MOVLW 0x48
04B2  00CA     MOVWF 0x4A
04B4  01CB     CLRF 0x4B
2334:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
04B5  144C     BSF 0x4C, 0x0
2335:                  inPipes[0].wCount.v[0] = 2;                         // Set data count
04B3  3002     MOVLW 0x2
04B6  00CD     MOVWF 0x4D
2336:              }//end if(...)
2337:          }//end USBStdGetStatusHandler
04B7  0008     RETURN
2338:          
2339:          /********************************************************************
2340:           * Function:        void USBStallHandler(void)
2341:           *
2342:           * PreCondition:    None
2343:           *
2344:           * Input:           None
2345:           *
2346:           * Output:          None
2347:           *
2348:           * Side Effects:    
2349:           *
2350:           * Overview:        This function handles the event of a STALL 
2351:           *                  occuring on the bus
2352:           *
2353:           * Note:            None
2354:           *******************************************************************/
2355:          static void __section("usb") USBStallHandler(void)
2356:          {
2357:              /*
2358:               * Does not really have to do anything here,
2359:               * even for the control endpoint.
2360:               * All BDs of Endpoint 0 are owned by SIE right now,
2361:               * but once a Setup Transaction is received, the ownership
2362:               * for EP0_OUT will be returned to CPU.
2363:               * When the Setup Transaction is serviced, the ownership
2364:               * for EP0_IN will then be forced back to CPU by firmware.
2365:               */
2366:          
2367:              /* v2b fix */
2368:              if(U1EP0bits.EPSTALL == 1)
1614  1C18     BTFSS T1CON, 0x0
1615  2E2A     GOTO 0x62A
2369:              {
2370:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2371:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
1616  0020     MOVLB 0x0
1617  086E     MOVF pBDTEntryEP0OutCurrent, W
1618  0086     MOVWF FSR1L
1619  0187     CLRF FSR1H
161A  0801     MOVF INDF1, W
161B  3A80     XORLW 0x80
161C  1D03     BTFSS STATUS, 0x2
161D  2E28     GOTO 0x628
161E  086A     MOVF pBDTEntryIn, W
161F  0086     MOVWF FSR1L
1620  0801     MOVF INDF1, W
1621  3A84     XORLW 0x84
1622  1D03     BTFSS STATUS, 0x2
1623  2E28     GOTO 0x628
2372:                  {
2373:                      // Set ep0Bo to stall also
2374:                      pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1624  086E     MOVF pBDTEntryEP0OutCurrent, W
1625  0086     MOVWF FSR1L
1626  308C     MOVLW 0x8C
1627  0081     MOVWF INDF1
2375:                  }//end if
2376:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
1628  003D     MOVLB 0x1D
1629  1018     BCF T1CON, 0x0
2377:              }//end if
2378:          
2379:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
162A  1290     BCF 0x10, 0x5
2380:          }
162B  0008     RETURN
2381:          
2382:          /********************************************************************
2383:           * Function:        void USBSuspend(void)
2384:           *
2385:           * PreCondition:    None
2386:           *
2387:           * Input:           None
2388:           *
2389:           * Output:          None
2390:           *
2391:           * Side Effects:    
2392:           *
2393:           * Overview:        This function handles if the host tries to 
2394:           *                  suspend the device
2395:           *
2396:           * Note:            None
2397:           *******************************************************************/
2398:          static void __section("usb") USBSuspend(void)
2399:          {
2400:              /*
2401:               * NOTE: Do not clear UIRbits.ACTVIF here!
2402:               * Reason:
2403:               * ACTVIF is only generated once an IDLEIF has been generated.
2404:               * This is a 1:1 ratio interrupt generation.
2405:               * For every IDLEIF, there will be only one ACTVIF regardless of
2406:               * the number of subsequent bus transitions.
2407:               *
2408:               * If the ACTIF is cleared here, a problem could occur when:
2409:               * [       IDLE       ][bus activity ->
2410:               * <--- 3 ms ----->     ^
2411:               *                ^     ACTVIF=1
2412:               *                IDLEIF=1
2413:               *  #           #           #           #   (#=Program polling flags)
2414:               *                          ^
2415:               *                          This polling loop will see both
2416:               *                          IDLEIF=1 and ACTVIF=1.
2417:               *                          However, the program services IDLEIF first
2418:               *                          because ACTIVIE=0.
2419:               *                          If this routine clears the only ACTIVIF,
2420:               *                          then it can never get out of the suspend
2421:               *                          mode.
2422:               */
2423:              USBActivityIE = 1;                     // Enable bus activity interrupt
1605  1512     BSF PIR2, 0x2
2424:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1606  1210     BCF 0x10, 0x4
2425:          
2426:              #if defined(__18CXX) || defined(_PIC14E)
2427:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
1607  148E     BSF PORTC, 0x1
2428:                                                          // mode, SIE clock inactive
2429:              #endif
2430:              USBBusIsSuspended = TRUE;
2431:           
2432:              /*
2433:               * At this point the PIC can go into sleep,idle, or
2434:               * switch to a slower clock, etc.  This should be done in the
2435:               * USBCBSuspend() if necessary.
2436:               */
2437:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
1608  3075     MOVLW 0x75
1609  0020     MOVLB 0x0
160A  00E0     MOVWF count
160B  3000     MOVLW 0x0
160C  01E1     CLRF 0x61
160D  01E2     CLRF 0x62
160E  01E3     CLRF 0x63
160F  01E4     CLRF 0x64
1610  01E5     CLRF 0x65
1611  3182     MOVLP 0x2
1612  2288     CALL 0x288
2438:          }
1613  0008     RETURN
2439:          
2440:          /********************************************************************
2441:           * Function:        void USBWakeFromSuspend(void)
2442:           *
2443:           * PreCondition:    None
2444:           *
2445:           * Input:           None
2446:           *
2447:           * Output:          None
2448:           *
2449:           * Side Effects:    None
2450:           *
2451:           * Overview:
2452:           *
2453:           * Note:            None
2454:           *******************************************************************/
2455:          static void __section("usb") USBWakeFromSuspend(void)
2456:          {
2457:              USBBusIsSuspended = FALSE;
2458:          
2459:              /*
2460:               * If using clock switching, the place to restore the original
2461:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2462:               */
2463:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
07EC  3074     MOVLW 0x74
07ED  0020     MOVLB 0x0
07EE  00E0     MOVWF count
07EF  3000     MOVLW 0x0
07F0  01E1     CLRF 0x61
07F1  01E2     CLRF 0x62
07F2  01E3     CLRF 0x63
07F3  01E4     CLRF 0x64
07F4  01E5     CLRF 0x65
07F5  3182     MOVLP 0x2
07F6  2288     CALL 0x288
2464:          
2465:              #if defined(__18CXX) || defined(_PIC14E)
2466:                  //To avoid improperly clocking the USB module, make sure the oscillator
2467:                  //settings are consistant with USB operation before clearing the SUSPND bit.
2468:                  //Make sure the correct oscillator settings are selected in the 
2469:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2470:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
07F7  003D     MOVLB 0x1D
07F8  108E     BCF PORTC, 0x1
2471:                                          // mode.
2472:              #endif
2473:          
2474:          
2475:              USBActivityIE = 0;
07F9  1112     BCF PIR2, 0x2
2476:          
2477:              /********************************************************************
2478:              Bug Fix: Feb 26, 2007 v2.1
2479:              *********************************************************************
2480:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2481:              up from Suspend or while the USB module is suspended. A few clock cycles
2482:              are required to synchronize the internal hardware state machine before
2483:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2484:              before the internal hardware is synchronized may not have an effect on
2485:              the value of ACTVIF. Additonally, if the USB module uses the clock from
2486:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2487:              module may not be immediately operational while waiting for the 96 MHz
2488:              PLL to lock.
2489:              ********************************************************************/
2490:          
2491:              // UIRbits.ACTVIF = 0;                      // Removed
2492:              #if defined(__18CXX)
2493:              while(USBActivityIF)
2494:              #endif
2495:              {
2496:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
07FA  1110     BCF 0x10, 0x2
2497:              }  // Added
2498:          
2499:          }//end USBWakeFromSuspend
07FB  0008     RETURN
2500:          
2501:          /********************************************************************
2502:           * Function:        void USBCtrlEPService(void)
2503:           *
2504:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2505:           *
2506:           * Input:           None
2507:           *
2508:           * Output:          None
2509:           *
2510:           * Side Effects:    None
2511:           *
2512:           * Overview:        USBCtrlEPService checks for three transaction
2513:           *                  types that it knows how to service and services
2514:           *                  them:
2515:           *                  1. EP0 SETUP
2516:           *                  2. EP0 OUT
2517:           *                  3. EP0 IN
2518:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2519:           *
2520:           * Note:            None
2521:           *******************************************************************/
2522:          static void __section("usb") USBCtrlEPService(void)
2523:          {
2524:              //If we get to here, that means a successful transaction has just occurred 
2525:              //on EP0.  This means "progress" has occurred in the currently pending 
2526:              //control transfer, so we should re-initialize our timeout counter.
2527:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2528:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
06B7  302D     MOVLW 0x2D
06B8  00BA     MOVWF 0x3A
2529:              #endif
2530:          	
2531:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2532:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
06B9  0021     MOVLB 0x1
06BA  086F     MOVF pBDTEntryEP0OutNext, W
06BB  39FD     ANDLW 0xFD
06BC  1D03     BTFSS STATUS, 0x2
06BD  2F06     GOTO 0x706
2533:              {
2534:          		//Point to the EP0 OUT buffer of the buffer that arrived
2535:                  #if defined (_PIC14E) || defined(__18CXX)
2536:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
06BE  366F     LSRF pBDTEntryEP0OutNext, W
06BF  393F     ANDLW 0x3F
06C0  0709     ADDWF WREG, W
06C1  0709     ADDWF WREG, W
06C2  3E20     ADDLW 0x20
06C3  0020     MOVLB 0x0
06C4  00EE     MOVWF pBDTEntryEP0OutCurrent
2537:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2538:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2539:                  #else
2540:                      #error "unimplemented"
2541:                  #endif
2542:          
2543:          		//Set the next out to the current out packet
2544:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
06C5  00EF     MOVWF pBDTEntryEP0OutNext
2545:          		//Toggle it to the next ping pong buffer (if applicable)
2546:                  ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
06C6  3004     MOVLW 0x4
06C7  06EF     XORWF pBDTEntryEP0OutNext, F
2547:          
2548:          		//If the current EP0 OUT buffer has a SETUP packet
2549:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
06C8  086E     MOVF pBDTEntryEP0OutCurrent, W
06C9  0086     MOVWF FSR1L
06CA  0187     CLRF FSR1H
06CB  0C01     RRF INDF1, W
06CC  0C89     RRF WREG, F
06CD  390F     ANDLW 0xF
06CE  3A0D     XORLW 0xD
06CF  1D03     BTFSS STATUS, 0x2
06D0  2F05     GOTO 0x705
2550:                  {
2551:                      unsigned char setup_cnt;
2552:          
2553:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2554:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2555:          	        //before the transaction.  Therefore, we should copy the data to the 
2556:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2557:                      for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
06D1  0021     MOVLB 0x1
06D2  01A6     CLRF 0x26
06F0  0021     MOVLB 0x1
06F1  3008     MOVLW 0x8
06F2  0AA6     INCF 0x26, F
06F3  0226     SUBWF 0x26, W
06F4  1C03     BTFSS STATUS, 0x0
06F5  2ED3     GOTO 0x6D3
2558:                      {
2559:                          *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
06D3  0826     MOVF 0x26, W
06D4  3E40     ADDLW 0x40
06D5  0086     MOVWF FSR1L
06D6  0187     CLRF FSR1H
06D7  0020     MOVLB 0x0
06D8  086E     MOVF pBDTEntryEP0OutCurrent, W
06D9  3E02     ADDLW 0x2
06DA  0084     MOVWF FSR0L
06DB  0185     CLRF FSR0H
06DC  3F00     MOVIW [0]FSR0
06DD  0021     MOVLB 0x1
06DE  00A4     MOVWF 0x24
06DF  3F01     MOVIW [1]FSR0
06E0  00A5     MOVWF 0x25
06E1  0824     MOVF 0x24, W
06E2  0084     MOVWF FSR0L
06E3  0825     MOVF 0x25, W
06E4  0085     MOVWF FSR0H
06E5  0800     MOVF INDF0, W
06E6  0081     MOVWF INDF1
2560:                          pBDTEntryEP0OutCurrent->ADR++;
06E7  0020     MOVLB 0x0
06E8  086E     MOVF pBDTEntryEP0OutCurrent, W
06E9  3E02     ADDLW 0x2
06EA  0086     MOVWF FSR1L
06EB  3001     MOVLW 0x1
06EC  0781     ADDWF INDF1, F
06ED  3141     ADDFSR 1, 1
06EE  1803     BTFSC STATUS, 0x0
06EF  0A81     INCF INDF1, F
2561:                      }    
2562:                      pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
06F6  3040     MOVLW 0x40
06F7  00A4     MOVWF 0x24
06F8  01A5     CLRF 0x25
06F9  0020     MOVLB 0x0
06FA  086E     MOVF pBDTEntryEP0OutCurrent, W
06FB  3E02     ADDLW 0x2
06FC  0086     MOVWF FSR1L
06FD  0187     CLRF FSR1H
06FE  0021     MOVLB 0x1
06FF  0824     MOVF 0x24, W
0700  3FC0     MOVWI [0]FSR1
0701  0825     MOVF 0x25, W
0702  3FC1     MOVWI [1]FSR1
2563:          
2564:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2565:                      USBCtrlTrfSetupHandler();
0703  3183     MOVLP 0x3
0704  2B16     GOTO 0x316
2566:                  }
2567:                  else
2568:                  {
2569:          			//Handle the DATA transfer
2570:                      USBCtrlTrfOutHandler();
0705  2F0E     GOTO 0x70E
2571:                  }
2572:              }
2573:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0706  30FD     MOVLW 0xFD
0707  056F     ANDWF pBDTEntryEP0OutNext, W
0708  00A4     MOVWF 0x24
0709  3A04     XORLW 0x4
070A  1D03     BTFSS STATUS, 0x2
070B  0008     RETURN
2574:              {
2575:          		//Otherwise the transmission was and EP0 IN
2576:          		//  so take care of the IN transfer
2577:                  USBCtrlTrfInHandler();
070C  3185     MOVLP 0x5
070D  2D72     GOTO 0x572
2578:              }
2579:          
2580:          }//end USBCtrlEPService
070E  086D     MOVF controlTransferState, W
2581:          
2582:          /********************************************************************
2583:           * Function:        void USBCtrlTrfSetupHandler(void)
2584:           *
2585:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2586:           *
2587:           * Input:           None
2588:           *
2589:           * Output:          None
2590:           *
2591:           * Side Effects:    None
2592:           *
2593:           * Overview:        This routine is a task dispatcher and has 3 stages.
2594:           *                  1. It initializes the control transfer state machine.
2595:           *                  2. It calls on each of the module that may know how to
2596:           *                     service the Setup Request from the host.
2597:           *                     Module Example: USBD, HID, CDC, MSD, ...
2598:           *                     A callback function, USBCBCheckOtherReq(),
2599:           *                     is required to call other module handlers.
2600:           *                  3. Once each of the modules has had a chance to check if
2601:           *                     it is responsible for servicing the request, stage 3
2602:           *                     then checks direction of the transfer to determine how
2603:           *                     to prepare EP0 for the control transfer.
2604:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2605:           *
2606:           * Note:            Microchip USB Firmware has three different states for
2607:           *                  the control transfer state machine:
2608:           *                  1. WAIT_SETUP
2609:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2610:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2611:           *                  Refer to firmware manual to find out how one state
2612:           *                  is transitioned to another.
2613:           *
2614:           *                  A Control Transfer is composed of many USB transactions.
2615:           *                  When transferring data over multiple transactions,
2616:           *                  it is important to keep track of data source, data
2617:           *                  destination, and data count. These three parameters are
2618:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2619:           *                  note if the data source is from ROM or RAM.
2620:           *
2621:           *******************************************************************/
2622:          static void USBCtrlTrfSetupHandler(void)
2623:          {
2624:              //--------------------------------------------------------------------------
2625:              //1. Re-initialize state tracking variables related to control transfers.
2626:              //--------------------------------------------------------------------------
2627:              shortPacketStatus = SHORT_PKT_NOT_USED;  
0316  0022     MOVLB 0x2
0317  01C1     CLRF 0x41
2628:              USBDeferStatusStagePacket = FALSE;
0318  0020     MOVLB 0x0
0319  01EC     CLRF USBDeferStatusStagePacket
2629:              USBDeferINDataStagePackets = FALSE;
031A  0022     MOVLB 0x2
031B  01B5     CLRF 0x35
2630:              USBDeferOUTDataStagePackets = FALSE;
031C  01B6     CLRF 0x36
2631:              BothEP0OutUOWNsSet = FALSE;    
031D  01B0     CLRF 0x30
2632:              controlTransferState = WAIT_SETUP;
031E  0020     MOVLB 0x0
031F  01ED     CLRF controlTransferState
2633:          
2634:              //Abandon any previous control transfers that might have been using EP0.
2635:              //Ordinarily, nothing actually needs abandoning, since the previous control
2636:              //transfer would have completed successfully prior to the host sending the next
2637:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2638:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2639:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2640:              //by the class request handler that will be called next.
2641:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
0320  086A     MOVF pBDTEntryIn, W
0321  0086     MOVWF FSR1L
0323  0187     CLRF FSR1H
0324  1381     BCF INDF1, 0x7
2642:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0322  3004     MOVLW 0x4
0325  06EA     XORWF pBDTEntryIn, F
2643:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
0326  086A     MOVF pBDTEntryIn, W
0327  0086     MOVWF FSR1L
0329  1381     BCF INDF1, 0x7
2644:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0328  3004     MOVLW 0x4
032A  06EA     XORWF pBDTEntryIn, F
2645:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
032B  086F     MOVF pBDTEntryEP0OutNext, W
032C  0086     MOVWF FSR1L
032D  1381     BCF INDF1, 0x7
2646:          
2647:              inPipes[0].info.Val = 0;
032E  0022     MOVLB 0x2
032F  01CC     CLRF 0x4C
2648:              inPipes[0].wCount.Val = 0;
0330  01CD     CLRF 0x4D
0331  01CE     CLRF 0x4E
2649:              outPipes[0].info.Val = 0;
0332  01A2     CLRF 0x22
2650:              outPipes[0].wCount.Val = 0;
0333  01A3     CLRF 0x23
0334  01A4     CLRF 0x24
2651:              
2652:          
2653:              //--------------------------------------------------------------------------
2654:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2655:              //--------------------------------------------------------------------------
2656:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0335  2343     CALL 0x343
2657:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
0336  3003     MOVLW 0x3
0337  0020     MOVLB 0x0
0338  00E0     MOVWF count
0339  3000     MOVLW 0x0
033A  01E1     CLRF 0x61
033B  01E2     CLRF 0x62
033C  01E3     CLRF 0x63
033D  01E4     CLRF 0x64
033E  01E5     CLRF 0x65
033F  3182     MOVLP 0x2
0340  2288     CALL 0x288
0341  3183     MOVLP 0x3
2658:          
2659:          
2660:              //--------------------------------------------------------------------------
2661:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2662:              //   progress.  If one of the above handlers (in step 2) knew how to process
2663:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2664:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2665:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2666:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2667:              //   process the request.  In this case, the default behavior will be to
2668:              //   perform protocol STALL on EP0.
2669:              //-------------------------------------------------------------------------- 
2670:              USBCtrlEPServiceComplete();
0342  2DC6     GOTO 0x5C6
2671:          }//end USBCtrlTrfSetupHandler
0343  0020     MOVLB 0x0
2672:          
2673:          
2674:          /******************************************************************************
2675:           * Function:        void USBCtrlTrfOutHandler(void)
2676:           *
2677:           * PreCondition:    None
2678:           *
2679:           * Input:           None
2680:           *
2681:           * Output:          None
2682:           *
2683:           * Side Effects:    None
2684:           *
2685:           * Overview:        This routine handles an OUT transaction according to
2686:           *                  which control transfer state is currently active.
2687:           *
2688:           * Note:            Note that if the the control transfer was from
2689:           *                  host to device, the session owner should be notified
2690:           *                  at the end of each OUT transaction to service the
2691:           *                  received data.
2692:           *
2693:           *****************************************************************************/
2694:          static void USBCtrlTrfOutHandler(void)
2695:          {
2696:              if(controlTransferState == CTRL_TRF_RX)
070E  086D     MOVF controlTransferState, W
070F  3A02     XORLW 0x2
0710  1D03     BTFSS STATUS, 0x2
0711  2F13     GOTO 0x713
2697:              {
2698:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0712  2F2B     GOTO 0x72B
2699:              }
2700:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2701:              {
2702:                  //If the status stage is complete, this means we are done with the 
2703:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2704:                  controlTransferState = WAIT_SETUP;
0713  01ED     CLRF controlTransferState
2705:          
2706:          	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2707:          	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2708:          	    //and the last control transfer was of direction: device to host, see
2709:          	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2710:          	    //to do anything to the BDT.
2711:          		if(BothEP0OutUOWNsSet == FALSE)
0714  0022     MOVLB 0x2
0715  08B0     MOVF 0x30, F
0716  1D03     BTFSS STATUS, 0x2
0717  2F29     GOTO 0x729
2712:          		{
2713:          	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0718  0020     MOVLB 0x0
0719  27D1     CALL 0x7D1
071A  3186     MOVLP 0x6
2714:          	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
071B  00DC     MOVWF work
071C  01DD     CLRF y
071D  086F     MOVF pBDTEntryEP0OutNext, W
071E  3E02     ADDLW 0x2
071F  0086     MOVWF FSR1L
0720  085C     MOVF work, W
0721  3FC0     MOVWI [0]FSR1
0722  085D     MOVF y, W
0723  3FC1     MOVWI [1]FSR1
2715:          	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;			
0724  086F     MOVF pBDTEntryEP0OutNext, W
0725  0086     MOVWF FSR1L
0726  308C     MOVLW 0x8C
0727  0081     MOVWF INDF1
2716:          		}
0728  0008     RETURN
2717:          		else
2718:          		{
2719:          			BothEP0OutUOWNsSet = FALSE;
0729  01B0     CLRF 0x30
2720:          		}
2721:              }
2722:          }
072A  0008     RETURN
2723:          
2724:          /******************************************************************************
2725:           * Function:        void USBCtrlTrfInHandler(void)
2726:           *
2727:           * PreCondition:    None
2728:           *
2729:           * Input:           None
2730:           *
2731:           * Output:          None
2732:           *
2733:           * Side Effects:    None
2734:           *
2735:           * Overview:        This routine handles an IN transaction according to
2736:           *                  which control transfer state is currently active.
2737:           *
2738:           * Note:            A Set Address Request must not change the acutal address
2739:           *                  of the device until the completion of the control
2740:           *                  transfer. The end of the control transfer for Set Address
2741:           *                  Request is an IN transaction. Therefore it is necessary
2742:           *                  to service this unique situation when the condition is
2743:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2744:           *                  usb9.h and its function is to specifically service this
2745:           *                  event.
2746:           *****************************************************************************/
2747:          static void USBCtrlTrfInHandler(void)
2748:          {
2749:              BYTE lastDTS;
2750:          
2751:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0572  0020     MOVLB 0x0
0573  086A     MOVF pBDTEntryIn, W
0574  0086     MOVWF FSR1L
0575  3000     MOVLW 0x0
0576  0187     CLRF FSR1H
0577  1B01     BTFSC INDF1, 0x6
0578  3001     MOVLW 0x1
0579  00DB     MOVWF i
2752:          
2753:              //switch to the next ping pong buffer
2754:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
057A  3004     MOVLW 0x4
057B  06EA     XORWF pBDTEntryIn, F
2755:          
2756:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2757:              //now, since the IN status stage of the (set address) control transfer has 
2758:              //evidently completed successfully.
2759:              if(USBDeviceState == ADR_PENDING_STATE)
057C  0021     MOVLB 0x1
057D  086B     MOVF 0x6B, W
057E  3A08     XORLW 0x8
057F  1D03     BTFSS STATUS, 0x2
0580  2D8D     GOTO 0x58D
2760:              {
2761:                  U1ADDR = SetupPkt.bDevADR.Val;
0581  0020     MOVLB 0x0
0582  0842     MOVF 0x42, W
0583  003D     MOVLB 0x1D
0584  0096     MOVWF TMR1L
2762:                  if(U1ADDR != 0u)
0585  0816     MOVF TMR1L, W
0586  1903     BTFSC STATUS, 0x2
0587  2D8A     GOTO 0x58A
2763:                  {
2764:                      USBDeviceState=ADDRESS_STATE;
0588  3010     MOVLW 0x10
0589  2D8B     GOTO 0x58B
2765:                  }
2766:                  else
2767:                  {
2768:                      USBDeviceState=DEFAULT_STATE;
058A  3004     MOVLW 0x4
058B  0021     MOVLB 0x1
058C  00EB     MOVWF 0x6B
2769:                  }
2770:              }//end if
2771:          
2772:          
2773:              if(controlTransferState == CTRL_TRF_TX)
058D  0020     MOVLB 0x0
058E  0B6D     DECFSZ controlTransferState, W
058F  2DB9     GOTO 0x5B9
2774:              {
2775:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0590  3048     MOVLW 0x48
0591  00D9     MOVWF x
0592  01DA     CLRF i_718
0593  086A     MOVF pBDTEntryIn, W
0594  3E02     ADDLW 0x2
0595  0086     MOVWF FSR1L
0596  0187     CLRF FSR1H
0597  0859     MOVF x, W
0598  3FC0     MOVWI [0]FSR1
0599  085A     MOVF i_718, W
059A  3FC1     MOVWI [1]FSR1
2776:                  USBCtrlTrfTxService();
059B  263D     CALL 0x63D
059C  3183     MOVLP 0x3
2777:          
2778:                  //Check if we have already sent a short packet.  If so, configure
2779:                  //the endpoint to STALL in response to any further IN tokens (in the
2780:                  //case that the host erroneously tries to receive more data than it
2781:                  //should).
2782:                  if(shortPacketStatus == SHORT_PKT_SENT)
059D  0022     MOVLB 0x2
059E  0841     MOVF 0x41, W
059F  3A02     XORLW 0x2
05A0  1D03     BTFSS STATUS, 0x2
05A1  2DA9     GOTO 0x5A9
2783:                  {
2784:                      // If a short packet has been sent, don't want to send any more,
2785:                      // stall next time if host is still trying to read.
2786:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
05A2  0020     MOVLB 0x0
05A3  086A     MOVF pBDTEntryIn, W
05A4  0086     MOVWF FSR1L
05A5  3084     MOVLW 0x84
05A6  0187     CLRF FSR1H
05A7  0081     MOVWF INDF1
2787:                  }
05A8  0008     RETURN
2788:                  else
2789:                  {
2790:                      if(lastDTS == 0)
05A9  0020     MOVLB 0x0
05AA  08DB     MOVF i, F
05AB  1D03     BTFSS STATUS, 0x2
05AC  2DB3     GOTO 0x5B3
2791:                      {
2792:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
05AD  086A     MOVF pBDTEntryIn, W
05AE  0086     MOVWF FSR1L
05AF  30C8     MOVLW 0xC8
05B0  0187     CLRF FSR1H
05B1  0081     MOVWF INDF1
2793:                      }
05B2  0008     RETURN
2794:                      else
2795:                      {
2796:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
05B3  086A     MOVF pBDTEntryIn, W
05B4  0086     MOVWF FSR1L
05B5  3088     MOVLW 0x88
05B6  0187     CLRF FSR1H
05B7  0081     MOVWF INDF1
05B8  0008     RETURN
2797:                      }
2798:                  }//end if(...)else
2799:              }
2800:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2801:          	{
2802:                  //if someone is still expecting data from the control transfer
2803:                  //  then make sure to terminate that request and let them know that
2804:                  //  they are done
2805:                  if(outPipes[0].info.bits.busy == 1)
05B9  0022     MOVLB 0x2
05BA  1FA2     BTFSS 0x22, 0x7
05BB  2DC3     GOTO 0x5C3
2806:                  {
2807:                      if(outPipes[0].pFunc != NULL)
05BC  0825     MOVF 0x25, W
05BD  1903     BTFSC STATUS, 0x2
05BE  2DC2     GOTO 0x5C2
2808:                      {
2809:                          outPipes[0].pFunc();
05BF  0825     MOVF 0x25, W
05C0  3185     MOVLP 0x5
05C1  2DC1     GOTO 0x5C1
2810:                      }
2811:                      outPipes[0].info.bits.busy = 0;
05C2  13A2     BCF 0x22, 0x7
2812:                  }
2813:              	
2814:                  controlTransferState = WAIT_SETUP;
05C3  0020     MOVLB 0x0
05C4  01ED     CLRF controlTransferState
2815:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2816:                  //got processed by the USBCtrlTrfRxService() handler.
2817:          	}	
2818:          
2819:          }
05C5  0008     RETURN
2820:          
2821:          
2822:          /********************************************************************
2823:           * Function:        void USBCheckStdRequest(void)
2824:           *
2825:           * PreCondition:    None
2826:           *
2827:           * Input:           None
2828:           *
2829:           * Output:          None
2830:           *
2831:           * Side Effects:    None
2832:           *
2833:           * Overview:        This routine checks the setup data packet to see
2834:           *                  if it knows how to handle it
2835:           *
2836:           * Note:            None
2837:           *******************************************************************/
2838:          static void USBCheckStdRequest(void)
2839:          {
2840:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0343  0020     MOVLB 0x0
0344  0E40     SWAPF SetupPkt, W
0345  0C89     RRF WREG, F
0346  3903     ANDLW 0x3
0347  1D03     BTFSS STATUS, 0x2
0348  0008     RETURN
0349  2B77     GOTO 0x377
2841:          
2842:              switch(SetupPkt.bRequest)
0377  0841     MOVF 0x41, W
0378  0084     MOVWF FSR0L
0379  300D     MOVLW 0xD
037A  0204     SUBWF FSR0L, W
037B  1803     BTFSC STATUS, 0x0
037C  0008     RETURN
037D  3190     MOVLP 0x10
037E  3504     LSLF FSR0L, W
037F  3EBD     ADDLW 0xBD
0380  0082     MOVWF PCL
10BD  3183     MOVLP 0x3
2843:              {
2844:                  case USB_REQUEST_SET_ADDRESS:
2845:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
034A  0022     MOVLB 0x2
034C  17CC     BSF 0x4C, 0x7
2846:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
034B  3008     MOVLW 0x8
034D  0021     MOVLB 0x1
034E  00EB     MOVWF 0x6B
2847:                      /* See USBCtrlTrfInHandler() for the next step */
2848:                      break;
034F  0008     RETURN
2849:                  case USB_REQUEST_GET_DESCRIPTOR:
2850:                      USBStdGetDscHandler();
0350  2CB8     GOTO 0x4B8
2851:                      break;
2852:                  case USB_REQUEST_SET_CONFIGURATION:
2853:                      USBStdSetCfgHandler();
0351  2CFC     GOTO 0x4FC
2854:                      break;
2855:                  case USB_REQUEST_GET_CONFIGURATION:
2856:                      inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
0352  304F     MOVLW 0x4F
0353  0022     MOVLB 0x2
0354  00CA     MOVWF 0x4A
0355  3001     MOVLW 0x1
0356  00CB     MOVWF 0x4B
2857:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0357  144C     BSF 0x4C, 0x0
2858:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0358  01CD     CLRF 0x4D
0359  0ACD     INCF 0x4D, F
2859:                      inPipes[0].info.bits.busy = 1;
035A  17CC     BSF 0x4C, 0x7
2860:                      break;
035B  0008     RETURN
2861:                  case USB_REQUEST_GET_STATUS:
2862:                      USBStdGetStatusHandler();
035C  2C74     GOTO 0x474
2863:                      break;
2864:                  case USB_REQUEST_CLEAR_FEATURE:
2865:                  case USB_REQUEST_SET_FEATURE:
2866:                      USBStdFeatureReqHandler();
035D  2B82     GOTO 0x382
2867:                      break;
2868:                  case USB_REQUEST_GET_INTERFACE:
2869:                      inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
035E  0844     MOVF 0x44, W
035F  3E50     ADDLW 0x50
0360  2B53     GOTO 0x353
2870:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2871:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2872:                      inPipes[0].info.bits.busy = 1;
2873:                      break;
2874:                  case USB_REQUEST_SET_INTERFACE:
2875:                      inPipes[0].info.bits.busy = 1;
0361  0022     MOVLB 0x2
0362  17CC     BSF 0x4C, 0x7
2876:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0363  0020     MOVLB 0x0
0364  0844     MOVF 0x44, W
0365  3E50     ADDLW 0x50
0366  0086     MOVWF FSR1L
0367  3001     MOVLW 0x1
0368  0087     MOVWF FSR1H
0369  0842     MOVF 0x42, W
036A  0081     MOVWF INDF1
2877:                      break;
036B  0008     RETURN
2878:                  case USB_REQUEST_SET_DESCRIPTOR:
2879:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
036C  3002     MOVLW 0x2
036D  00E0     MOVWF count
036E  3000     MOVLW 0x0
036F  01E1     CLRF 0x61
0370  01E2     CLRF 0x62
0371  01E3     CLRF 0x63
0372  01E4     CLRF 0x64
0373  01E5     CLRF 0x65
0374  3182     MOVLP 0x2
0375  2288     CALL 0x288
2880:                      break;
0376  0008     RETURN
2881:                  case USB_REQUEST_SYNCH_FRAME:
2882:                  default:
2883:                      break;
2884:              }//end switch
2885:          }//end USBCheckStdRequest
0381  0008     RETURN
2886:          
2887:          /********************************************************************
2888:           * Function:        void USBStdFeatureReqHandler(void)
2889:           *
2890:           * PreCondition:    None
2891:           *
2892:           * Input:           None
2893:           *
2894:           * Output:          Can alter BDT entries.  Can also modify USB stack
2895:           *                  Maintained variables.
2896:           *
2897:           * Side Effects:    None
2898:           *
2899:           * Overview:        This routine handles the standard SET & CLEAR
2900:           *                  FEATURES requests
2901:           *
2902:           * Note:            This is a private function, intended for internal 
2903:           *                  use by the USB stack, when processing SET/CLEAR
2904:           *                  feature requests.  
2905:           *******************************************************************/
2906:          static void USBStdFeatureReqHandler(void)
2907:          {
2908:              BDT_ENTRY *p;
2909:              EP_STATUS current_ep_data;
2910:              #if defined(__C32__)
2911:                  DWORD* pUEP;
2912:              #else
2913:                  unsigned char* pUEP;             
2914:              #endif
2915:              
2916:          
2917:              #ifdef	USB_SUPPORT_OTG
2918:              //Check for USB On-The-Go (OTG) specific requests
2919:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2920:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2921:              {  
2922:                  inPipes[0].info.bits.busy = 1;
2923:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2924:                      USBOTGEnableHnp();
2925:                  else
2926:                      USBOTGDisableHnp();
2927:              }
2928:          
2929:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2930:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2931:              {
2932:                  inPipes[0].info.bits.busy = 1;
2933:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2934:                      USBOTGEnableSupportHnp();
2935:                  else
2936:                      USBOTGDisableSupportHnp();
2937:              }
2938:          
2939:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2940:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2941:              {
2942:                  inPipes[0].info.bits.busy = 1;
2943:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2944:                      USBOTGEnableAltHnp();
2945:                  else
2946:                      USBOTGDisableAltHnp();
2947:              }
2948:              #endif   //#ifdef USB_SUPPORT_OTG 
2949:          
2950:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2951:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2952:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
0382  0020     MOVLB 0x0
0383  0B42     DECFSZ 0x42, W
0384  2B96     GOTO 0x396
0385  0840     MOVF SetupPkt, W
0386  391F     ANDLW 0x1F
0387  1D03     BTFSS STATUS, 0x2
0388  2B96     GOTO 0x396
2953:              {
2954:                  inPipes[0].info.bits.busy = 1;
0389  0022     MOVLB 0x2
038A  17CC     BSF 0x4C, 0x7
2955:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
038B  0020     MOVLB 0x0
038C  0841     MOVF 0x41, W
038D  3A03     XORLW 0x3
038E  1D03     BTFSS STATUS, 0x2
038F  2B94     GOTO 0x394
2956:                      RemoteWakeup = TRUE;
0390  0022     MOVLB 0x2
0391  01B1     CLRF 0x31
0392  0AB1     INCF 0x31, F
0393  2B96     GOTO 0x396
2957:                  else
2958:                      RemoteWakeup = FALSE;
0394  0022     MOVLB 0x2
0395  01B1     CLRF 0x31
2959:              }//end if
2960:          
2961:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2962:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2963:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2964:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2965:                 (USBDeviceState == CONFIGURED_STATE))
0396  0020     MOVLB 0x0
0397  0842     MOVF 0x42, W
0398  1D03     BTFSS STATUS, 0x2
0399  0008     RETURN
039A  0840     MOVF SetupPkt, W
039B  391F     ANDLW 0x1F
039C  3A02     XORLW 0x2
039D  1D03     BTFSS STATUS, 0x2
039E  0008     RETURN
039F  0844     MOVF 0x44, W
03A0  390F     ANDLW 0xF
03A1  1903     BTFSC STATUS, 0x2
03A2  0008     RETURN
03A3  0844     MOVF 0x44, W
03A4  390F     ANDLW 0xF
03A5  00E6     MOVWF work
03A6  3002     MOVLW 0x2
03A7  0266     SUBWF work, W
03A8  1803     BTFSC STATUS, 0x0
03A9  0008     RETURN
03AA  0021     MOVLB 0x1
03AB  086B     MOVF 0x6B, W
03AC  3A20     XORLW 0x20
03AD  1D03     BTFSS STATUS, 0x2
03AE  0008     RETURN
2966:              {
2967:          		//The request was valid.  Take control of the control transfer and
2968:          		//perform the host requested action.
2969:          		inPipes[0].info.bits.busy = 1;
03AF  0022     MOVLB 0x2
03B0  17CC     BSF 0x4C, 0x7
2970:          
2971:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2972:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
03B1  0020     MOVLB 0x0
03B2  1BC4     BTFSC 0x44, 0x7
03B3  2BC3     GOTO 0x3C3
2973:                  {
2974:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
03B4  0844     MOVF 0x44, W
03B5  390F     ANDLW 0xF
03B6  3E2C     ADDLW 0x2C
03B7  0086     MOVWF FSR1L
03B8  3001     MOVLW 0x1
03B9  0087     MOVWF FSR1H
03BA  0801     MOVF INDF1, W
03BB  0021     MOVLB 0x1
03BC  00A3     MOVWF 0x23
2975:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
03BD  0020     MOVLB 0x0
03BE  0844     MOVF 0x44, W
03BF  390F     ANDLW 0xF
03C0  3E28     ADDLW 0x28
03C1  0086     MOVWF FSR1L
03C2  2BD2     GOTO 0x3D2
2976:                  }
2977:                  else
2978:                  {
2979:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
03C3  0844     MOVF 0x44, W
03C4  390F     ANDLW 0xF
03C5  3E6A     ADDLW 0x6A
03C6  0086     MOVWF FSR1L
03C7  0187     CLRF FSR1H
03C8  0801     MOVF INDF1, W
03C9  0021     MOVLB 0x1
03CA  00A3     MOVWF 0x23
2980:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
03CB  0020     MOVLB 0x0
03CC  0844     MOVF 0x44, W
03CD  390F     ANDLW 0xF
03CE  3E26     ADDLW 0x26
03CF  0086     MOVWF FSR1L
03D0  3001     MOVLW 0x1
03D1  0087     MOVWF FSR1H
03D2  0801     MOVF INDF1, W
03D3  0021     MOVLB 0x1
03D4  00A2     MOVWF 0x22
2981:                  }
2982:          
2983:                  //If ping pong buffering is enabled on the requested endpoint, need 
2984:                  //to point to the one that is the active BDT entry which the SIE will 
2985:                  //use for the next attempted transaction on that EP number.
2986:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2987:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
03D5  1822     BTFSC 0x22, 0x0
03D6  2BD9     GOTO 0x3D9
2988:                      {
2989:                          USBHALPingPongSetToEven(&p);
03D7  1123     BCF 0x23, 0x2
2990:                      }
03D8  2BDA     GOTO 0x3DA
2991:                      else //else must have been odd
2992:                      {
2993:                          USBHALPingPongSetToOdd(&p);
03D9  1523     BSF 0x23, 0x2
2994:                      }
2995:                  #endif
2996:                  
2997:                  //Update the BDT pointers with the new, next entry based on the feature
2998:                  //  request
2999:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
03DA  0020     MOVLB 0x0
03DB  1BC4     BTFSC 0x44, 0x7
03DC  2BE4     GOTO 0x3E4
3000:                  {
3001:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
03DD  0844     MOVF 0x44, W
03DE  390F     ANDLW 0xF
03DF  3E2C     ADDLW 0x2C
03E0  0086     MOVWF FSR1L
03E1  3001     MOVLW 0x1
03E2  0087     MOVWF FSR1H
03E3  2BE9     GOTO 0x3E9
3002:                  }
3003:                  else
3004:                  {
3005:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
03E4  0844     MOVF 0x44, W
03E5  390F     ANDLW 0xF
03E6  3E6A     ADDLW 0x6A
03E7  0086     MOVWF FSR1L
03E8  0187     CLRF FSR1H
03E9  0021     MOVLB 0x1
03EA  0823     MOVF 0x23, W
03EB  0081     MOVWF INDF1
3006:                  }
3007:          
3008:          		//Check if it was a SET_FEATURE endpoint halt request
3009:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
03EC  0020     MOVLB 0x0
03ED  0841     MOVF 0x41, W
03EE  3A03     XORLW 0x3
03EF  1D03     BTFSS STATUS, 0x2
03F0  2C0C     GOTO 0x40C
3010:                  {
3011:                      if(p->STAT.UOWN == 1)
03F1  0021     MOVLB 0x1
03F2  0823     MOVF 0x23, W
03F3  0086     MOVWF FSR1L
03F4  0187     CLRF FSR1H
03F5  1F81     BTFSS INDF1, 0x7
03F6  2C05     GOTO 0x405
3012:                      {
3013:                          //Mark that we are terminating this transfer and that the user
3014:                          //  needs to be notified later
3015:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
03F7  0020     MOVLB 0x0
03F8  1BC4     BTFSC 0x44, 0x7
03F9  2BFE     GOTO 0x3FE
3016:                          {
3017:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
03FA  0844     MOVF 0x44, W
03FB  390F     ANDLW 0xF
03FC  3E28     ADDLW 0x28
03FD  2C01     GOTO 0x401
3018:                          }
3019:                          else
3020:                          {
3021:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
03FE  0844     MOVF 0x44, W
03FF  390F     ANDLW 0xF
0400  3E26     ADDLW 0x26
0401  0086     MOVWF FSR1L
0402  3001     MOVLW 0x1
0403  0087     MOVWF FSR1H
0404  1481     BSF INDF1, 0x1
3022:                          }
3023:                      }
3024:          
3025:          			//Then STALL the endpoint
3026:                      p->STAT.Val |= _USIE|_BSTALL;
0405  0021     MOVLB 0x1
0406  0823     MOVF 0x23, W
0407  0086     MOVWF FSR1L
0408  3084     MOVLW 0x84
0409  0187     CLRF FSR1H
040A  0481     IORWF INDF1, F
3027:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
040B  0008     RETURN
3028:                  else
3029:                  {
3030:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
3031:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3032:                          //toggle over the to the non-active BDT
3033:                          USBAdvancePingPongBuffer(&p);  
040C  3004     MOVLW 0x4
040D  0021     MOVLB 0x1
040E  06A3     XORWF 0x23, F
3034:          
3035:                          if(p->STAT.UOWN == 1)
040F  0823     MOVF 0x23, W
0410  0086     MOVWF FSR1L
0411  0187     CLRF FSR1H
0413  1F81     BTFSS INDF1, 0x7
0414  2C29     GOTO 0x429
3036:                          {
3037:                              //Clear UOWN and set DTS state so it will be correct the next time
3038:                              //the application firmware uses USBTransferOnePacket() on the EP.
3039:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
0412  0823     MOVF 0x23, W
0415  0086     MOVWF FSR1L
0416  1381     BCF INDF1, 0x7
3040:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0417  0086     MOVWF FSR1L
0419  1701     BSF INDF1, 0x6
3041:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0418  3005     MOVLW 0x5
041A  0020     MOVLB 0x0
041B  00E0     MOVWF count
041C  01E1     CLRF 0x61
041D  0021     MOVLB 0x1
041E  0823     MOVF 0x23, W
041F  0020     MOVLB 0x0
0420  00E2     MOVWF 0x62
0421  01E3     CLRF 0x63
0422  01E4     CLRF 0x64
0423  0AE4     INCF 0x64, F
0424  01E5     CLRF 0x65
0425  3182     MOVLP 0x2
0426  2288     CALL 0x288
0427  3183     MOVLP 0x3
3042:                          }
0428  2C2C     GOTO 0x42C
3043:                          else
3044:                          {
3045:                              //UOWN already clear, but still need to set DTS to DATA1     
3046:          					p->STAT.Val |= _DAT1;
0429  0086     MOVWF FSR1L
042A  0187     CLRF FSR1H
042B  1701     BSF INDF1, 0x6
3047:                          }
3048:          
3049:                          //toggle back to the active BDT (the one the SIE is currently looking at
3050:                          //and will use for the next successful transaction to take place on the EP
3051:                          USBAdvancePingPongBuffer(&p);    
042C  3004     MOVLW 0x4
042D  0021     MOVLB 0x1
042E  06A3     XORWF 0x23, F
3052:                          
3053:                          //Check if we are currently terminating, or have previously terminated
3054:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
3055:                          //set DTS to the proper state, and call the application callback
3056:                          //function.
3057:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
042F  18A2     BTFSC 0x22, 0x1
0430  2C36     GOTO 0x436
0431  0823     MOVF 0x23, W
0432  0086     MOVWF FSR1L
0433  0187     CLRF FSR1H
0434  1F81     BTFSS INDF1, 0x7
0435  2C5A     GOTO 0x45A
3058:                          {
3059:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0436  0020     MOVLB 0x0
0437  1BC4     BTFSC 0x44, 0x7
0438  2C3D     GOTO 0x43D
3060:                              {
3061:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0439  0844     MOVF 0x44, W
043A  390F     ANDLW 0xF
043B  3E28     ADDLW 0x28
043C  2C40     GOTO 0x440
3062:                              }
3063:                              else
3064:                              {
3065:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
043D  0844     MOVF 0x44, W
043E  390F     ANDLW 0xF
043F  3E26     ADDLW 0x26
0440  0086     MOVWF FSR1L
0441  3001     MOVLW 0x1
0442  0087     MOVWF FSR1H
0443  1081     BCF INDF1, 0x1
3066:                              }
3067:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3068:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0444  0021     MOVLB 0x1
0445  0823     MOVF 0x23, W
0446  0086     MOVWF FSR1L
0447  303B     MOVLW 0x3B
0448  0187     CLRF FSR1H
0449  0581     ANDWF INDF1, F
3069:                              //Call the application event handler callback function, so it can 
3070:          					//decide if the endpoint should get re-armed again or not.
3071:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
044A  3005     MOVLW 0x5
044B  0020     MOVLB 0x0
044C  00E0     MOVWF count
044D  01E1     CLRF 0x61
044E  0021     MOVLB 0x1
044F  0823     MOVF 0x23, W
0450  0020     MOVLB 0x0
0451  00E2     MOVWF 0x62
0452  01E3     CLRF 0x63
0453  01E4     CLRF 0x64
0454  0AE4     INCF 0x64, F
0455  01E5     CLRF 0x65
0456  3182     MOVLP 0x2
0457  2288     CALL 0x288
0458  3183     MOVLP 0x3
3072:                          }
0459  2C5F     GOTO 0x45F
3073:                          else
3074:                          {
3075:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3076:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
045A  0823     MOVF 0x23, W
045B  0086     MOVWF FSR1L
045C  303B     MOVLW 0x3B
045D  0187     CLRF FSR1H
045E  0581     ANDWF INDF1, F
3077:                          } 
3078:                      #else //else we must not be using ping-pong buffering on the requested endpoint
3079:                          //Check if we need to call the user transfer terminated event callback function.
3080:                          //We should call the callback, if the endpoint was previously terminated,
3081:                          //or the endpoint is currently armed, and the host is performing clear
3082:                          //endpoint halt, even though the endpoint wasn't stalled.
3083:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
3084:                          {
3085:                              //We are going to call the user transfer terminated callback.
3086:                              //Clear the flag so we know we took care of it and don't need
3087:                              //to call it again later.
3088:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
3089:                              {
3090:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
3091:                              }
3092:                              else
3093:                              {
3094:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
3095:                              }
3096:           
3097:                              //Clear UOWN and remove the STALL condition.   
3098:                              //  In this case we also need to set the DTS bit to 1 so that
3099:                              //  it toggles to DATA0 the next time the application firmware
3100:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3101:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3102:                              p->STAT.Val |= _DAT1;
3103:                              //Let the application firmware know a transaction just
3104:                              //got terminated by the host, and that it is now free to
3105:                              //re-arm the endpoint or do other tasks if desired.                                        
3106:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
3107:                          }
3108:                          else
3109:                          {
3110:                              //Clear UOWN and remove the STALL condition.   
3111:                              //  In this case we also need to set the DTS bit to 1 so that
3112:                              //  it toggles to DATA0 the next time the application firmware
3113:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3114:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3115:                              p->STAT.Val |= _DAT1;
3116:                          } 
3117:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3118:                      
3119:          			//Get a pointer to the appropriate UEPn register
3120:                      #if defined(__C32__)
3121:                          pUEP = (DWORD*)(&U1EP0);
3122:                          pUEP += (SetupPkt.EPNum*4);
3123:                      #else
3124:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
045F  0020     MOVLB 0x0
0460  0844     MOVF 0x44, W
0461  390F     ANDLW 0xF
0462  3E98     ADDLW 0x98
0463  00E6     MOVWF work
0464  300E     MOVLW 0xE
0465  01E7     CLRF n
0466  3DE7     ADDWFC n, F
0467  0866     MOVF work, W
0468  0021     MOVLB 0x1
0469  00A0     MOVWF BDT
046A  0020     MOVLB 0x0
046B  0867     MOVF n, W
046C  0021     MOVLB 0x1
046D  00A1     MOVWF 0x21
3125:                      #endif
3126:          
3127:          			//Clear the STALL bit in the UEP register
3128:                      *pUEP &= ~UEP_STALL;            
046E  0820     MOVF BDT, W
046F  0086     MOVWF FSR1L
0470  0821     MOVF 0x21, W
0471  0087     MOVWF FSR1H
0472  1001     BCF INDF1, 0x0
3129:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3130:              }//end if (lots of checks for set/clear endpoint halt)
3131:          }//end USBStdFeatureReqHandler
0473  0008     RETURN
3132:          
3133:          
3134:          /** EOF USBDevice.c *****************************************************/
---  /home/chris/Dev/klondike/firmware/Klondike.X/main.c  -----------------------------------------------
1:             /********
2:              * 
3:              *  Klondike ASIC Miner - main.c - firmware USB support and control loop
4:              * 
5:              * (C) Copyright 2013 Chris Savery. 
6:              *
7:              * This program is free software: you can redistribute it and/or modify
8:              * it under the terms of the GNU General Public License as published by
9:              * the Free Software Foundation, either version 3 of the License, or
10:             * (at your option) any later version.
11:             *
12:             * This program is distributed in the hope that it will be useful,
13:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
14:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15:             * GNU General Public License for more details.
16:             *
17:             * You should have received a copy of the GNU General Public License
18:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
19:             *
20:             * Portions Derived from Microchip LPC Dev Kit and USB stack code 
21:             * are covered under their own license from Microchip and not included
22:             * in the open source license as other source code. 
23:             * 
24:             * Supports only PIC16LF1459 processor.
25:             */
26:            
27:            #include "GenericTypeDefs.h"
28:            #include "Compiler.h"
29:            #include "USB/usb.h"
30:            #include "USB/usb_function_generic.h"
31:            #include "HardwareProfile.h"
32:            #include "klondike.h"
33:            
34:            #if defined (USE_INTERNAL_OSC)  //Definition in the hardware profile
35:                __CONFIG(FOSC_INTOSC & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
36:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_3x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
37:            #else
38:                __CONFIG(FOSC_HS & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
39:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_4x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
40:            #endif
41:            
42:            #define IN_DATA_BUFFER_ADDRESS 0x2140
43:            #define OUT_DATA_BUFFER_ADDRESS 0x2190
44:            #define IN_DATA_BUFFER_ADDRESS_TAG @IN_DATA_BUFFER_ADDRESS
45:            #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS 
46:            
47:            unsigned char INPacket[USBGEN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;      //User application buffer for sending IN packets to the host
48:            unsigned char OUTPacket[USBGEN_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;    //User application buffer for receiving and holding OUT packets sent from the host
49:            
50:            USB_HANDLE USBGenericOutHandle;  //USB handle.  Must be initialized to 0 at startup.
51:            USB_HANDLE USBGenericInHandle;   //USB handle.  Must be initialized to 0 at startup.
52:            
53:            BYTE WQI, WQX;
54:            
55:            extern WORKSTATUS Status;
56:            extern BYTE SlaveAddress;
57:            extern I2CSTATE I2CState;
58:            extern BYTE I2CCount;
59:            
60:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
61:            static void InitializeSystem(void);
62:            void ProcessIO(void);
63:            void USBDeviceTasks(void);
64:            void USBCBSendResume(void);
65:            void UserInit(void);
66:            
67:            void SendCmdReply(char *cmd, BYTE *ReplyBuf, BYTE count);
68:            
69:            void interrupt ISRCode()
70:            {
0004  3180     MOVLP 0x0
0005  0020     MOVLB 0x0
0006  087F     MOVF 0x7F, W
0007  00FD     MOVWF 0x7D
71:                //if(RCIF)
72:                if(IOCBF)
0008  0027     MOVLB 0x7
0009  0816     MOVF TMR1L, W
000A  1903     BTFSC STATUS, 0x2
000B  280E     GOTO 0xE
73:                    ResultRx();
000C  3197     MOVLP 0x17
000D  2733     CALL 0x733
74:                //if(TMR0IF)
75:                //    WorkTick();
76:                //if(RCIF)
77:                //    ResultRx();
78:                //if(TMR1GIF)
79:                //    UpdateFanSpeed();
80:                /*if(BCL1IF) {
81:                    BCL1IF = 0; I2CState.Next = 0;
82:                }
83:                if(SSP1IF) {
84:                    SSP1IF = 0;
85:                    if(I2CState.Slave)
86:                        I2CSlave();
87:                    else if(I2CState.Next < I2C_WRITE) // split because not enough contigous code space
88:                        I2CRead();
89:                    else
90:                        I2CWrite();
91:                }*/
92:                #if defined(USB_INTERRUPT)
93:                    USBDeviceTasks();
94:                #endif
95:            }
000E  087D     MOVF 0x7D, W
96:            
97:            int main(void)
98:            {   
99:                InitializeSystem();
085C  25C5     CALL 0x5C5
100:           
101:               while(1)
102:               {
103:                   #if defined(USB_INTERRUPT)
104:                       //if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
105:                       //{
106:                           USBDeviceAttach();              
107:                       //}
108:                   #endif
109:           
110:                   /*if(USBDeviceState < CONFIGURED_STATE) {
111:                       if(!I2CState.Slave)
112:                           InitI2CSlave();
113:                       }
114:                   else if(!I2CState.Master)
115:                       InitI2CMaster();*/
116:           
117:                   #if defined(USB_POLLING)
118:               // Check bus status and service USB interrupts.
119:                   USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
085D  3181     MOVLP 0x1
085E  2191     CALL 0x191
085F  3188     MOVLP 0x8
120:                                     // this function periodically.  This function will take care
121:                                     // of processing and responding to SETUP transactions 
122:                                     // (such as during the enumeration process when you first
123:                                     // plug in).  USB hosts require that USB devices should accept
124:                                     // and process SETUP packets in a timely fashion.  Therefore,
125:                                     // when using polling, this function should be called 
126:                                     // regularly (such as once every 1.8ms or faster** [see 
127:                                     // inline code comments in usb_device.c for explanation when
128:                                     // "or faster" applies])  In most cases, the USBDeviceTasks() 
129:                                     // function does not take very long to execute (ex: <100 
130:                                     // instruction cycles) before it returns.
131:                   #endif
132:                   
133:                   if(TMR0IF)
0860  1D0B     BTFSS INTCON, 0x2
0861  2864     GOTO 0x64
134:                       WorkTick();
0862  25DB     CALL 0x5DB
0863  3188     MOVLP 0x8
135:           
136:                   if(Status.State == 'P'){
0864  0022     MOVLB 0x2
0865  0852     MOVF 0x52, W
0866  3A50     XORLW 0x50
0867  1D03     BTFSS STATUS, 0x2
0868  286B     GOTO 0x6B
137:                       AsicPushWork();
0869  2255     CALL 0x255
086A  3188     MOVLP 0x8
138:                   }
139:                                 
140:                   ProcessIO();  
086B  2570     CALL 0x570
086C  3188     MOVLP 0x8
086D  285D     GOTO 0x5D
141:                         
142:               }//end while
143:           }//end main
086E  00E6     MOVWF work
144:           
145:           static void InitializeSystem(void)
146:           {
147:               // all pins digital mode, except RC2, which has a Thermistor on it
148:               ANSELA = 0x00;
0DC5  0023     MOVLB 0x3
0DC6  018C     CLRF PORTA
149:               ANSELB = 0x00;
0DC7  018D     CLRF PORTB
150:               ANSELC = 0x04;  
0DC8  3004     MOVLW 0x4
0DC9  008E     MOVWF PORTC
151:           
152:               #if defined (USE_INTERNAL_OSC)
153:                   OSCTUNE = 0;
0DCA  0021     MOVLB 0x1
0DCB  0198     CLRF T1CON
154:                   OSCCON = 0xFC;          //16MHz HFINTOSC with 3x PLL enabled (48MHz operation)
0DCC  30FC     MOVLW 0xFC
0DCD  0099     MOVWF T1GCON
155:                   ACTCON = 0x90;          //Enable active clock tuning with USB
0DCE  3090     MOVLW 0x90
0DCF  0027     MOVLB 0x7
0DD0  009B     MOVWF PR2
156:               #endif
157:           
158:               USBGenericOutHandle = 0;
0DD1  0021     MOVLB 0x1
0DD2  01EC     CLRF USBDeferStatusStagePacket
159:               USBGenericInHandle = 0;
0DD3  0022     MOVLB 0x2
0DD4  01B7     CLRF 0x37
160:               WQI = WQX = 0;
0DD5  01BB     CLRF 0x3B
0DD6  0021     MOVLB 0x1
0DD7  01ED     CLRF controlTransferState
161:               
162:               UserInit();
0DD8  260E     CALL 0x60E
163:           
164:               USBDeviceInit();    //usb_device.c.  Initializes USB module SFRs and firmware
0DD9  3196     MOVLP 0x16
0DDA  2EBF     GOTO 0x6BF
165:                                   //variables to known states.
166:           }//end InitializeSystem
0DDB  0022     MOVLB 0x2
167:           
168:           
169:           void UserInit(void)
170:           {
171:               InitLED();
0E0E  128C     BCF PORTA, 0x5
0E0F  0022     MOVLB 0x2
0E10  168C     BSF PORTA, 0x5
172:               InitTempSensor();
0E11  261A     CALL 0x61A
0E12  3188     MOVLP 0x8
173:               InitFAN();
0E13  2723     CALL 0x723
0E14  3188     MOVLP 0x8
174:               InitWorkTick();
0E15  270D     CALL 0x70D
0E16  3188     MOVLP 0x8
175:               //InitI2CMaster();
176:               InitResultRx();
0E17  273B     CALL 0x73B
0E18  3188     MOVLP 0x8
177:               DetectAsics();
0E19  2F4C     GOTO 0x74C
178:           
179:           }//end UserInit
0E1A  0021     MOVLB 0x1
180:           
181:           void ProcessIO(void)
182:           {   
183:             
184:               if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;
0D70  3020     MOVLW 0x20
0D71  0021     MOVLB 0x1
0D72  026B     SUBWF 0x6B, W
0D73  1C03     BTFSS STATUS, 0x0
0D74  0008     RETURN
0D75  003D     MOVLB 0x1D
0D76  188E     BTFSC PORTC, 0x1
0D77  0008     RETURN
185:           
186:               /*if(USBGetDeviceState() == DETACHED_STATE) {
187:                   if(I2CCount > 0) {
188:                       ProcessCmd(OUTPacket);
189:                       I2CCount = 0;
190:                       }
191:               }
192:               else*/
193:               if(!USBHandleBusy(USBGenericOutHandle)) {
0D78  0021     MOVLB 0x1
0D79  086C     MOVF USBDeferStatusStagePacket, W
0D7A  1903     BTFSC STATUS, 0x2
0D7B  2D84     GOTO 0x584
0D7C  086C     MOVF USBDeferStatusStagePacket, W
0D7D  0086     MOVWF FSR1L
0D7E  0187     CLRF FSR1H
0D7F  0D01     RLF INDF1, W
0D80  0D01     RLF INDF1, W
0D81  3901     ANDLW 0x1
0D82  00E7     MOVWF n
0D83  2D85     GOTO 0x585
0D84  01E7     CLRF n
0D85  01E8     CLRF i_1089
0D86  0868     MOVF i_1089, W
0D87  0467     IORWF n, W
0D88  1D03     BTFSS STATUS, 0x2
0D89  2D98     GOTO 0x598
194:                   //if( OUTPacket[1] != MASTER_ADDRESS )
195:                   //    I2CRelay(OUTPacket, USBGEN_EP_SIZE);
196:                   //else
197:                       ProcessCmd(OUTPacket);
0D8A  30A0     MOVLW 0xA0
0D8B  206E     CALL 0x6E
198:               USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM, (BYTE*)&OUTPacket, USBGEN_EP_SIZE);
0D8C  0020     MOVLB 0x0
0D8D  30A0     MOVLW 0xA0
0D8E  01D9     CLRF x
0D8F  00DA     MOVWF i_718
0D90  3040     MOVLW 0x40
0D91  00DB     MOVWF i
0D92  3001     MOVLW 0x1
0D93  3182     MOVLP 0x2
0D94  22CD     CALL 0x2CD
0D95  3188     MOVLP 0x8
0D96  0021     MOVLB 0x1
0D97  00EC     MOVWF USBDeferStatusStagePacket
199:               }
200:           
201:               if(WQI != WQX && !USBHandleBusy(USBGenericInHandle)) {
0D98  086D     MOVF controlTransferState, W
0D99  0022     MOVLB 0x2
0D9A  063B     XORWF 0x3B, W
0D9B  1903     BTFSC STATUS, 0x2
0D9C  0008     RETURN
0D9D  0837     MOVF 0x37, W
0D9E  1903     BTFSC STATUS, 0x2
0D9F  2DA9     GOTO 0x5A9
0DA0  0837     MOVF 0x37, W
0DA1  0086     MOVWF FSR1L
0DA2  0187     CLRF FSR1H
0DA3  0D01     RLF INDF1, W
0DA4  0D01     RLF INDF1, W
0DA5  3901     ANDLW 0x1
0DA6  0021     MOVLB 0x1
0DA7  00E9     MOVWF i
0DA8  2DAB     GOTO 0x5AB
0DA9  0021     MOVLB 0x1
0DAA  01E9     CLRF i
0DAB  01EA     CLRF pBDTEntryIn
0DAC  086A     MOVF pBDTEntryIn, W
0DAD  0469     IORWF i, W
0DAE  1D03     BTFSS STATUS, 0x2
0DAF  0008     RETURN
202:                   USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM, (BYTE*)&INPacket[WQX*USB_RECORD_SIZE], USB_RECORD_SIZE);
0DB0  0020     MOVLB 0x0
0DB1  300F     MOVLW 0xF
0DB2  01D9     CLRF x
0DB3  0AD9     INCF x, F
0DB4  00D6     MOVWF dest
0DB5  0022     MOVLB 0x2
0DB6  083B     MOVF 0x3B, W
0DB7  252E     CALL 0x52E
0DB8  3E20     ADDLW 0x20
0DB9  00DA     MOVWF i_718
0DBA  300F     MOVLW 0xF
0DBB  00DB     MOVWF i
0DBC  3001     MOVLW 0x1
0DBD  3182     MOVLP 0x2
0DBE  22CD     CALL 0x2CD
0DBF  0022     MOVLB 0x2
0DC0  00B7     MOVWF 0x37
203:                   WQX = (WQX+1) & 3;
0DC1  3003     MOVLW 0x3
0DC2  0ABB     INCF 0x3B, F
0DC3  05BB     ANDWF 0x3B, F
204:               }
205:           } //end ProcessIO
0DC4  0008     RETURN
206:           
207:           void SendCmdReply(char *cmd, BYTE *data, BYTE count)
208:           {
209:               if(WQI*USB_RECORD_SIZE + count + 2 < USBGEN_EP_SIZE) {
09B1  0860     MOVF count, W
09B2  00E1     MOVWF 0x61
09B3  01E2     CLRF 0x62
09B4  0021     MOVLB 0x1
09B5  086D     MOVF controlTransferState, W
09B6  0020     MOVLB 0x0
09B7  00D6     MOVWF dest
09B8  300F     MOVLW 0xF
09B9  01D7     CLRF product
09BA  00D8     MOVWF off
09BB  01D9     CLRF x
09BC  221B     CALL 0x21B
09BD  3188     MOVLP 0x8
09BE  0861     MOVF 0x61, W
09BF  0756     ADDWF dest, W
09C0  00E3     MOVWF 0x63
09C1  0862     MOVF 0x62, W
09C2  3D57     ADDWFC product, W
09C3  00E4     MOVWF 0x64
09C4  0863     MOVF 0x63, W
09C5  3E02     ADDLW 0x2
09C6  00E5     MOVWF 0x65
09C7  3000     MOVLW 0x0
09C8  3D64     ADDWFC 0x64, W
09C9  00E6     MOVWF work
09CA  3A80     XORLW 0x80
09CB  00FF     MOVWF 0x7F
09CC  3080     MOVLW 0x80
09CD  027F     SUBWF 0x7F, W
09CE  1D03     BTFSS STATUS, 0x2
09CF  29D2     GOTO 0x1D2
09D0  3040     MOVLW 0x40
09D1  0265     SUBWF 0x65, W
09D2  1803     BTFSC STATUS, 0x0
09D3  0008     RETURN
1776  087A     MOVF count, W
1777  0020     MOVLB 0x0
1778  00D0     MOVWF 0x50
1779  01D1     CLRF 0x51
177A  0021     MOVLB 0x1
177B  086D     MOVF controlTransferState, W
177C  00F0     MOVWF multiplicand
177D  300F     MOVLW 0xF
177E  01F1     CLRF 0x71
177F  00F2     MOVWF product
1780  01F3     CLRF 0x73
1781  27EB     CALL 0x7EB
1782  3197     MOVLP 0x17
1783  0020     MOVLB 0x0
1784  0850     MOVF 0x50, W
1785  0770     ADDWF multiplicand, W
1786  00D2     MOVWF 0x52
1787  0851     MOVF 0x51, W
1788  3D71     ADDWFC 0x71, W
1789  00D3     MOVWF 0x53
178A  0852     MOVF 0x52, W
178B  3E02     ADDLW 0x2
178C  00D4     MOVWF 0x54
178D  3000     MOVLW 0x0
178E  3D53     ADDWFC 0x53, W
178F  00D5     MOVWF 0x55
1790  3A80     XORLW 0x80
1791  00FF     MOVWF 0x7F
1792  3080     MOVLW 0x80
1793  027F     SUBWF 0x7F, W
1794  1D03     BTFSS STATUS, 0x2
1795  2F98     GOTO 0x798
1796  3040     MOVLW 0x40
1797  0254     SUBWF 0x54, W
1798  1803     BTFSC STATUS, 0x0
1799  0008     RETURN
210:                   INPacket[WQI*USB_RECORD_SIZE] = cmd[0];
09D4  300F     MOVLW 0xF
09D5  0020     MOVLB 0x0
09D6  00D6     MOVWF dest
09D7  0021     MOVLB 0x1
09D8  086D     MOVF controlTransferState, W
09D9  252E     CALL 0x52E
09DA  3188     MOVLP 0x8
09DB  3E20     ADDLW 0x20
09DC  0086     MOVWF FSR1L
09DD  3002     MOVLW 0x2
09DE  0087     MOVWF FSR1H
09DF  085C     MOVF work, W
09E0  0084     MOVWF FSR0L
09E1  085D     MOVF y, W
09E2  0085     MOVWF FSR0H
09E3  0800     MOVF INDF0, W
09E4  0081     MOVWF INDF1
179A  300F     MOVLW 0xF
179B  00F0     MOVWF multiplicand
179C  0021     MOVLB 0x1
179D  086D     MOVF controlTransferState, W
179E  27DF     CALL 0x7DF
179F  3197     MOVLP 0x17
17A0  3E20     ADDLW 0x20
17A1  0086     MOVWF FSR1L
17A2  3002     MOVLW 0x2
17A3  0087     MOVWF FSR1H
17A4  0876     MOVF cmd, W
17A5  0084     MOVWF FSR0L
17A6  0877     MOVF 0x77, W
17A7  0085     MOVWF FSR0H
17A8  0800     MOVF INDF0, W
17A9  0081     MOVWF INDF1
211:                   INPacket[WQI*USB_RECORD_SIZE + 1] = SlaveAddress;
09E5  300F     MOVLW 0xF
09E6  00D6     MOVWF dest
09E7  0021     MOVLB 0x1
09E8  086D     MOVF controlTransferState, W
09E9  252E     CALL 0x52E
09EA  3188     MOVLP 0x8
09EB  3E21     ADDLW 0x21
09EC  0086     MOVWF FSR1L
09ED  3002     MOVLW 0x2
09EE  0087     MOVWF FSR1H
09EF  0022     MOVLB 0x2
09F0  0833     MOVF 0x33, W
09F1  0081     MOVWF INDF1
17AA  300F     MOVLW 0xF
17AB  00F0     MOVWF multiplicand
17AC  086D     MOVF controlTransferState, W
17AD  27DF     CALL 0x7DF
17AE  3197     MOVLP 0x17
17AF  3E21     ADDLW 0x21
17B0  0086     MOVWF FSR1L
17B1  3002     MOVLW 0x2
17B2  0087     MOVWF FSR1H
17B3  0022     MOVLB 0x2
17B4  0833     MOVF 0x33, W
17B5  0081     MOVWF INDF1
212:                   for(BYTE n=0; n < count; n++)
09F2  0020     MOVLB 0x0
09F3  01E7     CLRF n
09F4  0860     MOVF count, W
09F5  0267     SUBWF n, W
09F6  1803     BTFSC STATUS, 0x0
09F7  2A16     GOTO 0x216
0A14  0AE7     INCF n, F
0A15  29F4     GOTO 0x1F4
17B6  01FB     CLRF n
17B7  087A     MOVF count, W
17B8  027B     SUBWF n, W
17B9  1803     BTFSC STATUS, 0x0
17BA  2FDA     GOTO 0x7DA
17D8  0AFB     INCF n, F
17D9  2FB7     GOTO 0x7B7
213:                       INPacket[WQI*USB_RECORD_SIZE + n + 2] = data[n];
09F8  300F     MOVLW 0xF
09F9  00D6     MOVWF dest
09FA  0021     MOVLB 0x1
09FB  086D     MOVF controlTransferState, W
09FC  252E     CALL 0x52E
09FD  3188     MOVLP 0x8
09FE  00E1     MOVWF 0x61
09FF  3E22     ADDLW 0x22
0A00  00E2     MOVWF 0x62
0A01  0867     MOVF n, W
0A02  0762     ADDWF 0x62, W
0A03  00E3     MOVWF 0x63
0A04  0086     MOVWF FSR1L
0A05  3002     MOVLW 0x2
0A06  0087     MOVWF FSR1H
0A07  085F     MOVF handle, W
0A08  00E5     MOVWF 0x65
0A09  085E     MOVF split, W
0A0A  00E4     MOVWF 0x64
0A0B  0867     MOVF n, W
0A0C  0764     ADDWF 0x64, W
0A0D  0084     MOVWF FSR0L
0A0E  0865     MOVF 0x65, W
0A0F  1803     BTFSC STATUS, 0x0
0A10  0A65     INCF 0x65, W
0A11  0085     MOVWF FSR0H
0A12  0800     MOVF INDF0, W
0A13  0081     MOVWF INDF1
17BB  300F     MOVLW 0xF
17BC  00F0     MOVWF multiplicand
17BD  0021     MOVLB 0x1
17BE  086D     MOVF controlTransferState, W
17BF  27DF     CALL 0x7DF
17C0  3197     MOVLP 0x17
17C1  0020     MOVLB 0x0
17C2  00D0     MOVWF 0x50
17C3  3E22     ADDLW 0x22
17C4  00D1     MOVWF 0x51
17C5  087B     MOVF n, W
17C6  0751     ADDWF 0x51, W
17C7  00D2     MOVWF 0x52
17C8  0086     MOVWF FSR1L
17C9  3002     MOVLW 0x2
17CA  0087     MOVWF FSR1H
17CB  0879     MOVF 0x79, W
17CC  00D4     MOVWF 0x54
17CD  0878     MOVF data, W
17CE  00D3     MOVWF 0x53
17CF  087B     MOVF n, W
17D0  0753     ADDWF 0x53, W
17D1  0084     MOVWF FSR0L
17D2  0854     MOVF 0x54, W
17D3  1803     BTFSC STATUS, 0x0
17D4  0A54     INCF 0x54, W
17D5  0085     MOVWF FSR0H
17D6  0800     MOVF INDF0, W
17D7  0081     MOVWF INDF1
214:                   WQI = (WQI+1) & 3;
0A16  0021     MOVLB 0x1
0A17  3003     MOVLW 0x3
0A18  0AED     INCF controlTransferState, F
0A19  05ED     ANDWF controlTransferState, F
17DA  0021     MOVLB 0x1
17DB  3003     MOVLW 0x3
17DC  0AED     INCF controlTransferState, F
17DD  05ED     ANDWF controlTransferState, F
215:               }
216:           
217:               //if(USBDeviceState < CONFIGURED_STATE) {
218:               //    I2CCount = count+2;
219:               //}
220:               //else
221:           
222:           
223:           }
0A1A  0008     RETURN
17DE  0008     RETURN
224:           
225:           
226:           // ******************************************************************************************************
227:           // ************** USB Callback Functions ****************************************************************
228:           // ******************************************************************************************************
229:           // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
230:           // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
231:           // packets to your device.  In response to this, all USB devices are supposed to decrease their power
232:           // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
233:           // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
234:           // function.  You should modify these callback functions to take appropriate actions for each of these
235:           // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
236:           // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
237:           // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
238:           // add code that undoes the power saving things done in the USBCBSuspend() function.
239:           
240:           // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
241:           // function.  This function is meant to be called from the application firmware instead.  See the
242:           // additional comments near the function.
243:           
244:           // Note *: The "usb_20.pdf" specs indicate 500uA or 2.5mA, depending upon device classification. However,
245:           // the USB-IF has officially issued an ECN (engineering change notice) changing this to 2.5mA for all 
246:           // devices.  Make sure to re-download the latest specifications to get all of the newest ECNs.
247:           
248:           /******************************************************************************
249:            * Function:        void USBCBSuspend(void)
250:            *
251:            * PreCondition:    None
252:            *
253:            * Input:           None
254:            *
255:            * Output:          None
256:            *
257:            * Side Effects:    None
258:            *
259:            * Overview:        Call back that is invoked when a USB suspend is detected
260:            *
261:            * Note:            None
262:            *****************************************************************************/
263:           void USBCBSuspend(void)
264:           {
265:               //Example power saving code.  Insert appropriate code here for the desired
266:               //application behavior.  If the microcontroller will be put to sleep, a
267:               //process similar to that shown below may be used:
268:               
269:               //ConfigureIOPinsForLowPower();
270:               //SaveStateOfAllInterruptEnableBits();
271:               //DisableAllInterruptEnableBits();
272:               //EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();   //should enable at least USBActivityIF as a wake source
273:               //Sleep();
274:               //RestoreStateOfAllPreviouslySavedInterruptEnableBits();    //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
275:               //RestoreIOPinsToNormal();                                  //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
276:           
277:               //IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
278:               //cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
279:               //things to not work as intended.   
280:               
281:           }
07FE  0008     RETURN
282:           
283:           /******************************************************************************
284:            * Function:        void USBCBWakeFromSuspend(void)
285:            *
286:            * PreCondition:    None
287:            *
288:            * Input:           None
289:            *
290:            * Output:          None
291:            *
292:            * Side Effects:    None
293:            *
294:            * Overview:        The host may put USB peripheral devices in low power
295:            *                  suspend mode (by "sending" 3+ms of idle).  Once in suspend
296:            *                  mode, the host may wake the device back up by sending non-
297:            *                  idle state signalling.
298:            *                  
299:            *                  This call back is invoked when a wakeup from USB suspend 
300:            *                  is detected.
301:            *
302:            * Note:            None
303:            *****************************************************************************/
304:           void USBCBWakeFromSuspend(void)
305:           {
306:               // If clock switching or other power savings measures were taken when
307:               // executing the USBCBSuspend() function, now would be a good time to
308:               // switch back to normal full power run mode conditions.  The host allows
309:               // a few milliseconds of wakeup time, after which the device must be 
310:               // fully back to normal, and capable of receiving and processing USB
311:               // packets.  In order to do this, the USB module must receive proper
312:               // clocking (IE: 48MHz clock must be available to SIE for full speed USB
313:               // operation).
314:           }
07FF  0008     RETURN
315:           
316:           /********************************************************************
317:            * Function:        void USBCB_SOF_Handler(void)
318:            *
319:            * PreCondition:    None
320:            *
321:            * Input:           None
322:            *
323:            * Output:          None
324:            *
325:            * Side Effects:    None
326:            *
327:            * Overview:        The USB host sends out a SOF packet to full-speed
328:            *                  devices every 1 ms. This interrupt may be useful
329:            *                  for isochronous pipes. End designers should
330:            *                  implement callback routine as necessary.
331:            *
332:            * Note:            None
333:            *******************************************************************/
334:           void USBCB_SOF_Handler(void)
335:           {
336:               // No need to clear UIRbits.SOFIF to 0 here.
337:               // Callback caller is already doing that.
338:           }
0003  0008     RETURN
339:           
340:           /*******************************************************************
341:            * Function:        void USBCBErrorHandler(void)
342:            *
343:            * PreCondition:    None
344:            *
345:            * Input:           None
346:            *
347:            * Output:          None
348:            *
349:            * Side Effects:    None
350:            *
351:            * Overview:        The purpose of this callback is mainly for
352:            *                  debugging during development. Check UEIR to see
353:            *                  which error causes the interrupt.
354:            *
355:            * Note:            None
356:            *******************************************************************/
357:           void USBCBErrorHandler(void)
358:           {
359:               // No need to clear UEIR to 0 here.
360:               // Callback caller is already doing that.
361:           
362:               // Typically, user firmware does not need to do anything special
363:               // if a USB error occurs.  For example, if the host sends an OUT
364:               // packet to your device, but the packet gets corrupted (ex:
365:               // because of a bad connection, or the user unplugs the
366:               // USB cable during the transmission) this will typically set
367:               // one or more USB error interrupt flags.  Nothing specific
368:               // needs to be done however, since the SIE will automatically
369:               // send a "NAK" packet to the host.  In response to this, the
370:               // host will normally retry to send the packet again, and no
371:               // data loss occurs.  The system will typically recover
372:               // automatically, without the need for application firmware
373:               // intervention.
374:               
375:               // Nevertheless, this callback function is provided, such as
376:               // for debugging purposes.
377:           }
0002  0008     RETURN
378:           
379:           
380:           /*******************************************************************
381:            * Function:        void USBCBCheckOtherReq(void)
382:            *
383:            * PreCondition:    None
384:            *
385:            * Input:           None
386:            *
387:            * Output:          None
388:            *
389:            * Side Effects:    None
390:            *
391:            * Overview:        When SETUP packets arrive from the host, some
392:            *                  firmware must process the request and respond
393:            *                  appropriately to fulfill the request.  Some of
394:            *                  the SETUP packets will be for standard
395:            *                  USB "chapter 9" (as in, fulfilling chapter 9 of
396:            *                  the official USB specifications) requests, while
397:            *                  others may be specific to the USB device class
398:            *                  that is being implemented.  For example, a HID
399:            *                  class device needs to be able to respond to
400:            *                  "GET REPORT" type of requests.  This
401:            *                  is not a standard USB chapter 9 request, and 
402:            *                  therefore not handled by usb_device.c.  Instead
403:            *                  this request should be handled by class specific 
404:            *                  firmware, such as that contained in usb_function_hid.c.
405:            *
406:            * Note:            None
407:            *****************************************************************************/
408:           void USBCBCheckOtherReq(void)
409:           {
410:               USBCheckVendorRequest();
07FC  2FFD     GOTO 0x7FD
411:           }//end
07FD  0008     RETURN
412:           
413:           
414:           /*******************************************************************
415:            * Function:        void USBCBStdSetDscHandler(void)
416:            *
417:            * PreCondition:    None
418:            *
419:            * Input:           None
420:            *
421:            * Output:          None
422:            *
423:            * Side Effects:    None
424:            *
425:            * Overview:        The USBCBStdSetDscHandler() callback function is
426:            *                  called when a SETUP, bRequest: SET_DESCRIPTOR request
427:            *                  arrives.  Typically SET_DESCRIPTOR requests are
428:            *                  not used in most applications, and it is
429:            *                  optional to support this type of request.
430:            *
431:            * Note:            None
432:            *****************************************************************************/
433:           void USBCBStdSetDscHandler(void)
434:           {
435:               // Must claim session ownership if supporting this request
436:           }//end
0802  0008     RETURN
437:           
438:           
439:           /******************************************************************************
440:            * Function:        void USBCBInitEP(void)
441:            *
442:            * PreCondition:    None
443:            *
444:            * Input:           None
445:            *
446:            * Output:          None
447:            *
448:            * Side Effects:    None
449:            *
450:            * Overview:        This function is called when the device becomes
451:            *                  initialized, which occurs after the host sends a
452:            *                  SET_CONFIGURATION (wValue not = 0) request.  This 
453:            *                  callback function should initialize the endpoints 
454:            *                  for the device's usage according to the current 
455:            *                  configuration.
456:            *
457:            * Note:            None
458:            *****************************************************************************/
459:           void USBCBInitEP(void)
460:           {
461:               //Enable the application endpoints
462:               USBEnableEndpoint(USBGEN_EP_NUM,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1668  301E     MOVLW 0x1E
1669  00DA     MOVWF i_718
166A  3001     MOVLW 0x1
166B  2677     CALL 0x677
463:               //Arm the application OUT endpoint, so it can receive a packet from the host
464:               USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,USBGEN_EP_SIZE);
166C  30A0     MOVLW 0xA0
166D  01D9     CLRF x
166E  00DA     MOVWF i_718
166F  3040     MOVLW 0x40
1670  00DB     MOVWF i
1671  3001     MOVLW 0x1
1672  3182     MOVLP 0x2
1673  22CD     CALL 0x2CD
1674  0021     MOVLB 0x1
1675  00EC     MOVWF USBDeferStatusStagePacket
465:           }
1676  0008     RETURN
466:           
467:           /********************************************************************
468:            * Function:        void USBCBSendResume(void)
469:            *
470:            * PreCondition:    None
471:            *
472:            * Input:           None
473:            *
474:            * Output:          None
475:            *
476:            * Side Effects:    None
477:            *
478:            * Overview:        The USB specifications allow some types of USB
479:            *                  peripheral devices to wake up a host PC (such
480:            *                  as if it is in a low power suspend to RAM state).
481:            *                  This can be a very useful feature in some
482:            *                  USB applications, such as an Infrared remote
483:            *                  control receiver.  If a user presses the "power"
484:            *                  button on a remote control, it is nice that the
485:            *                  IR receiver can detect this signalling, and then
486:            *                  send a USB "command" to the PC to wake up.
487:            *                  
488:            *                  The USBCBSendResume() "callback" function is used
489:            *                  to send this special USB signalling which wakes 
490:            *                  up the PC.  This function may be called by
491:            *                  application firmware to wake up the PC.  This
492:            *                  function will only be able to wake up the host if
493:            *                  all of the below are true:
494:            *                  
495:            *                  1.  The USB driver used on the host PC supports
496:            *                      the remote wakeup capability.
497:            *                  2.  The USB configuration descriptor indicates
498:            *                      the device is remote wakeup capable in the
499:            *                      bmAttributes field.
500:            *                  3.  The USB host PC is currently sleeping,
501:            *                      and has previously sent your device a SET 
502:            *                      FEATURE setup packet which "armed" the
503:            *                      remote wakeup capability.   
504:            *
505:            *                  If the host has not armed the device to perform remote wakeup,
506:            *                  then this function will return without actually performing a
507:            *                  remote wakeup sequence.  This is the required behavior, 
508:            *                  as a USB device that has not been armed to perform remote 
509:            *                  wakeup must not drive remote wakeup signalling onto the bus;
510:            *                  doing so will cause USB compliance testing failure.
511:            *                  
512:            *                  This callback should send a RESUME signal that
513:            *                  has the period of 1-15ms.
514:            *
515:            * Note:            This function does nothing and returns quickly, if the USB
516:            *                  bus and host are not in a suspended condition, or are 
517:            *                  otherwise not in a remote wakeup ready state.  Therefore, it
518:            *                  is safe to optionally call this function regularly, ex: 
519:            *                  anytime application stimulus occurs, as the function will
520:            *                  have no effect, until the bus really is in a state ready
521:            *                  to accept remote wakeup. 
522:            *
523:            *                  When this function executes, it may perform clock switching,
524:            *                  depending upon the application specific code in 
525:            *                  USBCBWakeFromSuspend().  This is needed, since the USB
526:            *                  bus will no longer be suspended by the time this function
527:            *                  returns.  Therefore, the USB module will need to be ready
528:            *                  to receive traffic from the host.
529:            *
530:            *                  The modifiable section in this routine may be changed
531:            *                  to meet the application needs. Current implementation
532:            *                  temporary blocks other functions from executing for a
533:            *                  period of ~3-15 ms depending on the core frequency.
534:            *
535:            *                  According to USB 2.0 specification section 7.1.7.7,
536:            *                  "The remote wakeup device must hold the resume signaling
537:            *                  for at least 1 ms but for no more than 15 ms."
538:            *                  The idea here is to use a delay counter loop, using a
539:            *                  common value that would work over a wide range of core
540:            *                  frequencies.
541:            *                  That value selected is 1800. See table below:
542:            *                  ==========================================================
543:            *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
544:            *                  ==========================================================
545:            *                      48              12          1.05
546:            *                       4              1           12.6
547:            *                  ==========================================================
548:            *                  * These timing could be incorrect when using code
549:            *                    optimization or extended instruction mode,
550:            *                    or when having other interrupts enabled.
551:            *                    Make sure to verify using the MPLAB SIM's Stopwatch
552:            *                    and verify the actual signal on an oscilloscope.
553:            *******************************************************************/
554:           void USBCBSendResume(void)
555:           {
556:               static WORD delay_count;
557:               
558:               //First verify that the host has armed us to perform remote wakeup.
559:               //It does this by sending a SET_FEATURE request to enable remote wakeup,
560:               //usually just before the host goes to standby mode (note: it will only
561:               //send this SET_FEATURE request if the configuration descriptor declares
562:               //the device as remote wakeup capable, AND, if the feature is enabled
563:               //on the host (ex: on Windows based hosts, in the device manager 
564:               //properties page for the USB device, power management tab, the 
565:               //"Allow this device to bring the computer out of standby." checkbox 
566:               //should be checked).
567:               if(USBGetRemoteWakeupStatus() == TRUE) 
568:               {
569:                   //Verify that the USB bus is in fact suspended, before we send
570:                   //remote wakeup signalling.
571:                   if(USBIsBusSuspended() == TRUE)
572:                   {
573:                       USBMaskInterrupts();
574:                       
575:                       //Clock switch to settings consistent with normal USB operation.
576:                       USBCBWakeFromSuspend();
577:                       USBSuspendControl = 0; 
578:                       USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
579:                                                   //until a new suspend condition is detected.
580:           
581:                       //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
582:                       //device must continuously see 5ms+ of idle on the bus, before it sends
583:                       //remote wakeup signalling.  One way to be certain that this parameter
584:                       //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
585:                       //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
586:                       //5ms+ total delay since start of idle).
587:                       delay_count = 3600U;        
588:                       do
589:                       {
590:                           delay_count--;
591:                       }while(delay_count);
592:                       
593:                       //Now drive the resume K-state signalling onto the USB bus.
594:                       USBResumeControl = 1;       // Start RESUME signaling
595:                       delay_count = 1800U;        // Set RESUME line for 1-13 ms
596:                       do
597:                       {
598:                           delay_count--;
599:                       }while(delay_count);
600:                       USBResumeControl = 0;       //Finished driving resume signalling
601:           
602:                       USBUnmaskInterrupts();
603:                   }
604:               }
605:           }
606:           
607:           
608:           /*******************************************************************
609:            * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
610:            *                        int event, void *pdata, WORD size)
611:            *
612:            * PreCondition:    None
613:            *
614:            * Input:           int event - the type of event
615:            *                  void *pdata - pointer to the event data
616:            *                  WORD size - size of the event data
617:            *
618:            * Output:          None
619:            *
620:            * Side Effects:    None
621:            *
622:            * Overview:        This function is called from the USB stack to
623:            *                  notify a user application that a USB event
624:            *                  occured.  This callback is in interrupt context
625:            *                  when the USB_INTERRUPT option is selected.
626:            *
627:            * Note:            None
628:            *******************************************************************/
629:           BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size)
630:           {
631:               switch( event )
0288  2AA5     GOTO 0x2A5
02A5  0861     MOVF 0x61, W
02A6  3A00     XORLW 0x0
02A7  1903     BTFSC STATUS, 0x2
02A8  2AAD     GOTO 0x2AD
02A9  3A7F     XORLW 0x7F
02AA  1903     BTFSC STATUS, 0x2
02AB  2AC7     GOTO 0x2C7
02AC  2ACC     GOTO 0x2CC
02AD  0860     MOVF count, W
02AE  3A01     XORLW 0x1
02AF  1903     BTFSC STATUS, 0x2
02B0  2A95     GOTO 0x295
02B1  3A03     XORLW 0x3
02B2  1903     BTFSC STATUS, 0x2
02B3  2A99     GOTO 0x299
02B4  3A01     XORLW 0x1
02B5  1903     BTFSC STATUS, 0x2
02B6  2A9D     GOTO 0x29D
02B7  3A06     XORLW 0x6
02B8  1903     BTFSC STATUS, 0x2
02B9  2ACC     GOTO 0x2CC
02BA  3A77     XORLW 0x77
02BB  1903     BTFSC STATUS, 0x2
02BC  2ACC     GOTO 0x2CC
02BD  3A01     XORLW 0x1
02BE  1903     BTFSC STATUS, 0x2
02BF  2A89     GOTO 0x289
02C0  3A07     XORLW 0x7
02C1  1903     BTFSC STATUS, 0x2
02C2  2A91     GOTO 0x291
02C3  3A01     XORLW 0x1
02C4  1903     BTFSC STATUS, 0x2
02C5  2A8D     GOTO 0x28D
02C6  2ACC     GOTO 0x2CC
02C7  0860     MOVF count, W
02C8  3AFF     XORLW 0xFF
02C9  1903     BTFSC STATUS, 0x2
02CA  2AA1     GOTO 0x2A1
02CB  2ACC     GOTO 0x2CC
632:               {
633:                   case EVENT_TRANSFER:
634:                       //Add application specific callback task or callback function here if desired.
635:                       break;
636:                   case EVENT_SOF:
637:                       USBCB_SOF_Handler();
0289  3180     MOVLP 0x0
028A  2003     CALL 0x3
028B  3181     MOVLP 0x1
638:                       break;
028C  2ACC     GOTO 0x2CC
639:                   case EVENT_SUSPEND:
640:                       USBCBSuspend();
028D  3187     MOVLP 0x7
028E  27FE     CALL 0x7FE
028F  3181     MOVLP 0x1
641:                       break;
0290  2ACC     GOTO 0x2CC
642:                   case EVENT_RESUME:
643:                       USBCBWakeFromSuspend();
0291  3187     MOVLP 0x7
0292  27FF     CALL 0x7FF
0293  3181     MOVLP 0x1
644:                       break;
0294  2ACC     GOTO 0x2CC
645:                   case EVENT_CONFIGURED: 
646:                       USBCBInitEP();
0295  3196     MOVLP 0x16
0296  2668     CALL 0x668
0297  3181     MOVLP 0x1
647:                       break;
0298  2ACC     GOTO 0x2CC
648:                   case EVENT_SET_DESCRIPTOR:
649:                       USBCBStdSetDscHandler();
0299  3188     MOVLP 0x8
029A  2002     CALL 0x2
029B  3181     MOVLP 0x1
650:                       break;
029C  2ACC     GOTO 0x2CC
651:                   case EVENT_EP0_REQUEST:
652:                       USBCBCheckOtherReq();
029D  3187     MOVLP 0x7
029E  27FC     CALL 0x7FC
029F  3181     MOVLP 0x1
653:                       break;
02A0  2ACC     GOTO 0x2CC
654:                   case EVENT_BUS_ERROR:
655:                       USBCBErrorHandler();
02A1  3180     MOVLP 0x0
02A2  2002     CALL 0x2
02A3  3181     MOVLP 0x1
656:                       break;
02A4  2ACC     GOTO 0x2CC
657:                   case EVENT_TRANSFER_TERMINATED:
658:                       //Add application specific callback task or callback function here if desired.
659:                       //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
660:                       //FEATURE (endpoint halt) request on an application endpoint which was 
661:                       //previously armed (UOWN was = 1).  Here would be a good place to:
662:                       //1.  Determine which endpoint the transaction that just got terminated was 
663:                       //      on, by checking the handle value in the *pdata.
664:                       //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
665:                       //      endpoints).
666:                       break;
667:                   default:
668:                       break;
669:               }      
670:               return TRUE; 
671:           }
02CC  0008     RETURN
672:           /** EOF main.c ***************************************************************/
673:           
---  /home/chris/Dev/klondike/firmware/Klondike.X/klondike.c  -------------------------------------------
1:             /********
2:              * Klondike ASIC Miner - klondike.c - cmd processing and host protocol support 
3:              * 
4:              * (C) Copyright 2013 Chris Savery. 
5:              *
6:              * This program is free software: you can redistribute it and/or modify
7:              * it under the terms of the GNU General Public License as published by
8:              * the Free Software Foundation, either version 3 of the License, or
9:              * (at your option) any later version.
10:             *
11:             * This program is distributed in the hope that it will be useful,
12:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
13:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14:             * GNU General Public License for more details.
15:             *
16:             * You should have received a copy of the GNU General Public License
17:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
18:             *
19:             */
20:            #include "GenericTypeDefs.h"
21:            #include "Compiler.h"
22:            #include <xc.h>
23:            #include "klondike.h"
24:            
25:            const IDENTITY ID = { 0x02, "K16", 0xCAFEBABE };
26:            const char FwPwd[] = FWPWD;
27:            
28:            DWORD BankRanges[8] = { 0, 0x40000000, 0x2aaaaaaa, 0x20000000, 0x19999999, 0x15555555, 0x12492492, 0x10000000 };
29:            BYTE WorkNow, BankSize, ResultQC, SlowTick;
30:            BYTE SlaveAddress = MASTER_ADDRESS;
31:            BYTE HashTime = 256 - ((WORD)TICK_TOTAL/DEFAULT_HASHCLOCK);
32:            volatile WORKSTATUS Status = {'I',0,0,0,0,0,0,0,0, WORK_TICKS, 0 };
33:            WORKCFG Cfg = { DEFAULT_HASHCLOCK, DEFAULT_TEMP_TARGET, DEFAULT_TEMP_CRITICAL, DEFAULT_FAN_TARGET, 0 };
34:            WORKTASK WorkQue[MAX_WORK_COUNT];
35:            volatile BYTE ResultQue[MAX_RESULT_COUNT*4];
36:            DWORD ClockCfg[2] = { (((DWORD)DEFAULT_HASHCLOCK) << 18) | CLOCK_LOW_CHG, CLOCK_HIGH_CFG };
37:            
38:            DWORD NonceRanges[8];
39:            
40:            extern I2CSTATE I2CState;
41:            extern DWORD PrecalcHashes[6];
42:            
43:            void ProcessCmd(char *cmd)
44:            {
086E  00E6     MOVWF work
45:                // cmd is one char, dest address 1 byte, data follows
46:                // we already know address is ours here
47:                switch(cmd[0]) {
086F  2993     GOTO 0x193
0993  0866     MOVF work, W
0994  0086     MOVWF FSR1L
0995  3002     MOVLW 0x2
0996  0087     MOVWF FSR1H
0997  0801     MOVF INDF1, W
0998  3A41     XORLW 0x41
0999  1903     BTFSC STATUS, 0x2
099A  28CA     GOTO 0xCA
099B  3A02     XORLW 0x2
099C  1903     BTFSC STATUS, 0x2
099D  28DA     GOTO 0xDA
099E  3A06     XORLW 0x6
099F  1903     BTFSC STATUS, 0x2
09A0  2959     GOTO 0x159
09A1  3A03     XORLW 0x3
09A2  1903     BTFSC STATUS, 0x2
09A3  297A     GOTO 0x17A
09A4  3A0F     XORLW 0xF
09A5  1903     BTFSC STATUS, 0x2
09A6  28CF     GOTO 0xCF
09A7  3A1A     XORLW 0x1A
09A8  1903     BTFSC STATUS, 0x2
09A9  28BE     GOTO 0xBE
09AA  3A04     XORLW 0x4
09AB  1903     BTFSC STATUS, 0x2
09AC  2870     GOTO 0x70
09AD  29AE     GOTO 0x1AE
48:                    case 'W': // queue new work
49:                        if( Status.WorkQC < MAX_WORK_COUNT-1 ) {
0870  3003     MOVLW 0x3
0871  0022     MOVLB 0x2
0872  0255     SUBWF 0x55, W
0873  1803     BTFSC STATUS, 0x0
0874  28BE     GOTO 0xBE
50:                            WorkQue[ (WorkNow + Status.WorkQC++) & WORKMASK ] = *(WORKTASK *)(cmd+2);
0875  0021     MOVLB 0x1
0876  26F1     CALL 0x6F1
0877  3188     MOVLP 0x8
0878  086E     MOVF pBDTEntryEP0OutCurrent, W
0879  0020     MOVLB 0x0
087A  00D6     MOVWF dest
087B  01D7     CLRF product
087C  0022     MOVLB 0x2
087D  0855     MOVF 0x55, W
087E  0020     MOVLB 0x0
087F  07D6     ADDWF dest, F
0880  1803     BTFSC STATUS, 0x0
0881  0AD7     INCF product, F
0882  3003     MOVLW 0x3
0883  05D6     ANDWF dest, F
0884  302D     MOVLW 0x2D
0885  01D7     CLRF product
0886  00D8     MOVWF off
0887  01D9     CLRF x
0888  221B     CALL 0x21B
0889  3188     MOVLP 0x8
088A  303C     MOVLW 0x3C
088B  0021     MOVLB 0x1
088C  00E1     MOVWF 0x61
088D  3023     MOVLW 0x23
088E  00E2     MOVWF 0x62
088F  0020     MOVLB 0x0
0890  0856     MOVF dest, W
0891  0021     MOVLB 0x1
0892  0761     ADDWF 0x61, W
0893  0084     MOVWF FSR0L
0894  0020     MOVLB 0x0
0895  0857     MOVF product, W
0896  0021     MOVLB 0x1
0897  3D62     ADDWFC 0x62, W
0898  0085     MOVWF FSR0H
0899  302D     MOVLW 0x2D
089A  00FF     MOVWF 0x7F
089B  0016     MOVIW FSR1++
089C  001A     MOVWI FSR0++
089D  0BFF     DECFSZ 0x7F, F
089E  289B     GOTO 0x9B
089F  0022     MOVLB 0x2
08A0  0AD5     INCF 0x55, F
51:                            if(Status.State == 'R') {
08A1  0852     MOVF 0x52, W
08A2  3A52     XORLW 0x52
08A3  1D03     BTFSS STATUS, 0x2
08A4  28BE     GOTO 0xBE
52:                                AsicPreCalc(&WorkQue[WorkNow]);
08A5  303C     MOVLW 0x3C
08A6  26C3     CALL 0x6C3
08A7  3188     MOVLP 0x8
08A8  269B     CALL 0x69B
08A9  3188     MOVLP 0x8
08AA  221B     CALL 0x21B
08AB  3188     MOVLP 0x8
08AC  0856     MOVF dest, W
08AD  0021     MOVLB 0x1
08AE  00E1     MOVWF 0x61
08AF  0020     MOVLB 0x0
08B0  0857     MOVF product, W
08B1  0021     MOVLB 0x1
08B2  00E2     MOVWF 0x62
08B3  0861     MOVF 0x61, W
08B4  0020     MOVLB 0x0
08B5  07E6     ADDWF work, F
08B6  0021     MOVLB 0x1
08B7  0862     MOVF 0x62, W
08B8  0020     MOVLB 0x0
08B9  3DE7     ADDWFC n, F
08BA  238B     CALL 0x38B
08BB  3188     MOVLP 0x8
53:                                AsicPushWork();
08BC  2255     CALL 0x255
08BD  3188     MOVLP 0x8
54:                            }
55:                        }
56:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
08BE  0021     MOVLB 0x1
08BF  26F7     CALL 0x6F7
08C0  3188     MOVLP 0x8
08C1  3052     MOVLW 0x52
08C2  00DE     MOVWF split
08C3  3001     MOVLW 0x1
08C4  00DF     MOVWF handle
08C5  300D     MOVLW 0xD
08C6  00E0     MOVWF count
08C7  21B1     CALL 0x1B1
08C8  3188     MOVLP 0x8
57:                        break;
08C9  29AE     GOTO 0x1AE
58:                    case 'A': // abort work, reply status has hash completed count
59:                        Status.WorkQC = WorkNow = 0;
08CA  01EE     CLRF pBDTEntryEP0OutCurrent
08CB  0022     MOVLB 0x2
08CC  01D5     CLRF 0x55
60:                        Status.State = 'R';
08CD  3052     MOVLW 0x52
08CE  2978     GOTO 0x178
08CF  26F7     CALL 0x6F7
08D0  3188     MOVLP 0x8
61:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
62:                        break;
63:                    case 'I': // return identity 
64:                        SendCmdReply(cmd, (char *)&ID, sizeof(ID));
08D1  30AD     MOVLW 0xAD
08D2  00DE     MOVWF split
08D3  3090     MOVLW 0x90
08D4  00DF     MOVWF handle
08D5  300C     MOVLW 0xC
08D6  00E0     MOVWF count
08D7  21B1     CALL 0x1B1
08D8  3188     MOVLP 0x8
65:                        break;
08D9  29AE     GOTO 0x1AE
08DA  26F1     CALL 0x6F1
08DB  3188     MOVLP 0x8
66:                    case 'S': // return status 
67:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status)); 
68:                        break;
69:                    case 'C': // set config values 
70:                        if( *(WORD *)&cmd[2] != 0 ) {
08DC  0016     MOVIW FSR1++
08DD  0401     IORWF INDF1, W
08DE  1903     BTFSC STATUS, 0x2
08DF  294D     GOTO 0x14D
71:                            Cfg = *(WORKCFG *)(cmd+2);
08E0  0866     MOVF work, W
08E1  3E02     ADDLW 0x2
08E2  0086     MOVWF FSR1L
08E3  3002     MOVLW 0x2
08E4  0087     MOVWF FSR1H
08E5  3067     MOVLW 0x67
08E6  0084     MOVWF FSR0L
08E7  3001     MOVLW 0x1
08E8  0085     MOVWF FSR0H
08E9  3006     MOVLW 0x6
08EA  00FF     MOVWF 0x7F
08EB  0016     MOVIW FSR1++
08EC  001A     MOVWI FSR0++
08ED  0BFF     DECFSZ 0x7F, F
08EE  28EB     GOTO 0xEB
72:                            if(Cfg.HashClock < MIN_HASH_CLOCK)
08EF  3000     MOVLW 0x0
08F0  0022     MOVLB 0x2
08F1  0268     SUBWF i_1089, W
08F2  3080     MOVLW 0x80
08F3  1903     BTFSC STATUS, 0x2
08F4  0267     SUBWF n, W
08F5  1803     BTFSC STATUS, 0x0
08F6  28FA     GOTO 0xFA
73:                                Cfg.HashClock = MIN_HASH_CLOCK;
08F7  3080     MOVLW 0x80
08F8  00E7     MOVWF n
08F9  01E8     CLRF i_1089
74:                            if(Cfg.HashClock <= HALF_HASH_CLOCK && Cfg.HashClock >= MAX_HASH_CLOCK/2)
08FA  3000     MOVLW 0x0
08FB  0268     SUBWF i_1089, W
08FC  30FB     MOVLW 0xFB
08FD  1903     BTFSC STATUS, 0x2
08FE  0267     SUBWF n, W
08FF  1803     BTFSC STATUS, 0x0
0900  290B     GOTO 0x10B
0901  3000     MOVLW 0x0
0902  0268     SUBWF i_1089, W
0903  30E1     MOVLW 0xE1
0904  1903     BTFSC STATUS, 0x2
0905  0267     SUBWF n, W
0906  1C03     BTFSS STATUS, 0x0
0907  290B     GOTO 0x10B
75:                                Cfg.HashClock = MAX_HASH_CLOCK/2-1;
0908  30E0     MOVLW 0xE0
0909  00E7     MOVWF n
090A  01E8     CLRF i_1089
76:                            if(Cfg.HashClock >= MAX_HASH_CLOCK)
090B  3001     MOVLW 0x1
090C  0268     SUBWF i_1089, W
090D  30C2     MOVLW 0xC2
090E  1903     BTFSC STATUS, 0x2
090F  0267     SUBWF n, W
0910  1C03     BTFSS STATUS, 0x0
0911  2916     GOTO 0x116
77:                                Cfg.HashClock = MAX_HASH_CLOCK-1;
0912  30C1     MOVLW 0xC1
0913  00E7     MOVWF n
0914  3001     MOVLW 0x1
0915  00E8     MOVWF i_1089
78:                            if(Cfg.HashClock <= HALF_HASH_CLOCK)
0916  3000     MOVLW 0x0
0917  0268     SUBWF i_1089, W
0918  30FB     MOVLW 0xFB
0919  1903     BTFSC STATUS, 0x2
091A  0267     SUBWF n, W
0921  1803     BTFSC STATUS, 0x0
0922  292A     GOTO 0x12A
79:                                ClockCfg[0] = (((DWORD)Cfg.HashClock*2) << 18) | CLOCK_HALF_CHG;
091B  0867     MOVF n, W
091C  00DF     MOVWF handle
091D  0868     MOVF i_1089, W
091E  00E0     MOVWF count
091F  01E1     CLRF 0x61
0920  01E2     CLRF 0x62
0923  3013     MOVLW 0x13
0924  2708     CALL 0x708
0925  3188     MOVLP 0x8
0926  0B89     DECFSZ WREG, F
0927  2924     GOTO 0x124
0928  3017     MOVLW 0x17
0929  2930     GOTO 0x130
80:                            else
81:                                ClockCfg[0] = ((DWORD)Cfg.HashClock << 18) | CLOCK_LOW_CHG;
092A  3012     MOVLW 0x12
092B  2708     CALL 0x708
092C  3188     MOVLP 0x8
092D  0B89     DECFSZ WREG, F
092E  292B     GOTO 0x12B
092F  3007     MOVLW 0x7
0930  04DF     IORWF handle, F
0931  3000     MOVLW 0x0
0932  04E0     IORWF count, F
0933  3003     MOVLW 0x3
0934  04E1     IORWF 0x61, F
0935  3000     MOVLW 0x0
0936  04E2     IORWF 0x62, F
82:                            HashTime = 256 - ((WORD)TICK_TOTAL/Cfg.HashClock);
0937  0868     MOVF i_1089, W
0938  0020     MOVLB 0x0
0939  00D7     MOVWF product
093A  0022     MOVLB 0x2
093B  0867     MOVF n, W
093C  0020     MOVLB 0x0
093D  00D6     MOVWF dest
093E  3004     MOVLW 0x4
093F  00D8     MOVWF off
0940  3030     MOVLW 0x30
0941  00D9     MOVWF x
0942  2230     CALL 0x230
0943  3188     MOVLP 0x8
0944  0856     MOVF dest, W
0945  3C00     SUBLW 0x0
0946  0022     MOVLB 0x2
0947  00D1     MOVWF 0x51
83:                            PWM1DCH = Cfg.FanTarget;
0948  086B     MOVF 0x6B, W
0949  002C     MOVLB 0xC
094A  0092     MOVWF PIR2
84:                            Status.ErrorCount = 0;
094B  0022     MOVLB 0x2
094C  01D9     CLRF x
85:                        }
86:                        SendCmdReply(cmd, (char *)&Cfg, sizeof(Cfg));
094D  0021     MOVLB 0x1
094E  26F7     CALL 0x6F7
094F  3188     MOVLP 0x8
0950  3067     MOVLW 0x67
0951  00DE     MOVWF split
0952  3001     MOVLW 0x1
0953  00DF     MOVWF handle
0954  3006     MOVLW 0x6
0955  00E0     MOVWF count
0956  21B1     CALL 0x1B1
0957  3188     MOVLP 0x8
87:                        break;
0958  29AE     GOTO 0x1AE
0959  26F1     CALL 0x6F1
095A  3188     MOVLP 0x8
88:                    case 'E': // enable/disable work
89:                        HASH_CLK_EN = (cmd[2] == '1');
095B  0801     MOVF INDF1, W
095C  3A31     XORLW 0x31
095D  3000     MOVLW 0x0
095E  1903     BTFSC STATUS, 0x2
095F  3001     MOVLW 0x1
0960  00E1     MOVWF 0x61
0961  0EE1     SWAPF 0x61, F
0962  0022     MOVLB 0x2
0963  080C     MOVF PORTA, W
0964  0021     MOVLB 0x1
0965  0661     XORWF 0x61, W
0966  39EF     ANDLW 0xEF
0967  0661     XORWF 0x61, W
0968  0022     MOVLB 0x2
0969  008C     MOVWF PORTA
90:                        Status.State = (cmd[2] == '1') ? 'R' : 'D';
096A  0021     MOVLB 0x1
096B  0866     MOVF work, W
096C  3E02     ADDLW 0x2
096D  0086     MOVWF FSR1L
096E  0801     MOVF INDF1, W
096F  3A31     XORLW 0x31
0970  1903     BTFSC STATUS, 0x2
0971  2974     GOTO 0x174
0972  3044     MOVLW 0x44
0973  2975     GOTO 0x175
0974  3052     MOVLW 0x52
0975  00E3     MOVWF 0x63
0976  01E4     CLRF 0x64
0977  0022     MOVLB 0x2
0978  00D2     MOVWF 0x52
0979  28BE     GOTO 0xBE
91:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
92:                        break;
93:                    case 'F': // enter firmware update mode
94:                        for(BYTE n = 0; n < sizeof(FwPwd); n++)
097A  01E5     CLRF 0x65
098A  300E     MOVLW 0xE
098B  0AE5     INCF 0x65, F
098C  0265     SUBWF 0x65, W
098D  1C03     BTFSS STATUS, 0x0
098E  297B     GOTO 0x17B
95:            				if(FwPwd[n] != cmd[2+n])
097B  0865     MOVF 0x65, W
097C  0766     ADDWF work, W
097D  00E1     MOVWF 0x61
097E  3E02     ADDLW 0x2
097F  0086     MOVWF FSR1L
0980  3002     MOVLW 0x2
0981  0087     MOVWF FSR1H
0982  0865     MOVF 0x65, W
0983  3E01     ADDLW 0x1
0984  3190     MOVLP 0x10
0985  000A     CALLW
0986  3189     MOVLP 0x9
0987  0601     XORWF INDF1, W
0988  1D03     BTFSS STATUS, 0x2
0989  0008     RETURN
96:            					return;
97:                        UpdateFirmware();
098F  3180     MOVLP 0x0
0990  2014     CALL 0x14
0991  3188     MOVLP 0x8
98:                        break;
0992  29AE     GOTO 0x1AE
99:                    default:
100:                       break;
101:                   }
102:               LED_On();
09AE  0022     MOVLB 0x2
09AF  168C     BSF PORTA, 0x5
103:           }
09B0  0008     RETURN
104:           
105:           void AsicPushWork(void)
106:           {
107:               Status.WorkID = WorkQue[WorkNow].WorkID;
0A57  221B     CALL 0x21B
0A58  3188     MOVLP 0x8
0A59  303C     MOVLW 0x3C
0A5A  00E8     MOVWF i_1089
0A5B  3023     MOVLW 0x23
0A5C  00E9     MOVWF i
0A5D  0856     MOVF dest, W
0A5E  0768     ADDWF i_1089, W
0A5F  0086     MOVWF FSR1L
0A60  0857     MOVF product, W
0A61  3D69     ADDWFC i, W
0A62  0087     MOVWF FSR1H
0A63  0801     MOVF INDF1, W
0A64  0022     MOVLB 0x2
0A65  00D6     MOVWF dest
108:               SendAsicData(&WorkQue[WorkNow], DATA_SPLIT);
0A66  303C     MOVLW 0x3C
0A67  0020     MOVLB 0x0
0A68  00DC     MOVWF work
0A69  3023     MOVLW 0x23
0A6A  00DD     MOVWF y
0A6B  269B     CALL 0x69B
0A6C  3188     MOVLP 0x8
0A6D  221B     CALL 0x21B
0A6E  3188     MOVLP 0x8
0A6F  2702     CALL 0x702
0A70  3188     MOVLP 0x8
0A71  07DC     ADDWF work, F
0A72  0869     MOVF i, W
0A73  3DDD     ADDWFC y, F
0A74  3050     MOVLW 0x50
0A75  00DE     MOVWF split
0A76  2295     CALL 0x295
0A77  3188     MOVLP 0x8
109:               WorkNow = (WorkNow+1) & WORKMASK;
0A78  0021     MOVLB 0x1
0A79  3003     MOVLW 0x3
0A7A  0AEE     INCF pBDTEntryEP0OutCurrent, F
0A7B  05EE     ANDWF pBDTEntryEP0OutCurrent, F
110:               Status.HashCount = 0;
0A7C  0022     MOVLB 0x2
0A7D  01DA     CLRF i_718
0A7E  01DB     CLRF i
111:               TMR0 = HashTime;
0A7F  0851     MOVF 0x51, W
0A80  0020     MOVLB 0x0
0A81  0095     MOVWF TMR0
112:               Status.State ='W';
0A82  3057     MOVLW 0x57
0A83  0022     MOVLB 0x2
0A84  00D2     MOVWF 0x52
113:               if(--Status.WorkQC > 0)
0A85  03D5     DECF 0x55, F
0A86  1903     BTFSC STATUS, 0x2
0A87  0008     RETURN
114:                   AsicPreCalc(&WorkQue[WorkNow]);
0A88  303C     MOVLW 0x3C
0A89  26C3     CALL 0x6C3
0A8A  3188     MOVLP 0x8
0A8B  269B     CALL 0x69B
0A8C  3188     MOVLP 0x8
0A8D  221B     CALL 0x21B
0A8E  3188     MOVLP 0x8
0A8F  2702     CALL 0x702
0A90  3188     MOVLP 0x8
0A91  07E6     ADDWF work, F
0A92  0869     MOVF i, W
0A93  3DE7     ADDWFC n, F
0A94  2B8B     GOTO 0x38B
115:           }
0A95  138B     BCF INTCON, 0x7
116:           
117:           // Housekeeping functons
118:           
119:           void CheckFanSpeed(void)
120:           {
121:               if(PWM1OE == 0) { // failed read attempt, abort
122:                   FAN_PWM = 0;
123:                   PWM1OE = 1;
124:                   Status.FanSpeed = 0;
125:               }
126:               else if( IOCAF3 == 1) { // only check if NegEdge else no Tach present
127:                   IOCAF3 = 0; // reset Tach detection
128:                   FAN_PWM = 1; // force PWM fan output to ON
129:                   PWM1OE=0;
130:                   T1CONbits.TMR1CS = 0;
131:                   T1CONbits.T1CKPS = 3;
132:                   T1CONbits.TMR1ON = TMR1GE = 1;
133:                   T1GCONbits.T1GPOL = 1;
134:                   T1GCONbits.T1GSS = T1GCONbits.T1GTM = 0;
135:                   T1GSPM = 1;
136:                   TMR1H = TMR1L = 0;
137:                   TMR1ON = 1;
138:                   TMR1GIE = TMR1IE = 1;
139:                   T1GCONbits.T1GGO_nDONE = 1;
140:               }
141:           }
142:           
143:           void DetectAsics(void)
144:           {
145:           /* disabled for now, not fully worked out yet
146:              const WORKTASK TestWork = { 0xFF, GOOD_MIDSTATE, GOOD_DATA };
147:               const DWORD GoodNonce = GOOD_NONCE;
148:               const DWORD StartNonce = (GOOD_NONCE - DETECT_DELAY_COUNT);
149:               BankSize = 8;
150:               Status.ChipCount = 0;
151:               for(BYTE x = 0; x < BankSize; x++)
152:                   NonceRanges[x] = StartNonce;
153:               WorkQue[0] = TestWork;
154:               AsicPreCalc(&WorkQue[0]);
155:               
156:               //SendAsicData(&WorkQue[0], (StartNonce & 0x80000000) ? DATA_ONE : DATA_ZERO);
157:               // wait for "push work time" for results to return and be counted*/
158:               
159:               Status.ChipCount = CHIPS; // just for testing
0F4C  3004     MOVLW 0x4
0F4D  0022     MOVLB 0x2
0F4E  00D3     MOVWF 0x53
160:               
161:               // pre-calc nonce range values
162:               BankSize = (Status.ChipCount+1)/2;
0F4F  3002     MOVLW 0x2
0F50  0020     MOVLB 0x0
0F51  00D6     MOVWF dest
0F52  01D7     CLRF product
0F53  0022     MOVLB 0x2
0F54  0853     MOVF 0x53, W
0F55  3E01     ADDLW 0x1
0F56  0020     MOVLB 0x0
0F57  00D8     MOVWF off
0F58  3000     MOVLW 0x0
0F59  1803     BTFSC STATUS, 0x0
0F5A  3001     MOVLW 0x1
0F5B  00D9     MOVWF x
0F5C  27C0     CALL 0x7C0
0F5D  3188     MOVLP 0x8
0F5E  0856     MOVF dest, W
0F5F  0022     MOVLB 0x2
0F60  00ED     MOVWF controlTransferState
163:               Status.MaxCount = WORK_TICKS / BankSize;
0F61  0020     MOVLB 0x0
0F62  00D6     MOVWF dest
0F63  3040     MOVLW 0x40
0F64  01D7     CLRF product
0F65  01D8     CLRF off
0F66  00D9     MOVWF x
0F67  27C0     CALL 0x7C0
0F68  3188     MOVLP 0x8
0F69  0857     MOVF product, W
0F6A  0022     MOVLB 0x2
0F6B  00DD     MOVWF y
0F6C  0020     MOVLB 0x0
0F6D  0856     MOVF dest, W
0F6E  0022     MOVLB 0x2
0F6F  00DC     MOVWF work
164:               NonceRanges[0] = 0;
0F70  0023     MOVLB 0x3
0F71  01A0     CLRF BDT
0F72  01A1     CLRF 0x21
0F73  01A2     CLRF 0x22
0F74  01A3     CLRF 0x23
165:               for(BYTE x = 1; x < BankSize; x++)
0F75  0020     MOVLB 0x0
0F76  01E6     CLRF work
0F77  0AE6     INCF work, F
0F78  0022     MOVLB 0x2
0F79  086D     MOVF controlTransferState, W
0F7A  0020     MOVLB 0x0
0F7B  0266     SUBWF work, W
0F7C  1803     BTFSC STATUS, 0x0
0F7D  2FBA     GOTO 0x7BA
0FB9  2F77     GOTO 0x777
166:                   NonceRanges[x] = NonceRanges[x-1] + 2*BankRanges[BankSize-1];  // single bank, double range size
0F7E  0866     MOVF work, W
0F7F  0709     ADDWF WREG, W
0F80  0709     ADDWF WREG, W
0F81  3E9C     ADDLW 0x9C
0F82  0086     MOVWF FSR1L
0F83  3001     MOVLW 0x1
0F84  0087     MOVWF FSR1H
0F85  3F40     MOVIW [0]FSR1
0F86  00DE     MOVWF split
0F87  3F41     MOVIW [1]FSR1
0F88  00DF     MOVWF handle
0F89  3F42     MOVIW [2]FSR1
0F8A  00E0     MOVWF count
0F8B  3F43     MOVIW [3]FSR1
0F8C  00E1     MOVWF 0x61
0F8D  0022     MOVLB 0x2
0F8E  086D     MOVF controlTransferState, W
0F8F  0709     ADDWF WREG, W
0F90  0709     ADDWF WREG, W
0F91  3E1C     ADDLW 0x1C
0F92  0086     MOVWF FSR1L
0F93  3003     MOVLW 0x3
0F94  0087     MOVWF FSR1H
0F95  3F40     MOVIW [0]FSR1
0F96  0020     MOVLB 0x0
0F97  00E2     MOVWF 0x62
0F98  3F41     MOVIW [1]FSR1
0F99  00E3     MOVWF 0x63
0F9A  3F42     MOVIW [2]FSR1
0F9B  00E4     MOVWF 0x64
0F9C  3F43     MOVIW [3]FSR1
0F9D  00E5     MOVWF 0x65
0F9E  35E2     LSLF 0x62, F
0F9F  0DE3     RLF 0x63, F
0FA0  0DE4     RLF 0x64, F
0FA1  0DE5     RLF 0x65, F
0FA2  0862     MOVF 0x62, W
0FA3  07DE     ADDWF split, F
0FA4  0863     MOVF 0x63, W
0FA5  3DDF     ADDWFC handle, F
0FA6  0864     MOVF 0x64, W
0FA7  3DE0     ADDWFC count, F
0FA8  0865     MOVF 0x65, W
0FA9  3DE1     ADDWFC 0x61, F
0FAA  0866     MOVF work, W
0FAB  0709     ADDWF WREG, W
0FAC  0709     ADDWF WREG, W
0FAD  3EA0     ADDLW 0xA0
0FAE  0086     MOVWF FSR1L
0FAF  3001     MOVLW 0x1
0FB0  0087     MOVWF FSR1H
0FB1  085E     MOVF split, W
0FB2  3FC0     MOVWI [0]FSR1
0FB3  085F     MOVF handle, W
0FB4  3FC1     MOVWI [1]FSR1
0FB5  0860     MOVF count, W
0FB6  3FC2     MOVWI [2]FSR1
0FB7  0861     MOVF 0x61, W
0FB8  3FC3     MOVWI [3]FSR1
167:               Status.State ='R';
0FBA  3052     MOVLW 0x52
0FBB  0022     MOVLB 0x2
0FBC  00D2     MOVWF 0x52
168:               Status.HashCount = 0;
0FBD  01DA     CLRF i_718
0FBE  01DB     CLRF i
169:           }
0FBF  0008     RETURN
170:           
171:           // ISR functions
172:           
173:           void WorkTick(void)
174:           {
175:               TMR0 += HashTime;
0DDB  0022     MOVLB 0x2
0DDC  0851     MOVF 0x51, W
0DDD  0020     MOVLB 0x0
0DDE  0795     ADDWF TMR0, F
176:               TMR0IF = 0;
0DDF  110B     BCF INTCON, 0x2
177:               if(RCSTAbits.SPEN == 0) {
0DE0  0023     MOVLB 0x3
0DE1  1B9D     BTFSC 0x1D, 0x7
0DE2  2DE6     GOTO 0x5E6
178:                   RCSTAbits.SPEN = 1; // renable Rx
0DE3  179D     BSF 0x1D, 0x7
179:                   ResultQC = 0;       // resync Rx
0DE4  0022     MOVLB 0x2
0DE5  01B2     CLRF 0x32
180:               }
181:               if((Status.State == 'W') && (++Status.HashCount == Status.MaxCount)) {
0DE6  0022     MOVLB 0x2
0DE7  0852     MOVF 0x52, W
0DE8  3A57     XORLW 0x57
0DE9  1D03     BTFSS STATUS, 0x2
0DEA  2E04     GOTO 0x604
0DEB  305A     MOVLW 0x5A
0DEC  0086     MOVWF FSR1L
0DED  3001     MOVLW 0x1
0DEE  0087     MOVWF FSR1H
0DEF  0781     ADDWF INDF1, F
0DF0  3141     ADDFSR 1, 1
0DF1  1803     BTFSC STATUS, 0x0
0DF2  0A81     INCF INDF1, F
0DF3  317F     ADDFSR 1, -1
0DF4  3F40     MOVIW [0]FSR1
0DF5  065C     XORWF work, W
0DF6  1D03     BTFSS STATUS, 0x2
0DF7  2DFA     GOTO 0x5FA
0DF8  3F41     MOVIW [1]FSR1
0DF9  065D     XORWF y, W
0DFA  1D03     BTFSS STATUS, 0x2
0DFB  2E04     GOTO 0x604
182:                   if(Status.WorkQC > 0) {
0DFC  0855     MOVF 0x55, W
0DFD  1903     BTFSC STATUS, 0x2
0DFE  2E02     GOTO 0x602
183:                       Status.State = 'P'; // set state to push data and do asap
0DFF  3050     MOVLW 0x50
0E00  00D2     MOVWF 0x52
0E01  0008     RETURN
184:                       return;
185:                   }
186:                   else
187:                       Status.State = 'R';
0E02  3052     MOVLW 0x52
0E03  00D2     MOVWF 0x52
188:               }
189:           
190:              if(++SlowTick == 0) {
0E04  0FB4     INCFSZ 0x34, F
0E05  0008     RETURN
191:                   LED_Off();
0E06  128C     BCF PORTA, 0x5
192:                   Status.Temp = ADRESH;
0E07  0021     MOVLB 0x1
0E08  081C     MOVF T2CON, W
0E09  0022     MOVLB 0x2
0E0A  00D7     MOVWF product
193:                   // todo: adjust fan speed for target temperature
194:                   ADCON0bits.GO_nDONE = 1;
0E0B  0021     MOVLB 0x1
0E0C  149D     BSF 0x1D, 0x1
195:                   //CheckFanSpeed();
196:               }
197:              //if((SlowTick & 3) == 0)
198:              //I2CPoll();
199:           }
0E0D  0008     RETURN
200:           
201:           void ResultRx(void)
202:           {
203:               BYTE TimeOut = 0;
1733  01FC     CLRF TimeOut
204:               ResultQC = 0;
1734  0022     MOVLB 0x2
1735  01B2     CLRF 0x32
205:               while(ResultQC < 4) {
1736  3004     MOVLW 0x4
1737  0022     MOVLB 0x2
1738  0232     SUBWF 0x32, W
1739  1803     BTFSC STATUS, 0x0
173A  2F5D     GOTO 0x75D
206:           
207:                   if(RCIF) {
173B  0020     MOVLB 0x0
173C  1E91     BTFSS PIR1, 0x5
173D  2F4A     GOTO 0x74A
208:                       ResultQue[2+ResultQC++] = RCREG;
173E  0022     MOVLB 0x2
173F  0832     MOVF 0x32, W
1740  3E44     ADDLW 0x44
1741  0086     MOVWF FSR1L
1742  3001     MOVLW 0x1
1743  0087     MOVWF FSR1H
1744  0023     MOVLB 0x3
1745  0819     MOVF T1GCON, W
1746  0081     MOVWF INDF1
1747  0022     MOVLB 0x2
1748  0AB2     INCF 0x32, F
209:                       TimeOut = 0;
1749  01FC     CLRF TimeOut
210:                   }
211:                   if(TimeOut++ > 32 ) {
174A  3022     MOVLW 0x22
174B  0AFC     INCF TimeOut, F
174C  027C     SUBWF TimeOut, W
174D  1C03     BTFSS STATUS, 0x0
174E  2F52     GOTO 0x752
212:                       Status.Noise++;
174F  0022     MOVLB 0x2
1750  0ADE     INCF split, F
213:                       goto outrx;
1751  2F70     GOTO 0x770
214:                   }
215:           
216:                   if(RCSTAbits.OERR) { // error occured, either overun or no more bits
1752  0023     MOVLB 0x3
1753  1C9D     BTFSS 0x1D, 0x1
1754  2F36     GOTO 0x736
217:                       if(Status.State == 'W')
1755  0022     MOVLB 0x2
1756  0852     MOVF 0x52, W
1757  3A57     XORLW 0x57
1758  1903     BTFSC STATUS, 0x2
218:                           Status.ErrorCount++;
1759  0AD9     INCF x, F
219:                       RCSTAbits.SPEN = 0; // clear error, don't re-enable until next tick TMR0, 21.3uS
175A  0023     MOVLB 0x3
175B  139D     BCF 0x1D, 0x7
220:                       goto outrx;
175C  2F70     GOTO 0x770
221:                   }
222:               }
223:               
224:               if(Status.State == 'W') {
175D  0852     MOVF 0x52, W
175E  3A57     XORLW 0x57
175F  1D03     BTFSS STATUS, 0x2
1760  2F70     GOTO 0x770
225:                   ResultQue[0] = '=';
1761  303D     MOVLW 0x3D
1762  00C2     MOVWF 0x42
226:                   ResultQue[1] = Status.WorkID;
1763  0856     MOVF dest, W
1764  00C3     MOVWF 0x43
227:                   SendCmdReply(&ResultQue, &ResultQue+1, sizeof(ResultQue)-1);
1765  3042     MOVLW 0x42
1766  00F6     MOVWF cmd
1767  3001     MOVLW 0x1
1768  00F7     MOVWF 0x77
1769  3043     MOVLW 0x43
176A  00F8     MOVWF data
176B  3001     MOVLW 0x1
176C  00F9     MOVWF 0x79
176D  3007     MOVLW 0x7
176E  00FA     MOVWF count
176F  2776     CALL 0x776
228:               }
229:           outrx:
230:               RCSTAbits.SPEN = 0; RCSTAbits.SPEN = 1;
1770  0023     MOVLB 0x3
1771  139D     BCF 0x1D, 0x7
1772  179D     BSF 0x1D, 0x7
231:               IOCBF = 0;
1773  0027     MOVLB 0x7
1774  0196     CLRF TMR1L
232:           }
1775  0008     RETURN
233:           
234:           void UpdateFanSpeed(void)
235:           {
236:               TMR1GIF = TMR1IF = 0;
237:               IOCAF3 = 0; // skip one cycle
238:               TMR1ON = 0;
239:               Status.FanSpeed = TMR1H; // rollover below 330 rpm, not measured
240:               FAN_PWM = 0; // re-enable PWM fan output
241:               PWM1OE=1;
242:           }
243:           
244:           // Init functions
245:           
246:           void InitFAN(void)
247:           {
248:               FAN_TRIS = 1;
0F23  168E     BSF PORTC, 0x5
249:               PWM1CON = 0;
0F24  002C     MOVLB 0xC
0F25  0193     CLRF 0x13
250:               PR2 = 0xFF;
0F26  30FF     MOVLW 0xFF
0F27  0020     MOVLB 0x0
0F28  009B     MOVWF PR2
251:               PWM1CON = 0xC0;
0F29  30C0     MOVLW 0xC0
0F2A  002C     MOVLB 0xC
0F2B  0093     MOVWF 0x13
252:               PWM1DCH = DEFAULT_FAN_TARGET;
0F2C  30E6     MOVLW 0xE6
0F2D  0092     MOVWF PIR2
253:               PWM1DCL = 0;
0F2E  0191     CLRF PIR1
254:               TMR2IF = 0;
0F2F  0020     MOVLB 0x0
0F30  1091     BCF PIR1, 0x1
255:               T2CONbits.T2CKPS = 1;
0F31  081C     MOVF T2CON, W
0F32  39FC     ANDLW 0xFC
0F33  3801     IORLW 0x1
0F34  009C     MOVWF T2CON
256:               TMR2ON = 1;
0F35  151C     BSF T2CON, 0x2
257:               FAN_TRIS = 0;
0F36  0021     MOVLB 0x1
0F37  128E     BCF PORTC, 0x5
258:               PWM1OE=1;
0F38  002C     MOVLB 0xC
0F39  1713     BSF 0x13, 0x6
259:           
260:               // for Fan Tach reading
261:               //T1GSEL = 1;
262:               //IOCAN3 = 1;
263:               //IOCAF3 = 0;
264:           }
0F3A  0008     RETURN
265:           
266:           void InitTempSensor(void)
267:           { 
268:               THERM_TRIS=1;
0E1A  0021     MOVLB 0x1
0E1B  150E     BSF PORTC, 0x2
269:               //TEMP_INIT;
270:               //FVREN = 1;
271:               ADCON0bits.CHS = TEMP_THERMISTOR;
0E1C  081D     MOVF 0x1D, W
0E1D  3983     ANDLW 0x83
0E1E  3818     IORLW 0x18
0E1F  009D     MOVWF 0x1D
272:               ADCON0bits.ADON = 1;
0E20  141D     BSF 0x1D, 0x0
273:               ADCON1bits.ADFM = 0;
0E21  139E     BCF 0x1E, 0x7
274:               ADCON1bits.ADCS = 6;
0E22  081E     MOVF 0x1E, W
0E23  398F     ANDLW 0x8F
0E24  3860     IORLW 0x60
0E25  009E     MOVWF 0x1E
275:               ADCON1bits.ADPREF = 0;
0E26  30FC     MOVLW 0xFC
0E27  059E     ANDWF 0x1E, F
276:               ADCON2bits.TRIGSEL = 0;
0E28  308F     MOVLW 0x8F
0E29  059F     ANDWF 0x1F, F
277:           }
0E2A  0008     RETURN
278:           
279:           void InitWorkTick(void)
280:           {
281:               TMR0CS = 0;
0F0D  0021     MOVLB 0x1
0F0E  1295     BCF TMR0, 0x5
282:               OPTION_REGbits.PSA = 0;
0F0F  1195     BCF TMR0, 0x3
283:               OPTION_REGbits.PS = 7;
0F10  3007     MOVLW 0x7
0F11  0495     IORWF TMR0, F
284:               TMR0 = HashTime;
0F12  0022     MOVLB 0x2
0F13  0851     MOVF 0x51, W
0F14  0020     MOVLB 0x0
0F15  0095     MOVWF TMR0
285:               //TMR0IE = 1;
286:           
287:               HASH_TRIS_0P = 0;
0F16  0021     MOVLB 0x1
0F17  138E     BCF PORTC, 0x7
288:               HASH_TRIS_0N = 0;
0F18  130E     BCF PORTC, 0x6
289:               HASH_TRIS_1P = 0;
0F19  120E     BCF PORTC, 0x4
290:               HASH_TRIS_1N = 0;
0F1A  118E     BCF PORTC, 0x3
291:               HASH_IDLE();
0F1B  30D8     MOVLW 0xD8
0F1C  0022     MOVLB 0x2
0F1D  008E     MOVWF PORTC
292:               HASH_CLK_TRIS = 0;
0F1E  0021     MOVLB 0x1
0F1F  120C     BCF PORTA, 0x4
293:               HASH_CLK_EN = 1;
0F20  0022     MOVLB 0x2
0F21  160C     BSF PORTA, 0x4
294:           }
0F22  0008     RETURN
295:           
296:           void InitResultRx(void)
297:           {
298:               ResultQC = 0;
0F3B  01B2     CLRF 0x32
299:               TXSTAbits.SYNC = 1;
0F3C  0023     MOVLB 0x3
0F3D  161E     BSF 0x1E, 0x4
300:               RCSTAbits.SPEN = 1;
0F3E  179D     BSF 0x1D, 0x7
301:               TXSTAbits.CSRC = 0;
0F3F  139E     BCF 0x1E, 0x7
302:               BAUDCONbits.SCKP = 0;
0F40  121F     BCF 0x1F, 0x4
303:               ANSELBbits.ANSB5 = 0;
0F41  128D     BCF PORTB, 0x5
304:               //PIE1bits.RCIE = 1;
305:               IOCBPbits.IOCBP7 = 1;
0F42  0027     MOVLB 0x7
0F43  1794     BSF 0x14, 0x7
306:               INTCONbits.IOCIE = 1;
0F44  158B     BSF INTCON, 0x3
307:               IOCBF = 0;
0F45  0196     CLRF TMR1L
308:               //INTCONbits.PEIE = 1;
309:               INTCONbits.GIE = 1;
0F46  178B     BSF INTCON, 0x7
310:               RCSTAbits.CREN = 1;
0F47  0023     MOVLB 0x3
0F48  161D     BSF 0x1D, 0x4
311:               RCREG = 0xFF;
0F49  30FF     MOVLW 0xFF
0F4A  0099     MOVWF T1GCON
312:           }
0F4B  0008     RETURN
---  /home/chris/Dev/klondike/firmware/Klondike.X/fwup.c  -----------------------------------------------
1:             /********
2:              * Klondike ASIC Miner - fwup.c - firmware update handling 
3:              * 
4:              * (C) Copyright 2013 Chris Savery. 
5:              *
6:              * This program is free software: you can redistribute it and/or modify
7:              * it under the terms of the GNU General Public License as published by
8:              * the Free Software Foundation, either version 3 of the License, or
9:              * (at your option) any later version.
10:             *
11:             * This program is distributed in the hope that it will be useful,
12:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
13:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14:             * GNU General Public License for more details.
15:             *
16:             * You should have received a copy of the GNU General Public License
17:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
18:             *
19:             */
20:            #include "GenericTypeDefs.h"
21:            #include "Compiler.h"
22:            #include <xc.h>
23:            #include "USB/usb.h"
24:            #include "USB/usb_function_generic.h"
25:            #include "klondike.h"
26:            
27:            #pragma psect text%%u=lowcode
28:            
29:            extern const IDENTITY ID;
30:            extern WORKTASK WorkQue[MAX_WORK_COUNT];
31:            
32:            extern unsigned char INPacket[USBGEN_EP_SIZE];
33:            extern unsigned char OUTPacket[USBGEN_EP_SIZE];
34:            
35:            extern USB_HANDLE USBGenericOutHandle;
36:            extern USB_HANDLE USBGenericInHandle;
37:            
38:            BYTE *fwbuf;
39:            
40:            void EraseRow(WORD addr)
41:            {
42:            #asm
43:                BCF INTCON,_INTCON_GIE_POSN ; Disable ints so required sequences will execute properly
00E8  138B     BCF INTCON, 0x7
44:                BANKSEL PMADRL              ; Bank 3
00E9  0023     MOVLB 0x3
45:                MOVF EraseRow@addr, W        ; Load initial address
00EA  0856     MOVF dest, W
46:                MOVWF PMADRL
00EB  0091     MOVWF PIR1
47:                MOVF EraseRow@addr+1, W
00EC  0857     MOVF product, W
48:                MOVWF PMADRH
00ED  0092     MOVWF PIR2
49:                BCF PMCON1,_PMCON1_CFGS_POSN ; Not configuration space
00EE  1315     BCF TMR0, 0x6
50:                BSF PMCON1,_PMCON1_FREE_POSN ; Specify an erase operation
00EF  1615     BSF TMR0, 0x4
51:                BSF PMCON1,_PMCON1_WREN_POSN ; Enable writes
00F0  1515     BSF TMR0, 0x2
52:            
53:                MOVLW 55h                   ; Start of required write sequence:
00F1  3055     MOVLW 0x55
54:                MOVWF PMCON2                ; Write 55h
00F2  0096     MOVWF TMR1L
55:                MOVLW 0AAh
00F3  30AA     MOVLW 0xAA
56:                MOVWF PMCON2                ; Write AAh
00F4  0096     MOVWF TMR1L
57:                BSF PMCON1,_PMCON1_WR_POSN  ; Set WR bit to begin write
00F5  1495     BSF TMR0, 0x1
58:                NOP                         ; NOP instructions are forced as processor writes all the program memory write latches simultaneously to program memory.
00F6  0000     NOP
59:                NOP                         ; After NOPs, the processor stalls until the self-write process in complete after write processor continues with 3rd instruction
00F7  0000     NOP
60:            
61:                BCF PMCON1,_PMCON1_WREN_POSN ; Disable writes
00F8  1115     BCF TMR0, 0x2
62:                BSF INTCON,_INTCON_GIE_POSN ; Enable interrupts
00F9  178B     BSF INTCON, 0x7
63:            #endasm
64:            }
00FA  0008     RETURN
65:            
66:            void WriteRow(WORD dest, BYTE off)
67:            {
68:                dest = (dest+off) << 5;
00FB  0858     MOVF off, W
00FC  0756     ADDWF dest, W
00FD  00D9     MOVWF x
00FE  0857     MOVF product, W
00FF  1803     BTFSC STATUS, 0x0
0100  0A57     INCF product, W
0101  00DA     MOVWF i_718
0102  3005     MOVLW 0x5
0103  35D9     LSLF x, F
0104  0DDA     RLF i_718, F
0105  0B89     DECFSZ WREG, F
0106  2903     GOTO 0x103
0107  0859     MOVF x, W
0108  00D6     MOVWF dest
0109  085A     MOVF i_718, W
010A  00D7     MOVWF product
69:                fwbuf = (WORD)&WorkQue + (WORD)off << 6;
010B  0858     MOVF off, W
010C  00D9     MOVWF x
010D  3000     MOVLW 0x0
010E  00DA     MOVWF i_718
010F  0859     MOVF x, W
0110  0022     MOVLB 0x2
0111  00AA     MOVWF 0x2A
0112  0020     MOVLB 0x0
0113  085A     MOVF i_718, W
0114  0022     MOVLB 0x2
0115  00AB     MOVWF 0x2B
0116  303C     MOVLW 0x3C
0117  07AA     ADDWF 0x2A, F
0118  3023     MOVLW 0x23
0119  3DAB     ADDWFC 0x2B, F
011A  3006     MOVLW 0x6
011B  35AA     LSLF 0x2A, F
011C  0DAB     RLF 0x2B, F
011D  0B89     DECFSZ WREG, F
011E  291B     GOTO 0x11B
70:            #asm
71:                BCF INTCON,_INTCON_GIE_POSN ; Disable ints so required sequences will execute properly
011F  138B     BCF INTCON, 0x7
72:                BANKSEL PMADRH              ; Bank 3
0120  0023     MOVLB 0x3
73:                MOVF WriteRow@dest+1,W       ; Load initial code address
0121  0857     MOVF product, W
74:                MOVWF PMADRH
0122  0092     MOVWF PIR2
75:                MOVF WriteRow@dest,W
0123  0856     MOVF dest, W
76:                MOVWF PMADRL
0124  0091     MOVWF PIR1
77:                MOVLW LOW _fwbuf             ; Load initial data address
0125  302A     MOVLW 0x2A
78:                MOVWF FSR0L
0126  0084     MOVWF FSR0L
79:                MOVLW HIGH _fwbuf            
0127  3001     MOVLW 0x1
80:                MOVWF FSR0H
0128  0085     MOVWF FSR0H
81:                BCF PMCON1,_PMCON1_CFGS_POSN ; Not configuration space
0129  1315     BCF TMR0, 0x6
82:                BSF PMCON1,_PMCON1_WREN_POSN ; Enable writes
012A  1515     BSF TMR0, 0x2
83:                BSF PMCON1,_PMCON1_LWLO_POSN ; Only Load Write Latches
012B  1695     BSF TMR0, 0x5
84:            WLOOP
85:                MOVIW FSR0++                
012C  0012     MOVIW FSR0++
86:                MOVWF PMDATL                ; Load first data byte into lower
012D  0093     MOVWF 0x13
87:                MOVIW FSR0++
012E  0012     MOVIW FSR0++
88:                MOVWF PMDATH                ; Load second data byte into upper
012F  0094     MOVWF 0x14
89:            
90:                MOVF PMADRL,W               ; Check if lower bits of address are '00000'
0130  0811     MOVF PIR1, W
91:                XORLW 0x1F                  ; Check if we're on the last of 32 addresses
0131  3A1F     XORLW 0x1F
92:                ANDLW 0x1F
0132  391F     ANDLW 0x1F
93:                BTFSC STATUS,_STATUS_Z_POSN ; Exit if last of 32 words
0133  1903     BTFSC STATUS, 0x2
94:                GOTO START_WRITE
0134  293E     GOTO 0x13E
95:            
96:                MOVLW 55h                   ; Start of required write sequence:
0135  3055     MOVLW 0x55
97:                MOVWF PMCON2                ; Write 55h
0136  0096     MOVWF TMR1L
98:                MOVLW 0AAh
0137  30AA     MOVLW 0xAA
99:                MOVWF PMCON2                ; Write AAh
0138  0096     MOVWF TMR1L
100:               BSF PMCON1,_PMCON1_WR_POSN  ; Set WR bit to begin write
0139  1495     BSF TMR0, 0x1
101:               NOP                         ; NOP instructions are forced as processor
013A  0000     NOP
102:               NOP                         ; loads program memory write latches
013B  0000     NOP
103:           
104:               INCF PMADRL,F               ; Still loading latches Increment address
013C  0A91     INCF PIR1, F
105:               GOTO WLOOP                  ; Write next latches
013D  292C     GOTO 0x12C
106:           
107:           START_WRITE
108:               BCF PMCON1,_PMCON1_LWLO_POSN ; No more loading latches - Actually start Flash program memory write
013E  1295     BCF TMR0, 0x5
109:           
110:               MOVLW 55h                   ; Start of required write sequence:
013F  3055     MOVLW 0x55
111:               MOVWF PMCON2                ; Write 55h
0140  0096     MOVWF TMR1L
112:               MOVLW 0AAh
0141  30AA     MOVLW 0xAA
113:               MOVWF PMCON2                ; Write AAh
0142  0096     MOVWF TMR1L
114:               BSF PMCON1,_PMCON1_WR_POSN  ; Set WR bit to begin write
0143  1495     BSF TMR0, 0x1
115:               NOP                         ; NOP instructions are forced as processor writes all the program memory write latches simultaneously to program memory.
0144  0000     NOP
116:               NOP                         ; After NOPs, the processor stalls until the self-write process in complete after write processor continues with 3rd instruction
0145  0000     NOP
117:           
118:               BCF PMCON1,_PMCON1_WREN_POSN ; Disable writes
0146  1115     BCF TMR0, 0x2
119:               BSF INTCON,_INTCON_GIE_POSN ; Enable interrupts
0147  178B     BSF INTCON, 0x7
120:           #endasm
121:           }
0148  0008     RETURN
122:           
123:           BOOL VerifyRow(WORD dest, BYTE off)
124:           {
125:               dest = (dest+off) << 5;
0149  0858     MOVF off, W
014A  0756     ADDWF dest, W
014B  00D9     MOVWF x
014C  0857     MOVF product, W
014D  1803     BTFSC STATUS, 0x0
014E  0A57     INCF product, W
014F  00DA     MOVWF i_718
0150  3005     MOVLW 0x5
0151  35D9     LSLF x, F
0152  0DDA     RLF i_718, F
0153  0B89     DECFSZ WREG, F
0154  2951     GOTO 0x151
0155  0859     MOVF x, W
0156  00D6     MOVWF dest
0157  085A     MOVF i_718, W
0158  00D7     MOVWF product
126:               fwbuf = (WORD)&WorkQue + (WORD)off << 6;
0159  0858     MOVF off, W
015A  00D9     MOVWF x
015B  3000     MOVLW 0x0
015C  00DA     MOVWF i_718
015D  0859     MOVF x, W
015E  0022     MOVLB 0x2
015F  00AA     MOVWF 0x2A
0160  0020     MOVLB 0x0
0161  085A     MOVF i_718, W
0162  0022     MOVLB 0x2
0163  00AB     MOVWF 0x2B
0164  303C     MOVLW 0x3C
0165  07AA     ADDWF 0x2A, F
0166  3023     MOVLW 0x23
0167  3DAB     ADDWFC 0x2B, F
0168  3006     MOVLW 0x6
0169  35AA     LSLF 0x2A, F
016A  0DAB     RLF 0x2B, F
016B  0B89     DECFSZ WREG, F
016C  2969     GOTO 0x169
127:           #asm
128:               MOVLW 1
016D  3001     MOVLW 0x1
129:               MOVWF ?_VerifyRow 
016E  00D6     MOVWF dest
130:               BANKSEL PMADRL              ; Select Bank for PMCON registers
016F  0023     MOVLB 0x3
131:               MOVLW LOW _fwbuf            ; Load initial data address
0170  302A     MOVLW 0x2A
132:               MOVWF FSR0L
0171  0084     MOVWF FSR0L
133:               MOVLW HIGH _fwbuf           
0172  3001     MOVLW 0x1
134:               MOVWF FSR0H
0173  0085     MOVWF FSR0H
135:               MOVLW VerifyRow@dest          ; Load initial code address
0174  3056     MOVLW 0x56
136:               MOVWF FSR1L
0175  0086     MOVWF FSR1L
137:               MOVLW VerifyRow@dest+1
0176  3057     MOVLW 0x57
138:               MOVWF FSR1H
0177  0087     MOVWF FSR1H
139:           VLOOP
140:               MOVIW FSR1++
0178  0016     MOVIW FSR1++
141:               MOVWF PMADRL                ; Store LSB of address
0179  0091     MOVWF PIR1
142:               MOVIW FSR1++
017A  0016     MOVIW FSR1++
143:               MOVWF PMADRH                ; Store MSB of address
017B  0092     MOVWF PIR2
144:           
145:               BCF PMCON1,_PMCON1_CFGS_POSN ; Do not select Configuration Space
017C  1315     BCF TMR0, 0x6
146:               BSF PMCON1,_PMCON1_RD_POSN   ; Initiate read
017D  1415     BSF TMR0, 0x0
147:               NOP
017E  0000     NOP
148:               NOP
017F  0000     NOP
149:           
0180  0012     MOVIW FSR0++
150:               MOVIW FSR0++
0181  0613     XORWF 0x13, W
151:               XORWF PMDATL,W              ; Compare LSB of word
0182  1D03     BTFSS STATUS, 0x2
152:               BTFSS STATUS,_STATUS_Z_POSN ; Fail if non-zero
0183  298E     GOTO 0x18E
153:               GOTO FAIL_VERIFY
154:           
0184  0012     MOVIW FSR0++
155:               MOVIW FSR0++
0185  0614     XORWF 0x14, W
156:               XORWF PMDATH,W              ; Compare MSB of word
0186  1D03     BTFSS STATUS, 0x2
157:               BTFSS STATUS,_STATUS_Z_POSN ; Fail if non-zero
0187  298E     GOTO 0x18E
158:               GOTO FAIL_VERIFY
159:           
0188  0811     MOVF PIR1, W
160:               MOVF PMADRL,W               ; Check if lower bits of address are '00000'
0189  3A1F     XORLW 0x1F
161:               XORLW 0x1F                  ; Check if we're on the last of 32 addresses
018A  391F     ANDLW 0x1F
162:               ANDLW 0x1F
018B  1903     BTFSC STATUS, 0x2
163:               BTFSC STATUS,_STATUS_Z_POSN ; Exit if last of 32 words
018C  2990     GOTO 0x190
164:               GOTO VERIFY_DONE
018D  2978     GOTO 0x178
165:               GOTO VLOOP
166:           FAIL_VERIFY
018E  3000     MOVLW 0x0
167:               MOVLW 0
018F  00D6     MOVWF dest
168:               MOVWF ?_VerifyRow
169:           VERIFY_DONE
170:           #endasm
0190  0008     RETURN
171:           }
172:           
173:           void UpdateFirmware(void)
174:           {
175:               BYTE row, n;
0014  01AD     CLRF 0x2D
0015  01AE     CLRF 0x2E
176:               WORD count = 0;
0016  303C     MOVLW 0x3C
0017  0022     MOVLB 0x2
0018  00AA     MOVWF 0x2A
0019  3023     MOVLW 0x23
001A  00AB     MOVWF 0x2B
177:               fwbuf = &WorkQue;
178:           
179:               while(1) {
001B  3181     MOVLP 0x1
001C  2191     CALL 0x191
001D  3180     MOVLP 0x0
180:                   USBDeviceTasks();
001E  0021     MOVLB 0x1
001F  086C     MOVF USBDeferStatusStagePacket, W
0020  1D03     BTFSS STATUS, 0x2
0021  2823     GOTO 0x23
0022  282C     GOTO 0x2C
0023  086C     MOVF USBDeferStatusStagePacket, W
0024  0086     MOVWF FSR1L
0025  0187     CLRF FSR1H
0026  0D01     RLF INDF1, W
0027  0D01     RLF INDF1, W
0028  3901     ANDLW 0x1
0029  00A9     MOVWF 0x29
002A  01AA     CLRF 0x2A
002B  282E     GOTO 0x2E
002C  01A9     CLRF 0x29
002D  01AA     CLRF 0x2A
002E  082A     MOVF 0x2A, W
002F  0429     IORWF 0x29, W
0030  1D03     BTFSS STATUS, 0x2
0031  2833     GOTO 0x33
0032  2834     GOTO 0x34
0033  281B     GOTO 0x1B
0034  28CB     GOTO 0xCB
181:                   if(!USBHandleBusy(USBGenericOutHandle)) {
00CB  0025     MOVLB 0x5
00CC  0820     MOVF BDT, W
00CD  3A44     XORLW 0x44
00CE  1903     BTFSC STATUS, 0x2
00CF  2835     GOTO 0x35
00D0  3A16     XORLW 0x16
00D1  1903     BTFSC STATUS, 0x2
00D2  28C9     GOTO 0xC9
00D3  3A05     XORLW 0x5
00D4  1903     BTFSC STATUS, 0x2
00D5  2854     GOTO 0x54
00D6  3A0F     XORLW 0xF
00D7  1903     BTFSC STATUS, 0x2
00D8  28E7     GOTO 0xE7
00D9  28DA     GOTO 0xDA
182:                       switch(OUTPacket[0])
183:                           {
184:                           case 'D':
185:                               // store 32 bytes in workque
0035  3002     MOVLW 0x2
0036  0021     MOVLB 0x1
0037  00AF     MOVWF 0x2F
004C  0AAF     INCF 0x2F, F
004D  3022     MOVLW 0x22
004E  022F     SUBWF 0x2F, W
004F  1C03     BTFSS STATUS, 0x0
0050  2852     GOTO 0x52
0051  2853     GOTO 0x53
0052  2838     GOTO 0x38
0053  28DA     GOTO 0xDA
186:                               for(n = 2; n < 34; n++)
0038  082D     MOVF 0x2D, W
0039  0022     MOVLB 0x2
003A  072A     ADDWF 0x2A, W
003B  0086     MOVWF FSR1L
003C  0021     MOVLB 0x1
003D  082E     MOVF 0x2E, W
003E  0022     MOVLB 0x2
003F  3D2B     ADDWFC 0x2B, W
0040  0087     MOVWF FSR1H
0041  0021     MOVLB 0x1
0042  082F     MOVF 0x2F, W
0043  3EA0     ADDLW 0xA0
0044  0084     MOVWF FSR0L
0045  3002     MOVLW 0x2
0046  0085     MOVWF FSR0H
0047  0800     MOVF INDF0, W
0048  0081     MOVWF INDF1
0049  0AAD     INCF 0x2D, F
004A  1903     BTFSC STATUS, 0x2
004B  0AAE     INCF 0x2E, F
187:                                   fwbuf[count++] = OUTPacket[n];
188:                               break;
189:                           case 'W':
0054  3031     MOVLW 0x31
0055  0024     MOVLB 0x4
0056  00A3     MOVWF 0x23
190:                               INPacket[3] ='1';
0057  0021     MOVLB 0x1
0058  01B0     CLRF 0x30
0059  2888     GOTO 0x88
0086  0021     MOVLB 0x1
0087  0AB0     INCF 0x30, F
0088  0025     MOVLB 0x5
0089  0823     MOVF 0x23, W
008A  0021     MOVLB 0x1
008B  0230     SUBWF 0x30, W
008C  1C03     BTFSS STATUS, 0x0
008D  288F     GOTO 0x8F
008E  2890     GOTO 0x90
008F  285A     GOTO 0x5A
191:                               for(row = 0; row < OUTPacket[3]; row++) {
005A  0025     MOVLB 0x5
005B  0822     MOVF 0x22, W
005C  0020     MOVLB 0x0
005D  00D6     MOVWF dest
005E  01D7     CLRF product
005F  0021     MOVLB 0x1
0060  0830     MOVF 0x30, W
0061  0020     MOVLB 0x0
0062  07D6     ADDWF dest, F
0063  1803     BTFSC STATUS, 0x0
0064  0AD7     INCF product, F
0065  20E8     CALL 0xE8
0066  3180     MOVLP 0x0
192:                                   EraseRow(OUTPacket[2]+row);
0067  0025     MOVLB 0x5
0068  0822     MOVF 0x22, W
0069  0020     MOVLB 0x0
006A  00D6     MOVWF dest
006B  01D7     CLRF product
006C  0021     MOVLB 0x1
006D  0830     MOVF 0x30, W
006E  0020     MOVLB 0x0
006F  00D8     MOVWF off
0070  20FB     CALL 0xFB
0071  3180     MOVLP 0x0
193:                                   WriteRow(OUTPacket[2], row);
0072  0025     MOVLB 0x5
0073  0822     MOVF 0x22, W
0074  0020     MOVLB 0x0
0075  00D6     MOVWF dest
0076  01D7     CLRF product
0077  0021     MOVLB 0x1
0078  0830     MOVF 0x30, W
0079  0020     MOVLB 0x0
007A  00D8     MOVWF off
007B  2149     CALL 0x149
007C  3180     MOVLP 0x0
007D  3800     IORLW 0x0
007E  1D03     BTFSS STATUS, 0x2
007F  2881     GOTO 0x81
0080  2882     GOTO 0x82
0081  2886     GOTO 0x86
194:                                   if(!VerifyRow(OUTPacket[2], row)) {
0082  3030     MOVLW 0x30
0083  0024     MOVLB 0x4
0084  00A3     MOVWF 0x23
195:                                       INPacket[3] = '0';
0085  2890     GOTO 0x90
196:                                       break;
197:                                   }
198:                               }
0090  0022     MOVLB 0x2
0091  0837     MOVF 0x37, W
0092  1D03     BTFSS STATUS, 0x2
0093  2895     GOTO 0x95
0094  289F     GOTO 0x9F
0095  0837     MOVF 0x37, W
0096  0086     MOVWF FSR1L
0097  0187     CLRF FSR1H
0098  0D01     RLF INDF1, W
0099  0D01     RLF INDF1, W
009A  3901     ANDLW 0x1
009B  0021     MOVLB 0x1
009C  00AB     MOVWF 0x2B
009D  01AC     CLRF 0x2C
009E  28A2     GOTO 0xA2
009F  0021     MOVLB 0x1
00A0  01AB     CLRF 0x2B
00A1  01AC     CLRF 0x2C
00A2  082C     MOVF 0x2C, W
00A3  042B     IORWF 0x2B, W
00A4  1D03     BTFSS STATUS, 0x2
00A5  28A7     GOTO 0xA7
00A6  28A8     GOTO 0xA8
00A7  28C0     GOTO 0xC0
199:                               if(!USBHandleBusy(USBGenericInHandle)) {
00A8  3046     MOVLW 0x46
00A9  0024     MOVLB 0x4
00AA  00A0     MOVWF BDT
200:                                   INPacket[0] = 'F';
00AB  0025     MOVLB 0x5
00AC  0821     MOVF 0x21, W
00AD  0024     MOVLB 0x4
00AE  00A1     MOVWF 0x21
201:                                   INPacket[1] = OUTPacket[1];
00AF  0025     MOVLB 0x5
00B0  0822     MOVF 0x22, W
00B1  0024     MOVLB 0x4
00B2  00A2     MOVWF 0x22
202:                                   INPacket[2] = OUTPacket[2];
00B3  0020     MOVLB 0x0
00B4  01D9     CLRF x
00B5  0AD9     INCF x, F
00B6  3020     MOVLW 0x20
00B7  00DA     MOVWF i_718
00B8  300F     MOVLW 0xF
00B9  00DB     MOVWF i
00BA  3001     MOVLW 0x1
00BB  3182     MOVLP 0x2
00BC  22CD     CALL 0x2CD
00BD  3180     MOVLP 0x0
00BE  0022     MOVLB 0x2
00BF  00B7     MOVWF 0x37
203:                                   USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM, (BYTE*)&INPacket[0], USB_RECORD_SIZE);
204:                               }
00C0  303C     MOVLW 0x3C
00C1  0022     MOVLB 0x2
00C2  00AA     MOVWF 0x2A
00C3  3023     MOVLW 0x23
00C4  00AB     MOVWF 0x2B
205:                               fwbuf = &WorkQue;
00C5  0021     MOVLB 0x1
00C6  01AD     CLRF 0x2D
00C7  01AE     CLRF 0x2E
206:                               count = 0;
00C8  28DA     GOTO 0xDA
207:                               break;
208:                           case 'R': // reset the device
00C9  0001     RESET
209:                               asm("reset");
00CA  28DA     GOTO 0xDA
210:                               break;
211:                           case 'X': // exit firmware mode
212:                               return;
213:                           }
00DA  0020     MOVLB 0x0
00DB  01D9     CLRF x
00DC  30A0     MOVLW 0xA0
00DD  00DA     MOVWF i_718
00DE  3040     MOVLW 0x40
00DF  00DB     MOVWF i
00E0  3001     MOVLW 0x1
00E1  3182     MOVLP 0x2
00E2  22CD     CALL 0x2CD
00E3  3180     MOVLP 0x0
00E4  0021     MOVLB 0x1
00E5  00EC     MOVWF USBDeferStatusStagePacket
00E6  281B     GOTO 0x1B
214:                       USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM, (BYTE*)&OUTPacket, USBGEN_EP_SIZE);
215:                   }
216:               }
00E7  0008     RETURN
217:           }
---  /home/chris/Dev/klondike/firmware/Klondike.X/asic.c  -----------------------------------------------
1:             /********
2:              * Klondike ASIC Miner - asic.c - ASIC serial data shifting support
3:              * 
4:              * (C) Copyright 2013 Chris Savery. 
5:              *
6:              * This program is free software: you can redistribute it and/or modify
7:              * it under the terms of the GNU General Public License as published by
8:              * the Free Software Foundation, either version 3 of the License, or
9:              * (at your option) any later version.
10:             *
11:             * This program is distributed in the hope that it will be useful,
12:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
13:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14:             * GNU General Public License for more details.
15:             *
16:             * You should have received a copy of the GNU General Public License
17:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
18:             *
19:             */
20:            #include "GenericTypeDefs.h"
21:            #include "Compiler.h"
22:            #include <xc.h>
23:            #include "klondike.h"
24:            
25:            extern BYTE BankSize;
26:            extern DWORD ClockCfg[2];
27:            extern DWORD NonceRanges[8];
28:            
29:            DWORD PrecalcHashes[6];
30:            
31:            bank2 WORD send32_data; // place in same bank as latc registers!
32:            bank2 BYTE send32_count; // count DWORDS
33:            bank2 BYTE last_bit0, last_bit1;
34:            
35:            void SendAsicData(WORKTASK *work, BYTE split)
36:            {
37:                GIE = 0;
0A95  138B     BCF INTCON, 0x7
38:                last_bit0 = DATA_ZERO; last_bit1 = DATA_ONE;
0A96  3048     MOVLW 0x48
0A97  0022     MOVLB 0x2
0A98  00BD     MOVWF 0x3D
0A99  3090     MOVLW 0x90
0A9A  00BE     MOVWF 0x3E
39:                send32_data = (WORD)&ClockCfg; send32_count = 2;
0A9B  305F     MOVLW 0x5F
0A9C  00AE     MOVWF 0x2E
0A9D  3001     MOVLW 0x1
0A9E  00AF     MOVWF 0x2F
0A9F  3002     MOVLW 0x2
0AA0  00C0     MOVWF SetupPkt
40:                Send32();
0AA1  22DF     CALL 0x2DF
0AA2  3188     MOVLP 0x8
41:                send32_data = (WORD)&work->Merkle; send32_count = 3;
0AA3  26D8     CALL 0x6D8
0AA4  3188     MOVLP 0x8
0AA5  3021     MOVLW 0x21
0AA6  07AE     ADDWF 0x2E, F
0AA7  1803     BTFSC STATUS, 0x0
0AA8  0AAF     INCF 0x2F, F
0AA9  3003     MOVLW 0x3
0AAA  00C0     MOVWF SetupPkt
42:                Send32();
0AAB  22DF     CALL 0x2DF
0AAC  3188     MOVLP 0x8
43:                send32_data = (WORD)&PrecalcHashes[1]; send32_count = 5;
0AAD  30C4     MOVLW 0xC4
0AAE  0022     MOVLB 0x2
0AAF  00AE     MOVWF 0x2E
0AB0  3001     MOVLW 0x1
0AB1  00AF     MOVWF 0x2F
0AB2  3005     MOVLW 0x5
0AB3  00C0     MOVWF SetupPkt
44:                Send32();
0AB4  22DF     CALL 0x2DF
0AB5  3188     MOVLP 0x8
0AB6  26D8     CALL 0x6D8
0AB7  3188     MOVLP 0x8
45:                send32_data = (WORD)&work->MidState; send32_count = 8;
0AB8  0AAE     INCF 0x2E, F
0AB9  1903     BTFSC STATUS, 0x2
0ABA  0AAF     INCF 0x2F, F
0ABB  3008     MOVLW 0x8
0ABC  00C0     MOVWF SetupPkt
46:                Send32();
0ABD  22DF     CALL 0x2DF
0ABE  3188     MOVLP 0x8
47:                send32_data = (WORD)&PrecalcHashes; send32_count = 1;
0ABF  30C0     MOVLW 0xC0
0AC0  0022     MOVLB 0x2
0AC1  00AE     MOVWF 0x2E
0AC2  3001     MOVLW 0x1
0AC3  00AF     MOVWF 0x2F
0AC4  01C0     CLRF SetupPkt
0AC5  0AC0     INCF SetupPkt, F
48:                Send32();
0AC6  22DF     CALL 0x2DF
0AC7  3188     MOVLP 0x8
49:            #ifdef BANKS == 2
50:                last_bit0 = last_bit1 = split;
0AC8  0020     MOVLB 0x0
0AC9  085E     MOVF split, W
0ACA  0022     MOVLB 0x2
0ACB  00BE     MOVWF 0x3E
0ACC  00BD     MOVWF 0x3D
51:            #endif
52:                send32_data = (WORD)&NonceRanges; send32_count = BankSize;
0ACD  30A0     MOVLW 0xA0
0ACE  00AE     MOVWF 0x2E
0ACF  3001     MOVLW 0x1
0AD0  00AF     MOVWF 0x2F
0AD1  086D     MOVF controlTransferState, W
0AD2  00C0     MOVWF SetupPkt
53:                Send32();
0AD3  22DF     CALL 0x2DF
54:                HASH_IDLE();
0AD4  30D8     MOVLW 0xD8
0AD5  0022     MOVLB 0x2
0AD6  008E     MOVWF PORTC
55:                GIE = 1;
0AD7  178B     BSF INTCON, 0x7
56:                ClockCfg[0] = ClockCfg[0] & ~CLOCK_NOCHG_MASK;
0AD8  30FD     MOVLW 0xFD
0AD9  05DF     ANDWF handle, F
0ADA  30FF     MOVLW 0xFF
0ADB  05E0     ANDWF count, F
0ADC  05E1     ANDWF 0x61, F
0ADD  05E2     ANDWF 0x62, F
57:            }
0ADE  0008     RETURN
58:            
59:            void Send32(void)
60:            {
61:                #asm
62:                BANKSEL(LATC) 
0ADF  0022     MOVLB 0x2
63:                MOVF (_send32_data) & 0x7F, W
0AE0  082E     MOVF 0x2E, W
64:                MOVWF FSR1L
0AE1  0086     MOVWF FSR1L
65:                MOVF (_send32_data+1) & 0x7F, W
0AE2  082F     MOVF 0x2F, W
66:                MOVWF FSR1H
0AE3  0087     MOVWF FSR1H
67:            
68:            next_word:
69:                // bit 0
70:                MOVLW DATA_ZERO
0AE4  3048     MOVLW 0x48
71:                CLRF LATC & 0x7F
0AE5  018E     CLRF PORTC
72:                BTFSC INDF1,0
0AE6  1801     BTFSC INDF1, 0x0
73:                MOVLW DATA_ONE
0AE7  3090     MOVLW 0x90
74:                MOVWF LATC & 0x7F
0AE8  008E     MOVWF PORTC
75:            
76:                // bit 1
77:                MOVLW DATA_ZERO
0AE9  3048     MOVLW 0x48
78:                CLRF LATC & 0x7F
0AEA  018E     CLRF PORTC
79:                BTFSC INDF1,1
0AEB  1881     BTFSC INDF1, 0x1
80:                MOVLW DATA_ONE
0AEC  3090     MOVLW 0x90
81:                MOVWF LATC & 0x7F
0AED  008E     MOVWF PORTC
82:            
83:                // bit 2
84:                MOVLW DATA_ZERO
0AEE  3048     MOVLW 0x48
85:                CLRF LATC & 0x7F
0AEF  018E     CLRF PORTC
86:                BTFSC INDF1,2
0AF0  1901     BTFSC INDF1, 0x2
87:                MOVLW DATA_ONE
0AF1  3090     MOVLW 0x90
88:                MOVWF LATC & 0x7F
0AF2  008E     MOVWF PORTC
89:            
90:                // bit 3
91:                MOVLW DATA_ZERO
0AF3  3048     MOVLW 0x48
92:                CLRF LATC & 0x7F
0AF4  018E     CLRF PORTC
93:                BTFSC INDF1,3
0AF5  1981     BTFSC INDF1, 0x3
94:                MOVLW DATA_ONE
0AF6  3090     MOVLW 0x90
95:                MOVWF LATC & 0x7F
0AF7  008E     MOVWF PORTC
96:            
97:                // bit 4
98:                MOVLW DATA_ZERO
0AF8  3048     MOVLW 0x48
99:                CLRF LATC & 0x7F
0AF9  018E     CLRF PORTC
100:               BTFSC INDF1,4
0AFA  1A01     BTFSC INDF1, 0x4
101:               MOVLW DATA_ONE
0AFB  3090     MOVLW 0x90
102:               MOVWF LATC & 0x7F
0AFC  008E     MOVWF PORTC
103:           
104:               // bit 5
105:               MOVLW DATA_ZERO
0AFD  3048     MOVLW 0x48
106:               CLRF LATC & 0x7F
0AFE  018E     CLRF PORTC
107:               BTFSC INDF1,5
0AFF  1A81     BTFSC INDF1, 0x5
108:               MOVLW DATA_ONE
0B00  3090     MOVLW 0x90
109:               MOVWF LATC & 0x7F
0B01  008E     MOVWF PORTC
110:           
111:               // bit 6
112:               MOVLW DATA_ZERO
0B02  3048     MOVLW 0x48
113:               CLRF LATC & 0x7F
0B03  018E     CLRF PORTC
114:               BTFSC INDF1,6
0B04  1B01     BTFSC INDF1, 0x6
115:               MOVLW DATA_ONE
0B05  3090     MOVLW 0x90
116:               MOVWF LATC & 0x7F
0B06  008E     MOVWF PORTC
117:           
118:               // bit 7
119:               MOVLW DATA_ZERO
0B07  3048     MOVLW 0x48
120:               CLRF LATC & 0x7F
0B08  018E     CLRF PORTC
121:               BTFSC INDF1,7
0B09  1B81     BTFSC INDF1, 0x7
122:               MOVLW DATA_ONE
0B0A  3090     MOVLW 0x90
123:               MOVWF LATC & 0x7F
0B0B  008E     MOVWF PORTC
124:           
125:               // select next byte
126:               ADDFSR FSR1, 0x01 & 0x3F
0B0C  3141     ADDFSR 1, 1
127:           
128:               // bit 8
129:               MOVLW DATA_ZERO
0B0D  3048     MOVLW 0x48
130:               CLRF LATC & 0x7F
0B0E  018E     CLRF PORTC
131:               BTFSC INDF1,0
0B0F  1801     BTFSC INDF1, 0x0
132:               MOVLW DATA_ONE
0B10  3090     MOVLW 0x90
133:               MOVWF LATC & 0x7F
0B11  008E     MOVWF PORTC
134:           
135:               // bit 9
136:               MOVLW DATA_ZERO
0B12  3048     MOVLW 0x48
137:               CLRF LATC & 0x7F
0B13  018E     CLRF PORTC
138:               BTFSC INDF1,1
0B14  1881     BTFSC INDF1, 0x1
139:               MOVLW DATA_ONE
0B15  3090     MOVLW 0x90
140:               MOVWF LATC & 0x7F
0B16  008E     MOVWF PORTC
141:           
142:               // bit 10
143:               MOVLW DATA_ZERO
0B17  3048     MOVLW 0x48
144:               CLRF LATC & 0x7F
0B18  018E     CLRF PORTC
145:               BTFSC INDF1,2
0B19  1901     BTFSC INDF1, 0x2
146:               MOVLW DATA_ONE
0B1A  3090     MOVLW 0x90
147:               MOVWF LATC & 0x7F
0B1B  008E     MOVWF PORTC
148:           
149:               // bit 11
150:               MOVLW DATA_ZERO
0B1C  3048     MOVLW 0x48
151:               CLRF LATC & 0x7F
0B1D  018E     CLRF PORTC
152:               BTFSC INDF1,3
0B1E  1981     BTFSC INDF1, 0x3
153:               MOVLW DATA_ONE
0B1F  3090     MOVLW 0x90
154:               MOVWF LATC & 0x7F
0B20  008E     MOVWF PORTC
155:           
156:               // bit 12
157:               MOVLW DATA_ZERO
0B21  3048     MOVLW 0x48
158:               CLRF LATC & 0x7F
0B22  018E     CLRF PORTC
159:               BTFSC INDF1,4
0B23  1A01     BTFSC INDF1, 0x4
160:               MOVLW DATA_ONE
0B24  3090     MOVLW 0x90
161:               MOVWF LATC & 0x7F
0B25  008E     MOVWF PORTC
162:           
163:               // bit 13
164:               MOVLW DATA_ZERO
0B26  3048     MOVLW 0x48
165:               CLRF LATC & 0x7F
0B27  018E     CLRF PORTC
166:               BTFSC INDF1,5
0B28  1A81     BTFSC INDF1, 0x5
167:               MOVLW DATA_ONE
0B29  3090     MOVLW 0x90
168:               MOVWF LATC & 0x7F
0B2A  008E     MOVWF PORTC
169:           
170:               // bit 14
171:               MOVLW DATA_ZERO
0B2B  3048     MOVLW 0x48
172:               CLRF LATC & 0x7F
0B2C  018E     CLRF PORTC
173:               BTFSC INDF1,6
0B2D  1B01     BTFSC INDF1, 0x6
174:               MOVLW DATA_ONE
0B2E  3090     MOVLW 0x90
175:               MOVWF LATC & 0x7F
0B2F  008E     MOVWF PORTC
176:           
177:               // bit 15
178:               MOVLW DATA_ZERO
0B30  3048     MOVLW 0x48
179:               CLRF LATC & 0x7F
0B31  018E     CLRF PORTC
180:               BTFSC INDF1,7
0B32  1B81     BTFSC INDF1, 0x7
181:               MOVLW DATA_ONE
0B33  3090     MOVLW 0x90
182:               MOVWF LATC & 0x7F
0B34  008E     MOVWF PORTC
183:           
184:               // select next byte
185:               ADDFSR FSR1, 0x01 & 0x3F
0B35  3141     ADDFSR 1, 1
186:           
187:               // bit 16
188:               MOVLW DATA_ZERO
0B36  3048     MOVLW 0x48
189:               CLRF LATC & 0x7F
0B37  018E     CLRF PORTC
190:               BTFSC INDF1,0
0B38  1801     BTFSC INDF1, 0x0
191:               MOVLW DATA_ONE
0B39  3090     MOVLW 0x90
192:               MOVWF LATC & 0x7F
0B3A  008E     MOVWF PORTC
193:           
194:               // bit 17
195:               MOVLW DATA_ZERO
0B3B  3048     MOVLW 0x48
196:               CLRF LATC & 0x7F
0B3C  018E     CLRF PORTC
197:               BTFSC INDF1,1
0B3D  1881     BTFSC INDF1, 0x1
198:               MOVLW DATA_ONE
0B3E  3090     MOVLW 0x90
199:               MOVWF LATC & 0x7F
0B3F  008E     MOVWF PORTC
200:           
201:               // bit 18
202:               MOVLW DATA_ZERO
0B40  3048     MOVLW 0x48
203:               CLRF LATC & 0x7F
0B41  018E     CLRF PORTC
204:               BTFSC INDF1,2
0B42  1901     BTFSC INDF1, 0x2
205:               MOVLW DATA_ONE
0B43  3090     MOVLW 0x90
206:               MOVWF LATC & 0x7F
0B44  008E     MOVWF PORTC
207:           
208:               // bit 19
209:               MOVLW DATA_ZERO
0B45  3048     MOVLW 0x48
210:               CLRF LATC & 0x7F
0B46  018E     CLRF PORTC
211:               BTFSC INDF1,3
0B47  1981     BTFSC INDF1, 0x3
212:               MOVLW DATA_ONE
0B48  3090     MOVLW 0x90
213:               MOVWF LATC & 0x7F
0B49  008E     MOVWF PORTC
214:           
215:               // bit 20
216:               MOVLW DATA_ZERO
0B4A  3048     MOVLW 0x48
217:               CLRF LATC & 0x7F
0B4B  018E     CLRF PORTC
218:               BTFSC INDF1,4
0B4C  1A01     BTFSC INDF1, 0x4
219:               MOVLW DATA_ONE
0B4D  3090     MOVLW 0x90
220:               MOVWF LATC & 0x7F
0B4E  008E     MOVWF PORTC
221:           
222:               // bit 21
223:               MOVLW DATA_ZERO
0B4F  3048     MOVLW 0x48
224:               CLRF LATC & 0x7F
0B50  018E     CLRF PORTC
225:               BTFSC INDF1,5
0B51  1A81     BTFSC INDF1, 0x5
226:               MOVLW DATA_ONE
0B52  3090     MOVLW 0x90
227:               MOVWF LATC & 0x7F
0B53  008E     MOVWF PORTC
228:           
229:               // bit 22
230:               MOVLW DATA_ZERO
0B54  3048     MOVLW 0x48
231:               CLRF LATC & 0x7F
0B55  018E     CLRF PORTC
232:               BTFSC INDF1,6
0B56  1B01     BTFSC INDF1, 0x6
233:               MOVLW DATA_ONE
0B57  3090     MOVLW 0x90
234:               MOVWF LATC & 0x7F
0B58  008E     MOVWF PORTC
235:           
236:               // bit 23
237:               MOVLW DATA_ZERO
0B59  3048     MOVLW 0x48
238:               CLRF LATC & 0x7F
0B5A  018E     CLRF PORTC
239:               BTFSC INDF1,7
0B5B  1B81     BTFSC INDF1, 0x7
240:               MOVLW DATA_ONE
0B5C  3090     MOVLW 0x90
241:               MOVWF LATC & 0x7F
0B5D  008E     MOVWF PORTC
242:           
243:               // select next byte
244:               ADDFSR FSR1, 0x01 & 0x3F
0B5E  3141     ADDFSR 1, 1
245:           
246:               // bit 24
247:               MOVLW DATA_ZERO
0B5F  3048     MOVLW 0x48
248:               CLRF LATC & 0x7F
0B60  018E     CLRF PORTC
249:               BTFSC INDF1,0
0B61  1801     BTFSC INDF1, 0x0
250:               MOVLW DATA_ONE
0B62  3090     MOVLW 0x90
251:               MOVWF LATC & 0x7F
0B63  008E     MOVWF PORTC
252:           
253:               // bit 25
254:               MOVLW DATA_ZERO
0B64  3048     MOVLW 0x48
255:               CLRF LATC & 0x7F
0B65  018E     CLRF PORTC
256:               BTFSC INDF1,1
0B66  1881     BTFSC INDF1, 0x1
257:               MOVLW DATA_ONE
0B67  3090     MOVLW 0x90
258:               MOVWF LATC & 0x7F
0B68  008E     MOVWF PORTC
259:           
260:               // bit 26
261:               MOVLW DATA_ZERO
0B69  3048     MOVLW 0x48
262:               CLRF LATC & 0x7F
0B6A  018E     CLRF PORTC
263:               BTFSC INDF1,2
0B6B  1901     BTFSC INDF1, 0x2
264:               MOVLW DATA_ONE
0B6C  3090     MOVLW 0x90
265:               MOVWF LATC & 0x7F
0B6D  008E     MOVWF PORTC
266:           
267:               // bit 27
268:               MOVLW DATA_ZERO
0B6E  3048     MOVLW 0x48
269:               CLRF LATC & 0x7F
0B6F  018E     CLRF PORTC
270:               BTFSC INDF1,3
0B70  1981     BTFSC INDF1, 0x3
271:               MOVLW DATA_ONE
0B71  3090     MOVLW 0x90
272:               MOVWF LATC & 0x7F
0B72  008E     MOVWF PORTC
273:           
274:               // bit 28
275:               MOVLW DATA_ZERO
0B73  3048     MOVLW 0x48
276:               CLRF LATC & 0x7F
0B74  018E     CLRF PORTC
277:               BTFSC INDF1,4
0B75  1A01     BTFSC INDF1, 0x4
278:               MOVLW DATA_ONE
0B76  3090     MOVLW 0x90
279:               MOVWF LATC & 0x7F
0B77  008E     MOVWF PORTC
280:           
281:               // bit 29
282:               MOVLW DATA_ZERO
0B78  3048     MOVLW 0x48
283:               CLRF LATC & 0x7F
0B79  018E     CLRF PORTC
284:               BTFSC INDF1,5
0B7A  1A81     BTFSC INDF1, 0x5
285:               MOVLW DATA_ONE
0B7B  3090     MOVLW 0x90
286:               MOVWF LATC & 0x7F
0B7C  008E     MOVWF PORTC
287:           
288:               // bit 30
289:               MOVLW DATA_ZERO
0B7D  3048     MOVLW 0x48
290:               CLRF LATC & 0x7F
0B7E  018E     CLRF PORTC
291:               BTFSC INDF1,6
0B7F  1B01     BTFSC INDF1, 0x6
292:               MOVLW DATA_ONE
0B80  3090     MOVLW 0x90
293:               MOVWF LATC & 0x7F
0B81  008E     MOVWF PORTC
294:           
295:               // bit 31
296:               MOVF _last_bit0 & 0x7F,W
0B82  083D     MOVF 0x3D, W
297:               CLRF LATC & 0x7F
0B83  018E     CLRF PORTC
298:               BTFSC INDF1,7
0B84  1B81     BTFSC INDF1, 0x7
299:               MOVF _last_bit1 & 0x7F,W
0B85  083E     MOVF 0x3E, W
300:               MOVWF LATC & 0x7F
0B86  008E     MOVWF PORTC
301:           
302:               // select next byte
303:               ADDFSR FSR1, 0x01 & 0x3F
0B87  3141     ADDFSR 1, 1
304:           
305:               // check if done
306:               DECFSZ _send32_count & 0x7F, F
0B88  0BC0     DECFSZ SetupPkt, F
307:               GOTO next_word
0B89  2AE4     GOTO 0x2E4
308:               #endasm
309:               
310:           }
0B8A  0008     RETURN
311:           
312:           #define r(x) ((x-n)&7)
313:           
314:           DWORD rotate(DWORD x, BYTE y)
315:           {
316:               return ((x<<y) | (x>>(32-y)));
0D3B  0859     MOVF x, W
0D3C  00DE     MOVWF split
0D3D  085A     MOVF i_718, W
0D3E  00DF     MOVWF handle
0D3F  085B     MOVF i, W
0D40  00E0     MOVWF count
0D41  085C     MOVF work, W
0D42  00E1     MOVWF 0x61
0D43  085D     MOVF y, W
0D44  3C20     SUBLW 0x20
0D45  0A89     INCF WREG, F
0D46  2D4C     GOTO 0x54C
0D47  1003     BCF STATUS, 0x0
0D48  0CE1     RRF 0x61, F
0D49  0CE0     RRF count, F
0D4A  0CDF     RRF handle, F
0D4B  0CDE     RRF split, F
0D4C  3EFF     ADDLW 0xFF
0D4D  1D03     BTFSS STATUS, 0x2
0D4E  2D47     GOTO 0x547
0D4F  0859     MOVF x, W
0D50  00E2     MOVWF 0x62
0D51  085A     MOVF i_718, W
0D52  00E3     MOVWF 0x63
0D53  085B     MOVF i, W
0D54  00E4     MOVWF 0x64
0D55  085C     MOVF work, W
0D56  00E5     MOVWF 0x65
0D57  0A5D     INCF y, W
0D58  2D5D     GOTO 0x55D
0D59  35E2     LSLF 0x62, F
0D5A  0DE3     RLF 0x63, F
0D5B  0DE4     RLF 0x64, F
0D5C  0DE5     RLF 0x65, F
0D5D  0B89     DECFSZ WREG, F
0D5E  2D59     GOTO 0x559
0D5F  0862     MOVF 0x62, W
0D60  04DE     IORWF split, F
0D61  0863     MOVF 0x63, W
0D62  04DF     IORWF handle, F
0D63  0864     MOVF 0x64, W
0D64  04E0     IORWF count, F
0D65  0865     MOVF 0x65, W
0D66  04E1     IORWF 0x61, F
0D67  0861     MOVF 0x61, W
0D68  00DC     MOVWF work
0D69  0860     MOVF count, W
0D6A  00DB     MOVWF i
0D6B  085F     MOVF handle, W
0D6C  00DA     MOVWF i_718
0D6D  085E     MOVF split, W
0D6E  00D9     MOVWF x
317:           }
0D6F  0008     RETURN
318:           
319:           void AsicPreCalc(WORKTASK *work)
320:           {
321:               DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
0B8B  30D8     MOVLW 0xD8
0B8C  0086     MOVWF FSR1L
0B8D  3001     MOVLW 0x1
0B8E  0087     MOVWF FSR1H
0B8F  30A8     MOVLW 0xA8
0B90  0084     MOVWF FSR0L
0B91  3000     MOVLW 0x0
0B92  0085     MOVWF FSR0H
0B93  300C     MOVLW 0xC
0B94  00FF     MOVWF 0x7F
0B95  0016     MOVIW FSR1++
0B96  001A     MOVWI FSR0++
0B97  0BFF     DECFSZ 0x7F, F
0B98  2B95     GOTO 0x395
15F9  3498     RETLW 0x98
15FA  342F     RETLW 0x2F
15FB  348A     RETLW 0x8A
15FC  3442     RETLW 0x42
15FD  3491     RETLW 0x91
15FE  3444     RETLW 0x44
15FF  3437     RETLW 0x37
1600  3471     RETLW 0x71
1601  34CF     RETLW 0xCF
1602  34FB     RETLW 0xFB
1603  34C0     RETLW 0xC0
1604  34B5     RETLW 0xB5
322:               DWORD x, y, z;
323:               DWORD m[8];
324:               BYTE n;
325:               
326:               for(n = 0; n < 8; n++)
0B99  0021     MOVLB 0x1
0B9A  01E0     CLRF count
0BB1  3008     MOVLW 0x8
0BB2  0AE0     INCF count, F
0BB3  0260     SUBWF count, W
0BB4  1C03     BTFSS STATUS, 0x0
0BB5  2B9B     GOTO 0x39B
327:                   m[n] = work->MidState[n];
0B9B  2680     CALL 0x680
0B9C  3188     MOVLP 0x8
0B9D  0086     MOVWF FSR1L
0B9E  0823     MOVF 0x23, W
0B9F  0087     MOVWF FSR1H
0BA0  3141     ADDFSR 1, 1
0BA1  26BA     CALL 0x6BA
0BA2  3188     MOVLP 0x8
0BA3  0860     MOVF count, W
0BA4  0709     ADDWF WREG, W
0BA5  0709     ADDWF WREG, W
0BA6  3EB8     ADDLW 0xB8
0BA7  0086     MOVWF FSR1L
0BA8  0187     CLRF FSR1H
0BA9  0824     MOVF 0x24, W
0BAA  3FC0     MOVWI [0]FSR1
0BAB  0825     MOVF 0x25, W
0BAC  3FC1     MOVWI [1]FSR1
0BAD  0826     MOVF 0x26, W
0BAE  3FC2     MOVWI [2]FSR1
0BAF  0827     MOVF 0x27, W
0BB0  3FC3     MOVWI [3]FSR1
328:           
329:               for(n = 0; n < 3; n++) {
0BB6  01E0     CLRF count
0D28  3003     MOVLW 0x3
0D29  0AE0     INCF count, F
0D2A  0260     SUBWF count, W
0D2B  1803     BTFSC STATUS, 0x0
0D2C  0008     RETURN
0D2D  2BB7     GOTO 0x3B7
330:           
331:                   x = m[5-n] ^ m[6-n];
0BB7  2652     CALL 0x652
0BB8  3188     MOVLP 0x8
0BB9  252E     CALL 0x52E
0BBA  3188     MOVLP 0x8
0BBB  3E18     ADDLW 0x18
0BBC  262B     CALL 0x62B
0BBD  3188     MOVLP 0x8
0BBE  252E     CALL 0x52E
0BBF  3188     MOVLP 0x8
0BC0  3E14     ADDLW 0x14
0BC1  3EB8     ADDLW 0xB8
0BC2  0086     MOVWF FSR1L
0BC3  0187     CLRF FSR1H
0BC4  3F40     MOVIW [0]FSR1
0BC5  0021     MOVLB 0x1
0BC6  00A4     MOVWF 0x24
0BC7  3F41     MOVIW [1]FSR1
0BC8  00A5     MOVWF 0x25
0BC9  3F42     MOVIW [2]FSR1
0BCA  00A6     MOVWF 0x26
0BCB  3F43     MOVIW [3]FSR1
0BCC  00A7     MOVWF 0x27
0BCD  0820     MOVF BDT, W
0BCE  0624     XORWF 0x24, W
0BCF  00DC     MOVWF work
0BD0  0821     MOVF 0x21, W
0BD1  0625     XORWF 0x25, W
0BD2  00DD     MOVWF y
0BD3  0822     MOVF 0x22, W
0BD4  0626     XORWF 0x26, W
0BD5  00DE     MOVWF split
0BD6  0823     MOVF 0x23, W
0BD7  0627     XORWF 0x27, W
0BD8  00DF     MOVWF handle
0BD9  2652     CALL 0x652
0BDA  3188     MOVLP 0x8
332:                   x = x & m[4-n];
0BDB  252E     CALL 0x52E
0BDC  3188     MOVLP 0x8
0BDD  3E10     ADDLW 0x10
0BDE  3EB8     ADDLW 0xB8
0BDF  263D     CALL 0x63D
0BE0  3188     MOVLP 0x8
0BE1  26E9     CALL 0x6E9
0BE2  3188     MOVLP 0x8
0BE3  2652     CALL 0x652
0BE4  3188     MOVLP 0x8
333:                   x = m[6-n] ^ x;
0BE5  252E     CALL 0x52E
0BE6  3188     MOVLP 0x8
0BE7  3E18     ADDLW 0x18
0BE8  3EB8     ADDLW 0xB8
0BE9  263D     CALL 0x63D
0BEA  3188     MOVLP 0x8
0BEB  06DC     XORWF work, F
0BEC  0821     MOVF 0x21, W
0BED  06DD     XORWF y, F
0BEE  0822     MOVF 0x22, W
0BEF  06DE     XORWF split, F
0BF0  0823     MOVF 0x23, W
0BF1  06DF     XORWF handle, F
334:                   x += K[n];
0BF2  0860     MOVF count, W
0BF3  0709     ADDWF WREG, W
0BF4  0709     ADDWF WREG, W
0BF5  3EA8     ADDLW 0xA8
0BF6  0086     MOVWF FSR1L
0BF7  3F40     MOVIW [0]FSR1
0BF8  26C8     CALL 0x6C8
0BF9  3188     MOVLP 0x8
0BFA  2680     CALL 0x680
0BFB  3188     MOVLP 0x8
335:                   x += work->Merkle[n];
0BFC  3E21     ADDLW 0x21
0BFD  0086     MOVWF FSR1L
0BFE  3000     MOVLW 0x0
0BFF  3D23     ADDWFC 0x23, W
0C00  0087     MOVWF FSR1H
0C01  3F40     MOVIW [0]FSR1
0C02  26C8     CALL 0x6C8
0C03  3188     MOVLP 0x8
0C04  2652     CALL 0x652
0C05  3188     MOVLP 0x8
336:                   x += m[7-n];
0C06  252E     CALL 0x52E
0C07  3188     MOVLP 0x8
0C08  3E1C     ADDLW 0x1C
0C09  3EB8     ADDLW 0xB8
0C0A  0086     MOVWF FSR1L
0C0B  0187     CLRF FSR1H
0C0C  3F40     MOVIW [0]FSR1
0C0D  0021     MOVLB 0x1
0C0E  26C8     CALL 0x6C8
0C0F  3188     MOVLP 0x8
0C10  2652     CALL 0x652
0C11  3188     MOVLP 0x8
337:                   y = rotate(m[4-n], 26);
0C12  252E     CALL 0x52E
0C13  3188     MOVLP 0x8
0C14  2670     CALL 0x670
0C15  3188     MOVLP 0x8
0C16  2668     CALL 0x668
0C17  3188     MOVLP 0x8
0C18  301A     MOVLW 0x1A
0C19  00DD     MOVWF y
0C1A  253B     CALL 0x53B
0C1B  3188     MOVLP 0x8
0C1C  2658     CALL 0x658
0C1D  3188     MOVLP 0x8
0C1E  2652     CALL 0x652
0C1F  3188     MOVLP 0x8
338:                   z = rotate(m[4-n], 21);
0C20  252E     CALL 0x52E
0C21  3188     MOVLP 0x8
0C22  2670     CALL 0x670
0C23  3188     MOVLP 0x8
0C24  2668     CALL 0x668
0C25  3188     MOVLP 0x8
0C26  3015     MOVLW 0x15
0C27  00DD     MOVWF y
0C28  253B     CALL 0x53B
0C29  3188     MOVLP 0x8
0C2A  085C     MOVF work, W
0C2B  0021     MOVLB 0x1
0C2C  00B7     MOVWF 0x37
0C2D  0020     MOVLB 0x0
0C2E  085B     MOVF i, W
0C2F  0021     MOVLB 0x1
0C30  00B6     MOVWF 0x36
0C31  0020     MOVLB 0x0
0C32  085A     MOVF i_718, W
0C33  0021     MOVLB 0x1
0C34  00B5     MOVWF 0x35
0C35  0020     MOVLB 0x0
0C36  0859     MOVF x, W
0C37  0021     MOVLB 0x1
0C38  00B4     MOVWF 0x34
339:                   z = y^z;
0C39  0858     MOVF off, W
0C3A  26E1     CALL 0x6E1
0C3B  3188     MOVLP 0x8
0C3C  2652     CALL 0x652
0C3D  3188     MOVLP 0x8
340:                   y = rotate(m[4-n], 7);
0C3E  252E     CALL 0x52E
0C3F  3188     MOVLP 0x8
0C40  2670     CALL 0x670
0C41  3188     MOVLP 0x8
0C42  2668     CALL 0x668
0C43  3188     MOVLP 0x8
0C44  3007     MOVLW 0x7
0C45  00DD     MOVWF y
0C46  253B     CALL 0x53B
0C47  3188     MOVLP 0x8
0C48  2658     CALL 0x658
0C49  3188     MOVLP 0x8
0C4A  26E1     CALL 0x6E1
0C4B  3188     MOVLP 0x8
341:                   z = y^z;
342:                   m[7-n] = z+x;
0C4C  0834     MOVF 0x34, W
0C4D  075C     ADDWF work, W
0C4E  00A0     MOVWF BDT
0C4F  0835     MOVF 0x35, W
0C50  3D5D     ADDWFC y, W
0C51  00A1     MOVWF 0x21
0C52  0836     MOVF 0x36, W
0C53  3D5E     ADDWFC split, W
0C54  00A2     MOVWF 0x22
0C55  0837     MOVF 0x37, W
0C56  3D5F     ADDWFC handle, W
0C57  00A3     MOVWF 0x23
0C58  2652     CALL 0x652
0C59  3188     MOVLP 0x8
0C5A  252E     CALL 0x52E
0C5B  3188     MOVLP 0x8
0C5C  26FD     CALL 0x6FD
0C5D  3188     MOVLP 0x8
0C5E  2676     CALL 0x676
0C5F  3188     MOVLP 0x8
0C60  2652     CALL 0x652
0C61  3188     MOVLP 0x8
343:                   m[3-n] = m[3-n] + m[7-n];
0C62  252E     CALL 0x52E
0C63  3188     MOVLP 0x8
0C64  3E1C     ADDLW 0x1C
0C65  262B     CALL 0x62B
0C66  3188     MOVLP 0x8
0C67  252E     CALL 0x52E
0C68  3188     MOVLP 0x8
0C69  3E0C     ADDLW 0xC
0C6A  3EB8     ADDLW 0xB8
0C6B  0086     MOVWF FSR1L
0C6C  0187     CLRF FSR1H
0C6D  3F40     MOVIW [0]FSR1
0C6E  0021     MOVLB 0x1
0C6F  07A0     ADDWF BDT, F
0C70  3F41     MOVIW [1]FSR1
0C71  3DA1     ADDWFC 0x21, F
0C72  3F42     MOVIW [2]FSR1
0C73  3DA2     ADDWFC 0x22, F
0C74  3F43     MOVIW [3]FSR1
0C75  3DA3     ADDWFC 0x23, F
0C76  2652     CALL 0x652
0C77  3188     MOVLP 0x8
0C78  252E     CALL 0x52E
0C79  3188     MOVLP 0x8
0C7A  3E0C     ADDLW 0xC
0C7B  3EB8     ADDLW 0xB8
0C7C  0086     MOVWF FSR1L
0C7D  0187     CLRF FSR1H
0C7E  2676     CALL 0x676
0C7F  3188     MOVLP 0x8
344:                   x = rotate(m[r(0)], 30);
0C80  2693     CALL 0x693
0C81  3188     MOVLP 0x8
0C82  3F40     MOVIW [0]FSR1
0C83  0020     MOVLB 0x0
0C84  2668     CALL 0x668
0C85  3188     MOVLP 0x8
0C86  301E     MOVLW 0x1E
0C87  00DD     MOVWF y
0C88  253B     CALL 0x53B
0C89  3188     MOVLP 0x8
0C8A  26A4     CALL 0x6A4
0C8B  3188     MOVLP 0x8
0C8C  2693     CALL 0x693
0C8D  3188     MOVLP 0x8
345:                   y = rotate(m[r(0)], 19);
0C8E  0187     CLRF FSR1H
0C8F  3F40     MOVIW [0]FSR1
0C90  0020     MOVLB 0x0
0C91  2668     CALL 0x668
0C92  3188     MOVLP 0x8
0C93  3013     MOVLW 0x13
0C94  00DD     MOVWF y
0C95  253B     CALL 0x53B
0C96  3188     MOVLP 0x8
0C97  2658     CALL 0x658
0C98  3188     MOVLP 0x8
346:                   y = y^x;
0C99  085C     MOVF work, W
0C9A  26D0     CALL 0x6D0
0C9B  3188     MOVLP 0x8
0C9C  2693     CALL 0x693
0C9D  3188     MOVLP 0x8
347:                   x = rotate(m[r(0)], 10);
0C9E  0187     CLRF FSR1H
0C9F  3F40     MOVIW [0]FSR1
0CA0  0020     MOVLB 0x0
0CA1  2668     CALL 0x668
0CA2  3188     MOVLP 0x8
0CA3  300A     MOVLW 0xA
0CA4  00DD     MOVWF y
0CA5  253B     CALL 0x53B
0CA6  3188     MOVLP 0x8
0CA7  26A4     CALL 0x6A4
0CA8  3188     MOVLP 0x8
0CA9  26D0     CALL 0x6D0
0CAA  3188     MOVLP 0x8
348:                   y = x^y;
349:                   x = m[r(0)] | m[r(1)];
0CAB  0860     MOVF count, W
0CAC  3C01     SUBLW 0x1
0CAD  26B4     CALL 0x6B4
0CAE  3188     MOVLP 0x8
0CAF  0187     CLRF FSR1H
0CB0  3F40     MOVIW [0]FSR1
0CB1  264A     CALL 0x64A
0CB2  3188     MOVLP 0x8
0CB3  2693     CALL 0x693
0CB4  3188     MOVLP 0x8
0CB5  26BA     CALL 0x6BA
0CB6  3188     MOVLP 0x8
0CB7  0820     MOVF BDT, W
0CB8  0424     IORWF 0x24, W
0CB9  00DC     MOVWF work
0CBA  0821     MOVF 0x21, W
0CBB  0425     IORWF 0x25, W
0CBC  00DD     MOVWF y
0CBD  0822     MOVF 0x22, W
0CBE  0426     IORWF 0x26, W
0CBF  00DE     MOVWF split
0CC0  0823     MOVF 0x23, W
0CC1  0427     IORWF 0x27, W
0CC2  00DF     MOVWF handle
350:                   x = m[r(2)] & x;
0CC3  0860     MOVF count, W
0CC4  3C02     SUBLW 0x2
0CC5  26B4     CALL 0x6B4
0CC6  3188     MOVLP 0x8
0CC7  3F40     MOVIW [0]FSR1
0CC8  264A     CALL 0x64A
0CC9  3188     MOVLP 0x8
0CCA  0820     MOVF BDT, W
0CCB  26E9     CALL 0x6E9
0CCC  3188     MOVLP 0x8
351:                   z = m[r(0)] & m[r(1)];
0CCD  0860     MOVF count, W
0CCE  3C01     SUBLW 0x1
0CCF  26B4     CALL 0x6B4
0CD0  3188     MOVLP 0x8
0CD1  3F40     MOVIW [0]FSR1
0CD2  264A     CALL 0x64A
0CD3  3188     MOVLP 0x8
0CD4  2693     CALL 0x693
0CD5  3188     MOVLP 0x8
0CD6  26BA     CALL 0x6BA
0CD7  3188     MOVLP 0x8
0CD8  0820     MOVF BDT, W
0CD9  0524     ANDWF 0x24, W
0CDA  00B4     MOVWF 0x34
0CDB  0821     MOVF 0x21, W
0CDC  0525     ANDWF 0x25, W
0CDD  00B5     MOVWF 0x35
0CDE  0822     MOVF 0x22, W
0CDF  0526     ANDWF 0x26, W
0CE0  00B6     MOVWF 0x36
0CE1  0823     MOVF 0x23, W
0CE2  0527     ANDWF 0x27, W
0CE3  00B7     MOVWF 0x37
352:                   x = x | z;
0CE4  0834     MOVF 0x34, W
0CE5  04DC     IORWF work, F
0CE6  0835     MOVF 0x35, W
0CE7  04DD     IORWF y, F
0CE8  0836     MOVF 0x36, W
0CE9  04DE     IORWF split, F
0CEA  0837     MOVF 0x37, W
0CEB  04DF     IORWF handle, F
353:                   m[7-n] += y + x;
0CEC  0858     MOVF off, W
0CED  075C     ADDWF work, W
0CEE  00A0     MOVWF BDT
0CEF  0859     MOVF x, W
0CF0  3D5D     ADDWFC y, W
0CF1  00A1     MOVWF 0x21
0CF2  085A     MOVF i_718, W
0CF3  3D5E     ADDWFC split, W
0CF4  00A2     MOVWF 0x22
0CF5  085B     MOVF i, W
0CF6  3D5F     ADDWFC handle, W
0CF7  00A3     MOVWF 0x23
0CF8  2652     CALL 0x652
0CF9  3188     MOVLP 0x8
0CFA  252E     CALL 0x52E
0CFB  3188     MOVLP 0x8
0CFC  26FD     CALL 0x6FD
0CFD  3188     MOVLP 0x8
0CFE  0021     MOVLB 0x1
0CFF  0820     MOVF BDT, W
0D00  0781     ADDWF INDF1, F
0D01  3141     ADDFSR 1, 1
0D02  0821     MOVF 0x21, W
0D03  3D81     ADDWFC INDF1, F
0D04  3141     ADDFSR 1, 1
0D05  0822     MOVF 0x22, W
0D06  3D81     ADDWFC INDF1, F
0D07  3141     ADDFSR 1, 1
0D08  0823     MOVF 0x23, W
0D09  3D81     ADDWFC INDF1, F
0D0A  2652     CALL 0x652
0D0B  3188     MOVLP 0x8
354:           
355:                   PrecalcHashes[2-n] = m[7-n];
0D0C  252E     CALL 0x52E
0D0D  3188     MOVLP 0x8
0D0E  3E1C     ADDLW 0x1C
0D0F  262B     CALL 0x62B
0D10  3188     MOVLP 0x8
0D11  252E     CALL 0x52E
0D12  3188     MOVLP 0x8
0D13  3EC8     ADDLW 0xC8
0D14  0086     MOVWF FSR1L
0D15  3001     MOVLW 0x1
0D16  0087     MOVWF FSR1H
0D17  2676     CALL 0x676
0D18  3188     MOVLP 0x8
0D19  2652     CALL 0x652
0D1A  3188     MOVLP 0x8
356:                   PrecalcHashes[5-n] = m[3-n];
0D1B  252E     CALL 0x52E
0D1C  3188     MOVLP 0x8
0D1D  3E0C     ADDLW 0xC
0D1E  262B     CALL 0x62B
0D1F  3188     MOVLP 0x8
0D20  252E     CALL 0x52E
0D21  3188     MOVLP 0x8
0D22  3ED4     ADDLW 0xD4
0D23  0086     MOVWF FSR1L
0D24  3001     MOVLW 0x1
0D25  0087     MOVWF FSR1H
0D26  2676     CALL 0x676
0D27  3188     MOVLP 0x8
357:               }
358:           }
0D2E  0020     MOVLB 0x0
359:           
360:           //#define R(a, b, c, d, e, f, g, h, w, k) \
361:           //    h = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \
362:           //    d = d + h; \
363:           //    h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
364:           
365:           /* this version uses too much stack and causes overflow
366:            * re-written above to be more flat and as first step to
367:            * assembly optimization
368:            *
369:           DWORD rotate(DWORD x, BYTE y)
370:           {
371:               return ((x<<y) | (x>>(32-y)));
372:           }
373:           
374:           void R1(DWORD *m, DWORD w, DWORD k)
375:           {
376:               m[7] = m[7] + (rotate(m[4], 26) ^ rotate(m[4], 21) ^ rotate(m[4], 7)) + (m[6] ^ (m[4] & (m[5] ^ m[6]))) + k + w;
377:               m[3] = m[3] + m[7];
378:               m[7] = m[7] + (rotate(m[0], 30) ^ rotate(m[0], 19) ^ rotate(m[0], 10)) + ((m[0] & m[1]) | (m[2] & (m[0] | m[1])));
379:           }
380:           
381:           void R2(DWORD *m)
382:           {
383:               DWORD hold = m[7];
384:               for(BYTE x=7; x > 0; x--)
385:                   m[x] = m[x-1];
386:               m[0] = hold;
387:           }
388:           
389:           extern BYTE WorkNow;
390:           extern WORKTASK WorkQue[MAX_WORK_COUNT];
391:           
392:           DWORD precalc_hash[6];
393:           
394:           void HasherPreCalc(void)
395:           {
396:               const DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
397:               DWORD m[8];
398:               BYTE n;
399:               for(n = 0; n < 8; n++)
400:                   m[n] = WorkQue[WorkNow].MidState[n];
401:           
402:               R1(m, WorkQue[WorkNow].Merkle[0], K[0]);
403:               precalc_hash[0] = m[7];
404:               precalc_hash[3] = m[3];
405:               R2(m);
406:               R1(m, WorkQue[WorkNow].Merkle[1], K[1]);
407:               precalc_hash[1] = m[7];
408:               precalc_hash[4] = m[3];
409:               R2(m);
410:               R1(m, WorkQue[WorkNow].Merkle[2], K[2]);
411:               precalc_hash[2] = m[7];
412:               precalc_hash[5] = m[3];
413:           }
414:           */
